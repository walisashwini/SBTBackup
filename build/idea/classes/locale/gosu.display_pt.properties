ARRAY = Matriz
BEAN = Bean
BOOLEAN = Booliano
DATETIME = Data e hora
FUNCTION = Função
IDENTIFIER = Identificador
METATYPENAME = Tipo
NULLTYPENAME = Nulo
NUMERIC = Número
STRING = Cadeia de caracteres
MSG_SYNTAX_ERROR = Erro de sintaxe.
MSG_BAD_IDENTIFIER_NAME = Não foi possível resolver o símbolo para\: {0}
MSG_END_OF_STMT = Esperando o final da instrução. Operador inválido ou ausente.
MSG_END_OF_EXPRESSION = Esperando o final da expressão. Operador inválido ou ausente.
MSG_EXPECTING_OPERATOR_TO_FOLLOW_EXPRESSION = Instrução incompleta. Esperava-se que o operador seguisse a expressão.
MSG_EXPECTING_ARGS = Esperando argumentos para a função {0}
MSG_EXPECTING_EXPRESSION_CLOSE = Esperando ')' para fechar a expressão entre parênteses.
MSG_EXPECTING_FUNCTION_CLOSE = Esperando ')' para fechar a chamada da função.
MSG_EXPECTING_TYPE_NAME = Esperando um nome de tipo.
MSG_PARAMETERIZATION_NOT_SUPPORTED_FOR_TYPE = {0} não dá suporte a parametrização.
MSG_NO_ARGUMENTS = A função {0} não aceita argumentos.
MSG_NULL_SYMBOL_TABLE = A tabela de símbolos é nula ou vazia.
MSG_TYPE_MISMATCH = O tipo "{1}" não pode ser convertido em "{0}"
MSG_VALUE_MISMATCH = Incompatibilidade de valor. O valor literal "{0}" não pode ser convertido em um {1}.
MSG_WRONG_NUM_OF_ARGS = Número incorreto de argumentos para a função {0}
MSG_EXPECTING_NAME_FUNCTION_DEF = Esperando um nome para a função.
MSG_EXPECTING_LEFTPAREN_FUNCTION_DEF = Esperando '(' para abrir a declaração de argumento da função.
MSG_EXPECTING_RIGHTPAREN_FUNCTION_DEF = Esperando ')' para fechar a declaração de argumentos da função.
MSG_EXPECTING_TYPE_FUNCTION_DEF = Esperando a cláusula "\:" para a declaração da função.
MSG_EXPECTING_TYPE_LITERAL_FUNCTION_DEF = Esperando o tipo depois de "\:" para a declaração da função.
MSG_EXPECTING_IDENTIFIER_FOREACH = Esperando o identificador para a instrução "for...in".
MSG_EXPECTING_IDENTIFIER_FOREACH_INDEX = Esperando identificador no "index" da instrução "for...in".
MSG_EXPECTING_IDENTIFIER_FOREACH_ITERATOR = Esperando identificador no "iterator" da instrução "for...in".
MSG_FOREACH_ITERATOR_NOT_ALLOWED = "iterator" não é permitido para a instrução "for...in" sem uma variável loop.
MSG_ITERATOR_SYMBOL_ONLY_SUPPORTED_ON_ITERABLE_OBJECTS = Um símbolo "iterator" só dá suporte a objetos Iterable.
MSG_EXPECTING_IDENTIFIER_EXISTS = Esperando identificador para a expressão "exists"
MSG_EXPECTING_IDENTIFIER_EXISTS_INDEX = Esperando identificador no "index" da expressão "exists".
MSG_EXPECTING_IN_FOREACH = Esperando a cláusula "in" para a instrução "for...in".
MSG_EXPECTING_LEFTPAREN_FE = Esperando '(' na instrução "for...in".
MSG_EXPECTING_RIGHTPAREN_FE = Esperando ')' na instrução "for...in".
MSG_EXPECTING_LEFTPAREN_BLOCK = Esperando '(' na declaração de tipos de bloco.
MSG_EXPECTING_RIGHTPAREN_BLOCK = Esperando ')' na declaração de tipos de bloco.
MSG_EXPECTING_COLON_BLOCK = Esperando '\:' na declaração de tipos do bloco.
MSG_EXPECTING_IN_EXISTS = Esperando a cláusula "in" para a expressão "exists".
MSG_EXPECTING_WHERE_EXISTS = Esperando a cláusula "where" para a expressão "exists".
MSG_EXPECTING_LEFTPAREN_EXISTS = Esperando '(' na expressão "exists".
MSG_EXPECTING_RIGHTPAREN_EXISTS = Esperando ')' na expressão "exists".
MSG_EXPECTING_LEFTPAREN_EVAL = Esperando '(' para abrir a expressão "eval".
MSG_EXPECTING_RIGHTPAREN_EVAL = Esperando ')' para fechar a expressão "eval".
MSG_EXPECTING_LEFTPAREN_CATCH = Esperando '(' na cláusula "catch" da instrução "try...catch...finally".
MSG_EXPECTING_RIGHTPAREN_CATCH = Esperando ')' na cláusula "catch" da instrução "try...catch...finally".
MSG_EXPECTING_IDENTIFIER_CATCH = Esperando o identificador para a cláusula "catch" da instrução "try...catch...finally".
MSG_CATCH_OR_FINALLY_REQUIRED = Esperando uma cláusula "catch" ou "finally" na instrução "try...catch...finally".
MSG_EXPECTING_LEFTBRACE_STMTBLOCK = Esperando '{' para abrir o bloco da instrução.
MSG_EXPECTING_RIGHTBRACE_STMTBLOCK = Esperando '}' para fechar o bloco da instrução.
MSG_EXPECTING_LEFTPAREN_IF = Esperando '(' para abrir a condição "if".
MSG_EXPECTING_RIGHTPAREN_IF = Esperando ')' para fechar a condição "if".
MSG_EXPECTING_LEFTPAREN_SWITCH = Esperando '(' para abrir a expressão "switch".
MSG_EXPECTING_RIGHTPAREN_SWITCH = Esperando ')' para fechar a expressão "switch".
MSG_EXPECTING_LEFTPAREN_WHILE = Esperando '(' para abrir a condição "while".
MSG_EXPECTING_RIGHTPAREN_WHILE = Esperando ')' para fechar a condição "while".
MSG_EXPECTING_LEFTPAREN_EXCEPT = Esperando '(' para abrir a condição "expect".
MSG_EXPECTING_RIGHTPAREN_EXCEPT = Esperando ')' para fechar a condição "except".
MSG_EXPECTING_WHILE_DO = Esperando a cláusula "while" para fechar a instrução "do...while".
MSG_LOOP_DOESNT_LOOP = O loop não faz loop
MSG_EXPECTING_EQUALS_ASSIGN = Esperando '\=' para instrução de atribuição.
MSG_EXPECTING_EXPRESSSION_ON_RHS = Esperando uma expressão rhs válida para instrução de atribuição.
MSG_EXPECTING_STATEMENT = Esperando instrução.
MSG_EXPECTING_BEANTYPE = Esperando tipo complexo para acesso do membro. Encontrado\: {0}
MSG_EXPECTING_ARRAYTYPE_FOREACH = Esperando o tipo iterável depois da cláusula 'in' na instrução "for...in". Encontrado\: {0}
MSG_EXPECTING_ARRAYTYPE_EXISTS = Esperando o tipo Array depois da cláusula 'in' na expressão "exists". Encontrado\:
MSG_EXPECTING_IDENTIFIER_ARG_TYPE = Esperando o nome do tipo depois de "\:" para o argumento da função.
MSG_EXPECTING_ARRAY_BRACKET = Esperando ']' para fechar o literal de tipo de matriz.
MSG_EXPECTING_NEW_ARRAY_OR_CTOR = Esperando '[' ou '(' para iniciar uma nova operação de objeto ou matriz.
MSG_EXPECTING_OPEN_BRACE_FOR_NEW_ARRAY = Esperando '{{' para iniciar uma lista de expressões de valor de matriz.
MSG_EXPECTING_CLOSE_BRACE_FOR_NEW_ARRAY = Esperando '}' para fechar a lista de expressões de valor de matriz.
MSG_EXPECTING_CLOSING_ANGLE_BRACKET_FOR_TYPE = Esperando '>' para fechar o tipo literal parametrizado.
MSG_EXPECTING_CLOSING_ANGLE_BRACKET_FOR_TYPE_VAR_LIST = Esperando '>' para fechar a lista de variáveis de tipo.
MSG_COULD_NOT_PARAMETERIZE = Não foi possível parametrizar.
MSG_EXPECTING_OPEN_BRACE_FOR_SWITCH = Esperando '{{' para abrir a instrução "switch".
MSG_EXPECTING_CLOSE_BRACE_FOR_SWITCH = Esperando '}' para fechar a instrução "switch".
MSG_EXPECTING_COLON_TERNARY = Esperando '\:' para expressão ternária condicional.
MSG_EXPECTING_REFERENCE_TYPE = Esperando o tipo de referência, o tipo primitivo não é permitido aqui.
MSG_LOSS_OF_PRECISION_IN_CONDITIONAL_EXP = Os tipos não podem ser convertidos sem perda de precisão. Converta-os explicitamente.
MSG_EXPECTING_CASE_COLON = Esperando '\:' para fechar a expressão "case".
MSG_DUPLICATE_CASE_EXPRESSION = Expressão de caso duplicada.
MSG_TYPE_MISMATCH_IN_CONDIITIONAL_EXP = Incompatibilidade de tipos na expressão ternária condicional.
MSG_EXPECTING_IDENTIFIER_VAR = Esperando um nome de variável.
MSG_EXPECTING_VAR_STMT = Esperando a declaração "var".
MSG_EXPECTING_TYPELITERAL = Esperando um literal de tipo no lado direito da expressão.
MSG_EXPECTING_TYPELITERAL_OR_NAMESPACE = Esperando um literal de tipo ou namespace.
MSG_PRIMITIVES_NOT_ALLOWED_HERE = Tipos primitivos não são permitidos aqui.
MSG_INCONVERTIBLE_TYPES = Tipos inconversíveis; não é possível converter {0} em {1}
MSG_BAD_NAMESPACE = {0} não é um namespace válido.
MSG_EXPECTING_ARRAYLENGTH = Esperando a propriedade de matriz "length"
MSG_ENTITYBEANS_ARE_IMMUTABLE = A propriedade do objeto não pode ser modificada diretamente.
MSG_MULTIPLE_DEFAULT_CLAUSES_NOT_PERMITTED = Várias cláusulas 'padrão' detectadas na instrução "switch".
MSG_CASE_CLAUSE_MAY_NOT_FOLLOW_DEFAULT_CLAUSE = Uma cláusula de caso não pode seguir a cláusula 'default'.
MSG_METHOD_NOT_VISIBLE = A função, "{0}", não é visível nas restrições de visibilidade do analisador.
MSG_PROPERTY_NOT_VISIBLE = A propriedade "{0}" não é visível nas restrições de visibilidade do analisador.
MSG_OBJECT_RETIRED = A ID "{0}" faz referência a um objeto desativado.
MSG_OBJECT_LITERALS_DEPRECATED = Os literais da entidade foram preteridos, use um criador de consulta.
MSG_DEPRECATED_MEMBER = {0} em {1} foi preterido.
MSG_EXPECTING_ENTITY_TYPE = Esperando um nome de tipo de entidade na expressão "find".
MSG_EXPECTING_QUERY_PATH = Esperando uma expressão de caminho de consulta.
MSG_QUERY_PATH_MUST_BEGIN_WITH = A expressão do caminho da consulta deve começar com "{0}"
MSG_EXPECTING_CONDITIONAL_EXPRESSION = Esperando uma expressão condicional, como "a > b"
MSG_CONDITIONAL_EXPRESSION_EXPECTS_BOOLEAN = esperado booliano.
MSG_EXPECTING_IDENTIFIER_FIND = Esperando identificador para expressão "find"
MSG_EXPECTING_IN_FIND = Esperando a cláusula "in" para a expressão "find".
MSG_EXPECTING_WHERE_FIND = Esperando a cláusula "where" para a expressão "find".
MSG_EXPECTING_LEFTPAREN_FIND = Esperando '(' na expressão "find".
MSG_EXPECTING_RIGHTPAREN_FIND = Esperando ')' na expressão "find".
MSG_QUERYPATH_MUST_BEGIN_WITH = O caminho de consulta deve começar com expressão da consulta pai "{0}".
MSG_QUERY_IN_LHS_OP_NOT_ENTITY = {0} não é resolvido como um tipo de entidade. O operador "in" requer uma propriedade de tipo de entidade no lhs.
MSG_QUERY_IN_LHS_OP_NOT_ARRAY = {0} não tem um tipo de matriz apropriado. O operador "in" requer uma propriedade do tipo de entidade no lhs que tenha um tipo de matriz válido.
MSG_QUERY_EXPECTED_BOOLEAN_EXPRESSION = {0} não é uma expressão booliana.
MSG_EXPECTING_READONLY_ENTITY_TYPE = "find" está limitado aos tipos de entidade somente leitura. Defina o elemento do Registro "allow-entity-queries' para localizar entidades graváveis.
MSG_STR_IMMUTABLE = As sequências de caracteres são imutáveis, não podem ser modificadas.
MSG_UNTERMINATED_STRING_LITERAL = Literal de sequência de caracteres não terminado. Esperando ".
MSG_INVALID_CHAR_AT = Caractere de escape ilegal na posição {0}
MSG_FUNCTION_CLASH_PARAMS = "{0}" em "{1}" está em conflito com "{2}" em "{3}"; as duas funções têm a mesma eliminação, mas uma não substitui a outra
MSG_UNTERMINATED_COMMENT = Comentário incompleto. Esperando "*/".
MSG_UNEXPECTED_EOF = Fim de arquivo inesperado
MSG_FUNCTION_ALREADY_DEFINED = {0} já está definido em {1}
MSG_FUNCTION_CLASH = "{0}" em "{1}" conflita com "{2}" em "{3}"; os tipos de retorno não são compatíveis.
MSG_ATTEMPTING_TO_ASSIGN_WEAKER_ACCESS_PRIVILEGES = "{0}" em "{1}" conflita com "{2}" em "{3}". Tentando atribuir privilégios de acesso mais fracos.
MSG_CANNOT_OVERRIDE_FINAL = Não é possível substituir um membro final "{0}" de "{1}"
MSG_CANNOT_ASSIGN_VALUE_TO_FINAL_VAR = Não é possível atribuir um valor a var final "{0}"
MSG_VAR_MIGHT_NOT_HAVE_BEEN_INIT = Talvez var "{0}" ainda não tenha sido inicializada
MSG_VAR_MIGHT_ALREADY_HAVE_BEEN_INIT = Var "{0}" já deve ter sido inicializada
MSG_VAR_MIGHT_ALREADY_HAVE_BEEN_INIT_LOOP = Talvez var "{0}" já tenha sido inicializada em loop
MSG_FUNCTION_ALREADY_DEFINED_IN_EXTENDED_CLASS = {0}, já está definido. Extensões não podem substituir funções.
MSG_DUPLICATE_CLASS_FOUND = Classe duplicada encontrada em\: {0}.
MSG_DUPLICATE_TYPE_FOUND = Tipo duplicado encontrado em\: {0}.
MSG_DUPLICATE_ENHANCEMENT_FOUND = Aprimoramento duplicado encontrado em\: {0}.
MSG_EXPECTING_OPEN_BRACE_FOR_CLASS_DEF = Esperando '{{' para abrir a instrução "class".
MSG_EXPECTING_CLOSE_BRACE_FOR_CLASS_DEF = Esperando '}' para fechar a instrução "class".
MSG_EXPECTING_NAME_CLASS_DEF = Esperando um nome para a classe.
MSG_EXPECTING_ENHANCEMENT_DEF = Esperando um aprimoramento.
MSG_NAMESPACE_CLASS_CONFLICT = O caminho do diretório da classe não corresponde ao nome do pacote.
MSG_NO_SUCH_FUNCTION = Nenhuma função definida para {0}.
MSG_CANNOT_EXTEND_PRIMITIVE_TYPE = Não é possível estender um tipo primitivo {0}.
MSG_CANNOT_EXTEND_FINAL_TYPE = Não é possível expandir um tipo final {0}.
MSG_ENHANCEMENTS_CANNOT_ENHANCE_OTHER_ENHANCEMENTS = Não é possível aprimorar um aprimoramento {0}.
MSG_CYCLIC_INHERITANCE = Herança cíclica envolvendo {0}.
MSG_EXPECTING_OPEN_BRACE_FOR_CONSTRUCTOR_DEF = Esperando '{{' para abrir o corpo do construtor.
MSG_EXPECTING_OPEN_BRACE_FOR_FUNCTION_DEF = Esperando '{{' para abrir o corpo da função.
MSG_EXPECTING_CLOSE_BRACE_FOR_FUNCTION_DEF = Esperando '}' para fechar o corpo da função.
MSG_EXPECTING_CLOSE_BRACE_FOR_CONSTRUCTOR_DEF = Esperando '}' para fechar o corpo do construtor.
MSG_NO_DEFAULT_CTOR_IN = Nenhum construtor padrão em {0}.
MSG_WRONG_NAMESPACE = O nome do pacote "{0}" não corresponde ao diretório "{1}".
MSG_WRONG_CLASSNAME = O nome da classe {0} não corresponde ao arquivo {1}.
MSG_SAME_NAME_AS_CLASS = "{0}" já está definido como o nome de classe para este arquivo
MSG_EXPECTING_PROPERTY_GET_OR_SET_MODIFIER = Esperando o modificador 'get' ou 'set' para a propriedade.
MSG_EXPECTING_NAME_PROPERTY = Esperando um nome de propriedade para a variável.
MSG_PROPERTY_ALREADY_DEFINED = A propriedade "{0}" já está definida.
MSG_GETTER_FOR_PROPERTY_ALREADY_DEFINED = A função 'get' da propriedade já está definida como "{0}".
MSG_SETTER_FOR_PROPERTY_ALREADY_DEFINED = A função 'set' da propriedade já está definida como "{0}".
MSG_PROPERTY_NOT_WRITABLE = "{0}" não é gravável.
MSG_CLASS_PROPERTY_NOT_READABLE = Propriedade, "{0}", de classe, "{1}", não é legível.
MSG_CLASS_PROPERTY_NOT_WRITABLE = Propriedade, "{0}", de classe, "{1}", não é gravável.
MSG_NO_VIEWS_FOR_YOUS = Não há suporte a exibições. Considere a consulta em "{0}"
MSG_VARIABLE_ALREADY_DEFINED = {0} já está definido. Use outro nome.
MSG_FUNCTION_DECL_MISSING = Erro interno. Não foi possível encontrar o símbolo da função decl para {0}.
MSG_EXPECTING_DEFAULT_VALUE = Esperando atribuição de valor padrão. Os parâmetros obrigatórios devem anteceder os parâmetros opcionais.
MSG_DEFAULT_VALUE_NOT_ALLOWED = Valor padrão não permitido aqui
MSG_COMPILE_TIME_CONSTANT_REQUIRED = Aqui a expressão deve ser constante do tempo de compilação.
MSG_OVERLOADING_NOT_ALLOWED_WITH_OPTIONAL_PARAMS = Excesso de carga não é permitido com parâmetros opcionais
MSG_MISSING_REQUIRED_ARGUMENTS = Um ou mais argumentos obrigatórios ausentes
MSG_ARGUMENT_ALREADY_DEFINED = Argumento já definido
MSG_EXPECTING_NAME_PARAM = Esperando nome para o parâmetro
MSG_EXPECTING_NAMED_ARG = Esperando um argumento nomeado
MSG_PARAM_NOT_FOUND = Parâmetro não encontrado
MSG_VARIABLE_REQUEST_DOES_NOT_ALLOW_VALUE = , as variáveis de solicitação não podem ter um valor inicial.
MSG_VARIABLE_TYPE_OR_VALUE_REQUIRED = Esperando um "as" e/ou "\:" para instrução "var".
MSG_VARIABLE_MUST_HAVE_NON_NULL_TYPE = As variáveis devem ter um tipo não nulo. Adicione um tipo explícito para esta variável.
MSG_CONDITION_IS_ALWAYS_TRUE_FALSE = A condição é sempre {0}
MSG_VOID_NOT_ALLOWED = o tipo 'void' não é permitido aqui.
MSG_FUNCTIONS_NOT_ALLOWED_IN_THIS_CONTEXT = Declarações de função não permitidas neste contexto
MSG_CONSTRUCTORS_NOT_ALLOWD_IN_THIS_CONTEXT = Construtores não permitidos neste contexto
MSG_INNER_CLASSES_NOT_ALLOWED_IN_THIS_CONTEXT = Declarações de classe interna não permitidas neste contexto
MSG_NO_SOURCE_FOUND = Nenhuma origem encontrada para a classe.
MSG_CANNOT_RETURN_VALUE_FROM_VOID = Não é possível retornar um valor de uma função nula.
MSG_RETURN_NOT_ALLOWED_HERRE = Instrução return não permitida aqui.
MSG_MISSING_RETURN_VALUE = Valor de retorno ausente.
MSG_EXPECTING_DECL = Esperando a declaração para var, função ou propriedade.
MSG_FUNCTION_ARG_NAME_CONFLICTS_WITH_CLASS_VAR = O argumento "{0}" da função {1} conflita com um campo de classe.
MSG_EXPECTING_ARROW_AFTER_BLOCK_ARGS = Esperando '->' para seguir as declarações de argumento do bloco.
MSG_EXPECTING_CLOSE_BRACE_FOR_BLOCK = Esperando '}' para seguir a lista de declaração do bloco.
MSG_EXPECTING_ARROW_AFTER_MAP_KEY = Esperando '->' para seguir as declarações de argumento do bloco.
MSG_UNEXPECTED_ARROW = '->' inesperado no inicializador de lista
MSG_EXPECTING_CLOSE_BRACE_FOR_INITIALIZER = Esperando '}' para seguir a instrução do inicializador.
MSG_MODIFIER_ABSTRACT_NOT_ALLOWED_HERE = Modificador 'abstract' não permitido aqui.
MSG_ABSTRACT_METHOD_CANNOT_BE_ACCESSED_DIRECTLY = O método abstrato {0} não pode ser acessado diretamente
MSG_NOT_ALLOWED_IN_INTERFACE = Não permitido na interface.
MSG_UNIMPLEMENTED_METHOD = {0} função não implementada\: {1}
MSG_INHERITS_UNRELATED_DEFAULTS = {0} Herda padrões não relacionados para {1} de {2} e {3}
MSG_INHERITS_ABSTRACT_AND_DEFAULT = {0} Herda métodos padrão e abstratos para {1} de {2} e {3}
MSG_INTERFACE_CANNOT_EXTEND_CLASS = Uma interface não pode estender uma classe, apenas interfaces.
MSG_CLASS_CANNOT_EXTEND_INTERFACE = Uma classe não pode 'estender' uma interface.
MSG_CANNOT_EXTEND_ARRAY = "Uma classe não pode 'estender' uma matriz."
MSG_CLASS_MUST_HAVE_PACKAGE = Uma classe deve ter um pacote.
MSG_CLASS_CANNOT_IMPLEMENT_CLASS = Uma classe não pode "implementar" uma classe.
MSG_ENUM_CANNOT_EXTEND_CLASS = Um Enum não pode estender uma classe
MSG_ENUM_CANNOT_HAVE_ANNOTATIONS = Uma constante enum não pode ter anotações
MSG_ENUM_CONSTRUCTOR_MUST_BE_PRIVATE = O construtor Enum deve ser declarado como privado
MSG_ENUM_CONSTRUCTOR_NOT_ACCESSIBLE = O construtor Enum não é acessível aqui
MSG_ENUM_MAY_NOT_HAVE_TYPEPARAM = Enum não pode ter parâmetros de tipo
MSG_BAD_CAPTURE_TYPE = Os blocos não dão suporte a referência lexical para este tipo de símbolo. Atribua a uma variável local fora do bloco para fazer referência a ele.
MSG_POTENTIALLY_BAD_CAPTURE = Este identificador captura uma variável externa que não suporta totalmente a captura "fora do escopo". Um erro de runtime pode ocorrer caso o identificador avalie fora do escopo da função circundante mais externa.
MSG_CANNOT_CAPTURE_SYMBOL_IN_BLOCK_IN_ANON_CLASS = Não é possível capturar símbolos em um bloco aninhado dentro de uma classe anônima.
MSG_CANNOT_CAPTURE_SYMBOL_IN_ANON_CLASS_IN_BLOCK = Não é possível capturar símbolos em uma classe anônima aninhada em um bloco.
MSG_EXPECTING_ENHANCE_KEYWORD = Esperado "enhance"
MSG_NON_PRIVATE_MEMBERS_MUST_DECLARE_TYPE = Os membros de dados não privados devem declarar um tipo explicitamente.
MSG_DELEGATES_CANNOT_BE_STATIC = Os representantes não podem ser estáticos.
MSG_DELEGATE_METHOD_CONFLICT = Conflito de membro delegado\: {0} e {1}. Implemente o membro explicitamente para resolver o conflito.
MSG_DELEGATES_SHOULD_NOT_SELF_DELEGATE = Representantes não devem autodelegar.
USING_INTERNAL_CLASS = É uma classe interna que será alterada no futuro. O uso dessa classe é <b>perigoso e incompatível</b>.
MSG_EXTENSION_CLASS_NOT_FOUND = Não foi possível encontrar a classe {0} para estendê-la.
MSG_CANNOT_DEREF_PROPERTIES_IN_WHERE = Não é possível desfazer referência a propriedade na cláusula 'where'. Considere usar a cláusula 'exists'.
MSG_CANNOT_CALL_METHOD_WITH_WILDCARD_PARAM = Não é possível chamar a função que tem parâmetros curinga.
MSG_NO_WILDCARDS = Os curingas são obsoletos no Gosu. Substitua o parâmetro de tipo por "{0}"
MSG_EXPECTING_COLON_ENHANCEMENT = Esperando '\:' no aprimoramento.
MSG_EXPECTING_CLOSE_BRACKET_FOR_LIST_LITERAL = Esperando ']' no fim de um literal de lista.
MSG_CANNOT_PARAMETERIZE_NONGENERIC = Não é possível parametrizar um tipo não genérico.
MSG_TYPE_PARAM_NOT_ASSIGNABLE_TO = O parâmetro de tipo {0} não pode ser atribuído ao tipo de vínculo {1}.
MSG_TYPE_NOT_ANNOTATION = O tipo {0} não é uma anotação. Deve ser uma anotação Java ou uma interface de implementação gw.lang.IAnnotation
MSG_MISPLACED_META_ANNOTATION = Esta anotação pode ser usada apenas na classe annotation.
MSG_MISPLACED_ANNOTATION = Esta anotação não pode ser usada em uma classe annotation.
MSG_ANNOTATION_WHEN_NONE_ALLOWED = A anotação "{0}" não pode aparecer em uma declaração {1}.
MSG_ANNOTATION_USE_SITE_TARGET_NOT_ALLOWED_HERE = A anotação "{0}" tem o destino use-site inválido "{1}" para contexto.
MSG_TOO_MANY_ANNOTATIONS = A anotação "{0}" pode aparecer apenas uma vez em uma declaração {1}.
MSG_EXPECTING_COLON_ANNOTATION = Era esperado '\:' para separar o destino use-site e o tipo de anotação.
MSG_INVALID_TYPE = "{0}" não é um tipo válido.
MSG_INVALID_GENERIC_EXCEPTION = A classe genérica não pode estender 'java.lang.Throwable'
MSG_INVALID_INNER_TYPE = Nenhuma classe interna "{0}" encontrada em "{1}".
MSG_INVALID_TYPE_WITH_QUALIFIED_NAME = "{0}" tem um tipo inválido\: "{1}".
MSG_NOT_A_STATEMENT = Não é uma instrução.
MSG_CANNOT_CONSTRUCT_ABSTRACT_CLASS = "{0}" é abstrato; não pode ser construído.
MSG_CANNOT_CONSTRUCT_RECURSIVE_CLASS = "{0}" é recursivo; não pode ser construído diretamente.
MSG_RECURSIVE_CONSTRUCTOR = Invocação recursiva do construtor.
MSG_MISSING_RETURN = Instrução return ausente.
MSG_UNREACHABLE_STMT = Instrução inalcançável.
MSG_BREAK_OUTSIDE_SWITCH_OR_LOOP = Instrução break não permitida aqui.
MSG_CONTINUE_OUTSIDE_LOOP = Instrução continue não permitida aqui.
MSG_PROPERTY_SET_MUST_HAVE_ONE_PARAMETER = Os configuradores de propriedade devem ter exatamente um parâmetro.
MSG_PROPERTY_SET_MUST_RETURN_VOID = O setter da propriedade deve retornar void.
MSG_MISSING_PROPERTY_RETURN = Tipo de retorno de propriedade ausente.
MSG_IMPLICIT_COERCION_WARNING = Uma coerção implícita do tipo {0} para {1} ocorre aqui. Considere deixar explícito com um "as {1}".
MSG_IMPLICIT_COERCION_ERROR = Deve-se forçar explicitamente {0} para {1} usando a palavra-chave 'as'.
MSG_ASYMMETRICAL_COMPARISON = Comparação assimétrica entre {0} e {1}. Considere converter um dos operandos.
MSG_SILLY_ASSIGNMENT = Uma atribuição inútil de {0} a ele mesmo ocorre aqui. Talvez isso não seja intencional, mas devido a um erro de programação.
MSG_UNUSED_VARIABLE = Este {0} não é usado.
MSG_LIKELY_JAVA_CAST = Parece ser uma tentativa de fazer uma conversão estilo Java, que não é correto no Gosu. Para converter uma expressão em outro tipo, insira "as {0}" depois da expressão
MSG_UNEXPECTED_TOKEN = Token inesperado\: {0}
MSG_EXPECTING_INT_ACCESS_TO_ARR_ETC = Esperando acesso int para o tipo Array, Collection ou String com o operador [] de matriz.
MSG_EXPECTING_BEAN_TYPE_WITH_REFLECTION_OPERATOR = Esperando o tipo de bean com o operador de reflexão [].
MSG_PROPERTY_REFLECTION_ONLY_WITH_STRINGS = A reflexão da propriedade de bean pode ser feita apenas com sequências de caracteres.
MSG_EXPECTING_BRACKET_TO_CLOSE_DYNAMIC_MEMBER_ACCESS = Esperando o operador ']' para fechar a expressão de acesso do membro dinâmico.
MSG_WRONG_NUMBER_OF_ARGS_TO_FUNCTION = Número incorreto de argumentos para função {0}. Esperava-se '{1}', mas foi obtido '{2}'.
MSG_WRONG_NUMBER_OF_ARGS_TO_CONSTRUCTOR = Número incorreto de argumentos para construtor {0}. Esperava-se '{1}', mas foi obtido '{2}'.
MSG_SHOULD_HAVE_FOUND_METHOD_AT_LINE = Deveria ter encontrado uma função na linha {0}, coluna {1}
MSG_VOID_EXPRESSION_NOT_ALLOWED = As expressões nesta posição não devem ser nulas.
MSG_EXPECTING_RETURN_TYPE_OR_FUN_BODY = Esperando tipo de retorno ou corpo da função.
MSG_INVALID_TYPE_FOR_ANNOTATION_MEMBER = Tipo inválido para membro de anotação
MSG_ERRANT_TYPE_VAR = Tipo de var errado
MSG_USING_VOID_RETURN_TYPE_FROM_NON_NULL_EXPR = Usando o tipo de retorno void da expressão não nula.
MSG_FIELD_TYPE_HAS_NOT_BEEN_INFERRED = O tipo deste campo ainda não foi deduzido e, por isso, não pode ser usado. Esta expressão deve aparecer depois da declaração do campo.
MSG_BEAN_CLASS_IS_NULL = A classe do bean é nula.
MSG_BEAN_MEMBER_PATH_IS_NULL = O caminho do membro do bean é nulo.
MSG_BEAN_MEMBER_PATH_IS_EMPTY = O caminho do membro do bean está vazio.
MSG_NO_EXPLICIT_TYPE_INFO_FOUND = Nenhuma informação de tipo explícito encontrada para {0}
MSG_NO_CONSTRUCTOR_FOUND_FOR_CLASS = Nenhum construtor encontrado para a classe {0}
MSG_WRONG_NUMBER_OF_ARGS_FOR_METHOD_ON_CLASS = Número incorreto de argumentos para a função, {0}, na classe, {1}
MSG_NO_METHOD_DESCRIPTOR_FOUND_FOR_METHOD = Nenhum descritor de função encontrado para a função {0}, na classe {1}
MSG_METHOD_IS_NOT_STATIC = A função "{0}" não é estática na classe {1}
MSG_METHOD_IS_STATIC = A função "{0}" é estática na classe {1}
MSG_NO_PROPERTY_DESCRIPTOR_FOUND = Nenhum descritor da propriedade {0} encontrado para propriedade, {1}, na classe, {2}
MSG_NO_TYPE_ON_NAMESPACE = Nenhum tipo {0} encontrado no pacote {1}
MSG_ANY = {0}
MSG_EXPECTING_MEMBER_ACCESS_PATH = Esperando o caminho de acesso do membro.
MSG_CANNOT_CREATE_NEW_ARRAY_FROM_TYPE_VAR = Não é possível criar uma nova matriz de instância a partir de uma variável de tipo. O tipo pode apenas ser acessado e gravado.
MSG_NOT_A_VALID_EXCEPTION_TYPE = {0} não estende Throwable e não pode ser encontrado.
MSG_CANNOT_INFER_ARGUMENT_TYPE_AT_THIS_POSTION = O argumento {0} deve fornecer uma declaração de tipo, pois não pode ser inferido.
MSG_OBSOLETE_CTOR_SYNTAX = Esta sintaxe de construtor é obsoleta. Use a palavra-chave 'construct'.
MSG_OBSOLETE_NOT_EQUAL_OP = O operador <> é obsoleto e deve ser substituído por \!\=
MSG_MUST_BE_IN_OUTER_TO_CONSTRUCT_INNER = Deve estar na classe {0} ou derivar dela para construir a classe interna não estática {1}.
MSG_TYPE_DOES_NOT_HAVE_EMPTY_CONSTRUCTOR = O tipo {0} não tem um construtor padrão e não pode ser criado implicitamente aqui.
MSG_ENHANCEMENT_DOES_NOT_ACCEPT_THIS_STATEMENT = Os aprimoramentos não podem ter instruções deste tipo.
MSG_CANNOT_OVERRIDE_FUNCTIONS_IN_ENHANCEMENTS = A função "{0}" já está definida no tipo {1}. Os aprimoramentos não podem substituir funções.
MSG_CANNOT_OVERRIDE_PROPERTIES_IN_ENHANCEMENTS = A propriedade "{0}" já está definida no tipo {1}. Os aprimoramentos não podem substituir propriedades.
MSG_ENHANCED_TYPE_MUST_USE_ENHANCEMENT_TYPEVARS = O tipo aprimorado deve usar todas as variáveis de tipo declaradas pelo aprimoramento.
MSG_ABSTRACT_MEMBER_NOT_IN_ABSTRACT_CLASS = Membro abstrato não está na classe abstrata.
MSG_ILLEGAL_USE_OF_MODIFIER = Uso ilegal do modificador, "{0}" não pode ser usado com "{1}" aqui
MSG_ILLEGAL_FORWARD_REFERENCE = Referência de encaminhamento ilegal
MSG_MISSING_OVERRIDE_MODIFIER = Modificador 'override' ausente. A função {0} substitui e/ou implementa a função de {1}.
MSG_RENAME_METHOD = Renomeie a função. A função {0} conflita com a função de {1}, os tipos de retorno são incompatíveis. As funções particulares são compiladas com acesso 'interno', por isso, conflitam em tempo de execução quando estão no mesmo pacote.
MSG_STATIC_METHOD_CANNOT_OVERRIDE = A função estática {0} não pode substituir/implementar a função em {1}.
MSG_OVERRIDES_OBJECT_METHOD = O método padrão {0} substitui o método Object
MSG_INHEREITED_WITH_DIFF_ARG_TYPES = "{0}" não pode ser herdada com argumentos de tipos diferentes\: {1}
MSG_NO_IMPLEMENTS_ALLOWED = Nenhuma cláusula de implementação permitida para interface.
MSG_NO_EXTENDS_ALLOWED = Nenhuma cláusula de extensão permitida para anotação.
MSG_FUNCTION_NOT_OVERRIDE = A função {0} não substitui nada
MSG_FUNCTION_NOT_OVERRIDE_PROPERTY = A função {0} não substitui nada. Talvez você queira substituir uma propriedade {1}?
MSG_PROPERTY_OVERRIDES_WITH_INCOMPATIBLE_TYPE = Substituições de propriedade com tipo incompatível
MSG_SUBCLASS_OBJECT = {0} explicitamente coloca Object como subclasse
MSG_AMBIGUOUS_SYMBOL_REFERENCE = Esta é uma referência ambígua. Qualifique completamente o símbolo.
MSG_LIST_TO_ARRAYLIST_WARNING = Coerção implícita para ArrayList. Use ArrayList explicitamente.
MSG_VAR_CASE_MISMATCH = A var "{0}" não é referenciada pelo caso apropriado. Altere essa referência para "{1}".
MSG_FUNCTION_CASE_MISMATCH = A função "{0}" não é referenciada pelo caso apropriado. Altere essa referência para "{1}".
MSG_PROPERTY_CASE_MISMATCH = A propriedade "{0}" não é referenciada pelo caso apropriado. Altere essa referência para "{1}".
MSG_TYPE_CASE_MISMATCH = O tipo "{0}" não é referenciado pelo caso apropriado. Altere essa referência para "{1}".
MSG_NON_STATIC_ACCESS_OF_STATIC_MEMBER = A propriedade "{0}" é estática, mas não é referenciada estaticamente no tipo {1}.
MSG_NON_STATIC_ACCESS_WITH_IDENTIFIER_OF_STATIC_MEMBER = A propriedade "{0}" é estática, mas não foi referenciada diretamente fora do tipo {1}. \nHá uma variável em conflito ou uma propriedade nomeada "{2}". Qualifique totalmente a expressão como {3}.{0}.
MSG_STATEMENT_ON_SAME_LINE = Várias instruções ocupam a mesma linha; podem indicar um erro de lógica não intencional.\nMova a instrução para uma nova linha.
MSG_MUST_BE_DEFINED_AS_CLASS = Deve ser definido como "class".
MSG_VOID_RETURN_IN_CTX_EXPECTING_VALUE = Esta função espera o bloco para retornar um valor.
MSG_NO_STATIC_CONSTRUCTOR = Construtores não podem ser estáticos
MSG_NO_ABSTRACT_METHOD_CALL_IN_CONSTR = A função {0} é abstrata e não pode ser chamada no construtor.
MSG_CALLING_OVERRIDABLE_FROM_CTOR = Chamando a função substituível do construtor\: {0}
MSG_AMBIGUOUS_METHOD_INVOCATION = Esta é uma chamada de função ambígua.
MSG_RETURN_VAL_FROM_VOID_FUNCTION = Você está tentando retornar um valor de uma função nula.
MSG_BAD_ANONYMOUS_CLASS_DECLARATION = Somente os tipos Java e Gosu podem ter extensão anônima.
MSG_SINGLE_ANON_CTOR = Uma classe anônima pode definir no máximo um construtor
MSG_ANON_CTOR_PARAMS_CONFLICT_WITH_CALL_SITE = Os tipos de parâmetro do construtor anônimo estão em conflito com os tipos de argumentos no local da chamada
MSG_ASSIGNMENT_IN_IF_STATEMENT = As atribuições não são legais na parte interna de condições if
MSG_ASSIGNMENT_IN_LOOP_STATEMENT = As atribuições não são válidas dentro de condições de loop
MSG_JAVA_STYLE_VARIABLE_DECLARATION = É uma declaração de variável no estilo Java. Em vez disso, use a palavra-chave "var".
MSG_NUMERIC_TYPE_EXPECTED = Expressão numérica esperada.
MSG_GETTER_CANNOT_HAVE_PARAMETERS = A definição de uma propriedade get não pode ter parâmetros.
MSG_BAD_TEMPLATE_DIRECTIVE = Diretiva de modelo inválida. As diretivas válidas são "extends" e "params".
MSG_CLASSPATH_STATEMENT_EXPECTS_A_STRING = A instrução classpath requer uma sequência de caracteres para o caminho
MSG_COMMA_IS_THE_CLASSPATH_SEPARATOR = A instrução classpath usa vírgulas como separador de caminho independente da plataforma
MSG_BITSHIFT_LHS_MUST_BE_INT_OR_LONG = O operando do lado esquerdo deve ser int ou long.
MSG_BITWISE_OPERAND_MUST_BE_INT_OR_LONG = O operando lógico bit-wise deve ser int ou long.
MSG_EXPECTING_LEFTPAREN_USING = Esperando '(' para abrir o predicado "using".
MSG_EXPECTING_RIGHTPAREN_USING = Esperando ')' para fechar o predicado "using".
MSG_BAD_TYPE_FOR_USING_STMT = O predicado de instrução de uso deve ser Closeable, IDisposable ou Lock. Converta em IMonitorLock para sincronização no estilo Java.
MSG_UNNECESSARY_COERCION = Esta expressão já é do tipo {0}, por isso, é desnecessário convertê-la em {1}.
MSG_LATER_ASSIGNMENT_MAKES_EXPRESSION_ILLEGAL = Uma atribuição posterior para {0} cancela a inferência do tipo que possibilita este uso.
WSDL_DUPLICATE_WEB_SERVICE = Nome de serviço Web duplicado. Somente um webservice com o nome dado pode ser definido.
MSG_NUMBER_LITERAL_TOO_LARGE = Literal de número muito grande.
WSDL_DUPLICATE_METHOD = Funções de serviço Web duplicadas. As funções sobrecarregadas devem ter um número diferente de parâmetros, mesmo que os tipos sejam diferentes.\n{0} conflita com {1}.
WSDL_NOT_WEBSERVICE = Esta anotação está disponível apenas no serviço Web
WSDL_UNSUPPORTED_TYPE = O serviço Web não pode referenciar o seguinte tipo sem suporte\: {0} {1}
WSDL_REFERENCE_ABSTRACT_CLASS = O serviço Web não pode fazer referência a uma classe abstrata\: {0} {1}
WSDL_REFERENCE_INTERFACE = O serviço Web não pode fazer referência a uma interface\: {0} {1}
WSDL_REFERENCE_ANNOTATION = O serviço Web não pode fazer referência a uma anotação\: {0} {1}
WSDL_REFERENCE_TRANSACTION_TYPE = O serviço Web não pode fazer referência a um tipo no namespace gw.transaction.*\: {0} {1}
WSDL_REFERENCE_LIST = O serviço Web não pode fazer referência a tipos de lista\: {0}. Tente uma matriz fortemente tipada (por exemplo, String[]). {1}
WSDL_REFERENCE_MAP = O serviço Web não pode fazer referência a tipos de mapa\: {0} {1}
WSDL_REFERENCE_COLLECTION = O serviço Web não pode fazer referência a tipos Collection\: {0}. Tente uma matriz fortemente tipada (por exemplo, String[]). {1}
WSDL_REFERENCE_PARAMETERIZED_TYPE = O serviço Web não pode referenciar tipos parametrizados\: {0}
WSDL_REFERENCE_GENERIC_TYPE = O serviço Web não pode fazer referência a tipos genéricos\: {0} {1}
WSDL_REFERENCE_UNSUPPORTED_NAMESPACE = O serviço Web não pode fazer referência ao seguinte tipo. Ele é parte de um namespace sem suporte, somente tipos do namespace 'gw.*' (exceto gw.transaction.*) são permitidos\: {0} {1}
WSDL_REFERENCE_CLASS_WITHOUT_DEFAULT_CONSTRUCTOR = A classe {0} não tem nenhum construtor padrão e não pode ser mencionada por um serviço Web. {1}   //Talvez devesse ser um aviso.
WSDL_REFERENCE_WEBSERVICE = O serviço Web não pode referenciar outros tipos de serviços Web\: {0} {1}
WSDL_REFERENCE_SOAP_TYPE = Os serviços Web não podem fazer referência a tipos no namespace soap.*\: {0} {1}
WSDL_REFERENCE_XML_TYPE = Os serviços Web RPC não podem fazer referência a tipos baseados em xml\: {0} {1}
WSDL_READONLY_PROPERTIES = Os serviços Web não devem fazer referência a tipos que têm propriedades somente leitura.\nEsses tipos não podem ser definidos como parâmetro para uma operação de serviço Web. {0} {1}
WSDL_WRITEONLY_PROPERTIES = Os serviços Web não devem fazer referência a tipos que têm propriedades somente gravação.\nEsses tipos não podem ser definidos como um tipo de retorno para uma operação de serviço Web. {0} {1}
WSDL_REFERENCE_CAUSES_NAMESPACE_COLLISION = Este tipo causa uma colisão de namespace de serviços Web. Esses dois tipos têm o mesmo nome relativo e seriam expostos aos serviços Web no mesmo soap de namespace.*.{0}.\nRenomeie um dos seguintes tipos ou garanta que não é mencionado em um serviço Web\: {1} e {2}. {3}
MSG_DELEGATION_NOT_ALLOWED_HERE = A delegação não é permitida aqui
MSG_DELEGATE_MUST_NOT_BE_STATIC = Não há suporte para delegação estática
MSG_DELEGATES_REPRESENT_INTERFACES_ONLY = Um representante pode apenas representar tipos de interface
MSG_ONLY_INTERFACES_ALLOWED_HERE = Somente interfaces são permitidas aqui
MSG_ONLY_ONE_CLASS_IN_COMPONENT_TYPE = Somente uma não interface é permitida em um tipo de componente
MSG_ONLY_ONE_TYPE_VARIABLE = Uma variável de tipo não pode ser seguida por outros vínculos
MSG_NO_ARRAY_IN_COMPONENT_TYPE = Não são permitidas matrizes em um tipo de componente
MSG_NO_PRIMITIVE_IN_COMPONENT_TYPE = Não são permitidos primitivos em um tipo de componente
MSG_COMPOUND_TYPE_NOT_ALLOWED_HERE = O tipo composto não é permitido aqui
MSG_PARAMETERIZED_TYPE_NOT_ALLOWED_HERE = Tipo parametrizado não permitido aqui
MSG_DYNAMIC_TYPE_NOT_ALLOWED_HERE = Tipo dinâmico não permitido aqui
MSG_CANNOT_EXTEND_INTERNAL_JAVATYPE = O tipo Java {0} tem acesso protegido por pacote e não pode ser estendido ou aprimorado no Gosu
MSG_CLASS_DOES_NOT_IMPL = Interface de delegação não implementada pelo tipo declarado\: {0}
MSG_EXPECTING_REPRESENTS = Esperando a cláusula 'represent' para representante
MSG_EXPECTING_LEFTPAREN_AGGREGATE = Esperando '(' para abrir o tipo agregado
MSG_EXPECTING_RIGHTPAREN_AGGREGATE = Esperando ')' para fechar o tipo agregado
MSG_MEMBER_ACCESS_REQUIRED_FOR_SUPER = Acesso de membro necessário para 'super'
MSG_ALREADY_CONTAINS_TYPE = Tipo {0} já especificado
MSG_OVERRIDING_FUNCTION_MUST_HAVE_SAME_NUMBER_OF_TYPE_VARS = Para esta função substituir adequadamente sua função pai, ela deve ter variáveis do tipo {0}
MSG_AGGREGATES_MUST_CONTAIN_MORE = Um tipo agregado deve ter mais de um tipo
MSG_INTERFACE_REDUNDANT = Interface {0} redundante, {1} estende {0}
MSG_NONTERMINAL_CASE_CLAUSE = A cláusula do caso anterior não é terminal; possível instrução break, continue ou return ausente
MSG_ANONYMOUS_CLASS_NOT_ALLOWED_HERE = Classe anônima não permitida aqui
MSG_PARAMETERIZED_ARRAY_COMPONENT = O tipo de componente de matriz parametrizada perde os parâmetros de tipo no runtime.
MSG_TEMPLATE_EXCEPTION_GENERATED_SOURCE = Origem gerada
MSG_TEMPLATE_MISSING_END_TAG_SCRIPTLET = A marcação final '%>' para scriptlet está ausente.
MSG_TEMPLATE_MISSING_END_TAG_EXPRESSION = A marcação final de '%>' para a expressão está ausente.
MSG_TEMPLATE_MISSING_END_TAG_EXPRESSION_ALT = Marcação final '}' ausente na expressão.
MSG_TEMPLATE_MULTIPLE_PARAMS = Várias diretivas de "params" encontradas.
MSG_TEMPLATE_INVALID_PARAMS = Parâmetros inválidos\: {0}
MSG_TEMPLATE_UNKNOWN_DIRECTIVE = Diretiva desconhecida {0}. As diretivas válidas são "params" e "extends".
MSG_EQUALS_FOR_INITIALIZER_EXPR = Esperando '\=' no inicializador deste objeto.
MSG_INITIALIZER_NOT_ALLOWED_ABSTRACT_PROPERTY = Não é permitido inicializador em propriedade abstrata.
MSG_EXPECTING_NAME_VALUE_PAIR = Esperando um nome de propriedade seguido por '\=' e o valor da expressão.
MSG_REDUNTANT_INITIALIZERS = A propriedade {0} já tem um valor de inicializador.
MSG_ONLY_ONE_COLON_IN_INITIALIZERS = Somente um dois-pontos pode vir antes do nome de uma propriedade nos inicializadores.
MSG_EXPECTING_PROPERTY_NAME = Esperando um nome de propriedade.
MSG_BLOCK_TYPES_SHOULD_HAVE_ARG_NAMES = Os parâmetros de tipo de bloco devem especificar nomes e estar na forma 'argName\:Type'.
MSG_DIMENSION_MULTIPLICATION_UNDEFINED = Multiplicação não definida entre dimensões
MSG_DIMENSION_ADDITION_MUST_BE_SAME_TYPE = Os dois operandos devem ser dimensões do mesmo tipo final
MSG_DIMENSION_DIVIDE_SCALAR_BY_DIMENSION = Não é possível dividir escalar pela dimensão
MSG_DIMENSION_MUST_BE_FINAL = A aritmética de dimensão deve envolver tipos finais. {0} não é final.
MSG_DIMENSION_NONSTANDARD_NUMBER_NO_OVERRIDE = Métodos aritméticos ausentes na dimensão, {0}, com tipo de número não padrão, {1}
MSG_RELATIONAL_OPERATOR_CANNOT_BE_APPLIED_TO_TYPE = O operador relacional {0} não pode ser aplicado ao tipo {1}
MSG_ARITHMETIC_OPERATOR_CANNOT_BE_APPLIED_TO_TYPES = O operador "{0}" não pode ser aplicado a "{1}", "{2}"
MSG_ASSIGNMENTS_MUST_BE_ENCLOSED_IN_CURLIES_IN_BLOCKS = As atribuições no corpo de um bloco devem estar entre colchetes
MSG_BLOCKS_CAN_HAVE_A_MOST_SIXTEEN_ARGS = Os blocos podem ter, no máximo, 16 argumentos.
MSG_BLOCKS_LITERAL_NOT_ALLOWED_IN_NEW_EXPR = Literais de blocos não permitidos em uma expressão nova.
MSG_STATEMENTS_MUST_BE_ENCLOSED_IN_CURLIES_IN_BLOCKS = As instruções "{0}" no corpo de um bloco devem estar entre colchetes
MSG_NOT_AN_ENHANCEABLE_TYPE = {0} não dá suporte a aprimoramentos.
MSG_CANNOT_REFERENCE_CLASS_TYPE_VAR_IN_STATIC_CONTEXT = Não é possível fazer referência às variáveis do tipo de classe em um contexto estático.
MSG_CANNOT_REFERENCE_THIS_IN_STATIC_CONTEXT = Não é possível fazer referência a 'this' em um contexto estático.
MSG_CANNOT_CALL_NON_STATIC_METHOD_FROM_STATIC_CONTEXT = Não é possível referenciar métodos não estáticos em um contexto estático.
MSG_CANNOT_REFERENCE_NON_STATIC_PROPERTY_FROM_STATIC_CONTEXT = Não é possível referenciar propriedades não estáticas em um contexto estático.
MSG_CANNOT_REFERENCE_NON_STATIC_FEATURE_HERE = Você não pode fazer referência a um recurso não estático aqui
MSG_ONLY_GOSU_JAVA_TYPES = Somente tipos Gosu e Java são permitidos aqui
MSG_CANNOT_READ_A_WRITE_ONLY_PROPERTY = As propriedades somente gravação podem apenas ser gravadas
MSG_TYPE_IS_NOT_ITERABLE = Esperando o tipo Iterable para operador de expansão - {0}
MSG_INTERVAL_MUST_BE_ITERABLE_HERE = O tipo de intervalo deve ser iterável aqui
MSG_EXTRA_DOT_FOUND_IN_INTERVAL = O operador de intervalo tem dois pontos, foram encontrados três
MSG_EXPECTING_NUMBER_TO_FOLLOW_DECIMAL = Esperando um número decimal
MSG_IMPROPER_VALUE_FOR_NUMERIC_TYPE = O valor {0} não se enquadra no domínio dos números de tipo {1}
MSG_PRIMITIVE_TYPE_PARAM = O tipo primitivo {0} não é permitido aqui. O tipo {0} é transformado implicitamente em {1} como um parâmetro de tipo. Use {1} diretamente.
MSG_CTOR_HAS_XXX_ACCESS = O construtor tem {0} acesso
MSG_TYPE_HAS_XXX_ACCESS = O tipo {0} tem {1} acesso
MSG_QUERY_SPECIFY_COLUMN = Especifique uma coluna de consulta
MSG_QUERY_SPECIFY_QUERY_COLUMN = {0} deve especificar uma coluna no banco de dados que possa ser consultada
MSG_CANNOT_EXTEND_RAW_GENERIC_TYPE = O tipo genérico {0} requer argumento[s] de tipo
MSG_TYPE_VAR_VARIANCE_ERROR = A variável de tipo {0} está declarada como "{1}", mas é usada em uma posição "{2}" com o tipo {3}
MSG_SUPER_CLASS_METHOD_NAME_SAME_AS_SUBCLASS = O método de superclasse {0} conflita com o nome do construtor interno da classe. Altere o nome do método de superclasse ou o nome da classe.
MSG_NOT_A_SUPERTYPE = {0] não é um supertipo direto
MSG_CALL_TO_SUPER_THIS_MUST_BE_FIRST = A chamada de {0}() deve ser a primeira instrução no construtor
MSG_EXPECTING_OPERATOR_TO_FOLLOW_NEW_EXPRESSION = Instrução incompleta. Esperava-se que o operador seguisse a nova expressão.
MSG_EXPECTING_TYPE_TO_FOLLOW_PACKAGE_NAME = Esperando tipo após o nome do pacote
MSG_QUERY_FUNCTION_EXPRESSION_RESTRICTION = Somente referências a colunas do banco de dados ou chamadas do método DBFunction são permitidas.
MSG_QUERY_ORDER_BY_EXPRESSION = São permitidas apenas expressões de acesso do membro que contenham colunas de banco de dados.
MSG_QUERY_ARRAYS_NOT_ALLOWED = Não é permitido o acesso a uma matriz aqui.
MSG_APPLICATION_MODIFIER_HAS_BEEN_DEPRECATED = O modificador "application" foi preterido. Use o mapa gw.api.web.Scopes.Application.
MSG_SESSION_MODIFIER_HAS_BEEN_DEPRECATED = O modificador "session" foi preterido. Use gw.api.web.SessionVar.
MSG_REQUEST_MODIFIER_HAS_BEEN_DEPRECATED = O modificador "request" foi preterido. Use gw.api.web.RequestVar.
MSG_EXECUTION_MODIFIER_HAS_BEEN_DEPRECATED = O modificador "execution" foi preterido e não tem significado. Você pode simplesmente removê-lo.
MSG_CANNOT_REFERENCE_OUTER_SYMBOL_WITHIN_ENHANCEMENTS = A palavra-chave externa não pode ser referenciada nestes aprimoramentos. Mova esta classe anônima para uma classe nomeada.
MSG_CANNOT_REFERENCE_ENCLOSING_PROPERTIES_WITHIN_ENHANCEMENTS = Métodos do tipo circundante não podem ser referenciados em aprimoramentos. Considere mover esta classe anônima para uma classe nomeada.
MSG_CANNOT_REFERENCE_ENCLOSING_METHODS_WITHIN_ENHANCEMENTS = Métodos do tipo circundante não podem ser referenciados em aprimoramentos. Considere mover esta classe anônima para uma classe nomeada.
MSG_INVALID_LITERAL = Este literal não pode ser convertido em um {0}. Você precisa construir o valor explicitamente.
MSG_PROPERTIES_MUST_AGREE_ON_STATIC_MODIFIERS = O getter e o setter das propriedades devem ser estáticos ou não estáticos
MSG_PROPERTIES_MUST_AGREE_ON_TYPE = O getter e o setter das propriedades devem estar de acordo com o tipo da propriedade
MSG_NO_ENCLOSING_INSTANCE_IN_SCOPE = Nenhuma instância circundante de tipo '{0}' no escopo
MSG_EXPECTING_CONDITION_FOR_ASSERT = Esperando condição para 'assert'.
MSG_EXPECTING_MESSAGE_FOR_ASSERT = Esperando mensagem para 'assert'.
MSG_ASSERTIONS_NOT_ALLOWED_HERE = Instrução assert não permitida aqui.
MSG_ARRAY_NOT_SUPPORTED = Tipo de matriz sem suporte para {0}
MSG_IMPROPER_USE_OF_KEYWORD = Uso impróprio da palavra-chave {0}
MSG_USES_STMT_CONFLICT = Já está usando o tipo, {0}
MSG_USES_STMT_DUPLICATE = A duplicata usa instrução
MSG_ARRAY_INDEX_MUST_BE_INT = As matrizes devem ser indexadas com um valor int
MSG_PARAM_TYPE_CANT_BE_INFERRED_FROM_LATE_BOUND_EXPRESSION = O tipo de parâmetro não pode ser inferido da última expressão de vínculo
MSG_LOSS_OF_PRECISION_IN_NUMERIC_LITERAL = Este literal duplo perde precisão nesta operação. Em vez disso, você deve declará-lo explicitamente como BigDecimal\: {0}
MSG_COMPILE_TIME_ANNOTATION_FAILED_TO_EXECUTE = Uma anotação de tempo de compilação não foi executada. A mensagem foi {0}. Consulte o console para obter um rastreamento de pilha.
MSG_METHOD_REIFIES_TO_SAME_SIGNATURE_AS_ANOTHER_METHOD = Um método com o mesmo nome reifica a mesma assinatura no nível de bytecode. Renomeie um dos métodos.
MSG_TYPE_NOT_REIFIED = {0} deve ser declarado com o modificador "reified" para acessar a variável de tipo "{1}" em tempo de execução.
MSG_REIFIED_DONT_MATCH = Deve substituir a função com a mesma configuração "reified"
MSG_REIFIED_DONT_MATCH_JAVA = O método genérico reificado {0} substitui um método Java em {1}. A invocação de {0} a partir de {1} apaga parâmetros de tipo.
NOTHING_TO_REIFY = Nada para reificar
MSG_PROPERTY_AND_FUNCTION_CONFLICT = O método {0} conflita com os métodos implícitos gerados pela propriedade {1}
MSG_PROPERTY_AND_FUNCTION_CONFLICT_UPON_REIFICATION = O método {0} conflita com os métodos implícitos gerados pela propriedade {1} após reificação
MSG_CANNOT_OVERRIDE_FUNCTION_FROM_ENHANCEMENT = Você não pode substituir um método definido em um aprimoramento.
MSG_MASKING_ENHANCEMENT_METHODS_MAY_BE_CONFUSING = Este método mascara um método definido em um aprimoramento neste tipo. Isso pode causar confusão semântica, já que os métodos de aprimoramento são despachados estaticamente.
MSG_STRING_COERCION_ON_RHS_OF_ADDITIVE_EXPRESSION_MUST_BE_PARENTHESIZED = A seleção de uma sequência de caracteres em uma expressão de adição pode ser confuso. Coloque a expressão entre parênteses para avaliá-la corretamente.
MSG_EXPLICIT_TYPE_RECOMMENDED_FOR_CATCH_STMTS = Você deve adicionar um tipo preso explicitamente aqui.
MSG_SUPER_NOT_ACCESSIBLE_FROM_BLOCK = O supersímbolo não é acessível de dentro dos blocos.
MSG_GENERIC_PROPERTIES_NOT_SUPPORTED = As propriedades não podem ter variáveis de tipo.
MSG_GENERIC_ANNOTATIONS_NOT_SUPPORTED = As anotações não podem ter variáveis de tipo.
MSG_CATCH_STMT_CANNOT_EXECUTE = Esta instrução catch jamais será executada, pois uma instrução catch anterior já capturou as exceções deste tipo.
MSG_IMONITOR_LOCK_SHOULD_ONLY_BE_USED_WITHIN_USING_STMTS = A interface IMonitorLock pode apenas ser usada no estilo da expressão usando instruções para sincronização de estilo herdado.
MSG_STATIC_MODIFIER_NOT_ALLOWED_HERE = O modificador 'static' não é permitido aqui.
MSG_MODIFIERS_NOT_ALLOWED_HERE = Não são permitidos modificadores aqui.
MSG_CANNOT_INSTANTIATE_NON_STATIC_CLASSES_HERE = Não é possível instanciar uma classe não estática aqui.
MSG_WARN_ON_SUSPICIOUS_THIS_COMPARISON = Parece ser uma má comparação. No Gosu, o operador '\=\=' equivale a .equals(). Em vez disso, se quiser fazer equivalência de instância, use o operador '\=\=\='.
MSG_FL_EXPECTING_FEATURE_NAME = Esperado um nome de recurso aqui e também um nome de método, de propriedade ou 'construct'
MSG_FL_EXPECTING_RIGHT_CARET = Esperado um '>'
MSG_FL_GENERIC_FUNCTION_REFERENCES_NOT_YET_SUPPORTED = Ainda não há suporte a literais da função genérica.
MSG_FL_EXPECTING_RIGHT_PAREN = Esperado ')' para fechar a lista de tipos de argumento.
MSG_FL_CONSTRUCTOR_NOT_FOUND = Um construtor com os tipos {0} não foi encontrado
MSG_FL_METHOD_NOT_FOUND = Um método com o nome {0} e os tipos {1} não foi encontrado.
MSG_FL_PROPERTY_NOT_FOUND = Uma propriedade com o nome {0} não foi encontrada
MSG_FL_STATIC_FEATURES_MUST_BE_REFERENCED_FROM_THEIR_TYPES = Um recurso estático ou um construtor deve ser referenciado diretamente no tipo ao qual o recurso pertence.
MSG_NO_TYPE_AFTER_CONSTRUCTOR = Construtores não podem especificar um tipo de retorno.
WS_ERR_Can_Not_Marshal = {0} Não é possível realizar marshalling do tipo local {2} para {1}.
WS_ERR_Annotation_Duplicate_Namespace = Em {0}\: namespace "{1}" duplicado já usado em "{2}". {3} tenta introduzi-lo novamente para {4}.
WS_ERR_Annotation_Exception = As propriedades de tipo {0} serão ignoradas. Consulte o log para obter o rastreamento de pilha
WS_ERR_Annotation_Invalid_Namespace = {0}\: namespace inválido "{1}"
WS_ERR_Annotation_Only_For_WebService = {0}\: a anotação @{1} pode ser usada apenas em classes anotadas com @WsiWebService
WS_ERR_Annotation_Operation_Duplicate = Em {0}\: método {1}, já existe um método com esse nome
WS_ERR_Annotation_Operation_OneWay_Invalid = Métodos unidirecionais devem ter o tipo de retorno void
WS_ERR_Annotation_Operation_Response_Reserved = Em {0}\: método {1}, o sufixo 'Response' é reservado para elementos de resposta
WS_ERR_Export_Inner_Only_On_WebService = Em {0}\: tipo {1} as classes internas não são exportáveis
WS_ERR_Export_Inner_Not_Name_Of_Method = As classes internas têm o mesmo nome que a solicitação do método {0}
WS_ERR_Export_Inner_Not_Name_Of_Response = As classes internas têm o mesmo nome que a resposta do método {0}
WS_ERR_Export_No_Constructor = Em {0}\: tipo {1} uma classe exportável precisa de um construtor padrão público
WS_ERR_Export_No_Extends = Em {0}\: tipo {1} uma classe exportável não pode estender outra classe
WS_ERR_Export_Not_Final = Em {0}\: tipo {1} não é final. Uma classe exportável deve ser final
WS_ERR_Export_Not_WebService = Em {0}\: o tipo {1} é um serviço Web. Um serviço Web não pode ser exportado
WS_ERR_Export_Recursive = Não há suporte a recursão. Verifique se {0} não é recursivo
WS_WARN_Annontation_Some_Generators_Dont_Support_Schema = {0} Aviso\: processando parâmetro {1}; algumas estruturas de serviços Web podem não compreender {2}
WS_WARN_Annontation_Not_Available = {0} não está disponível até {1}
WS_WARN_Ignored = {0}\: vai ignorar a propriedade {1} de tipo {2}
PCF_ERR_Verify = Erro de PCF ao tentar verificar {0}.
MSG_FL_ONLY_PROPERTIES_MAY_BE_CHAINED = Somente literais de propriedade podem ser encadeados.
Gen_Wsi_InvalidType = {0} não pode realizar marshalling de {1}\: {2}
Gen_Wsi_UnsupportedType = {0} é um tipo válido, mas não tem suporte em serviços Web.
Gen_Wsi_UnsupportedComponentType = {0} não tem suporte, pois seu componente/tipo de parâmetro não tem suporte.
Gen_Wsi_NoComponentType = {0} não tem suporte, pois nenhum componente/tipo de parâmetro foi especificado.
Gen_Wsi_NoBase = A classe XmlBase {0} não tem suporte direto.
Gen_Wsi_AnonElement = 0} Elementos anônimos não têm suporte. Elementos anônimos são filhos de outro elemento. Você pode tentar usar o tipo do elemento filho.
Gen_Wsi_AnonType = Os tipos anônimos {0} (tipos declarados em uma declaração de elemento) não têm suporte. Você pode tentar usar o elemento.
Gen_Wsi_NoSimple = Os tipos XSD simples {0} não têm suporte. Você pode tentar criar um tipo complexo ou usar o tipo estendido.
Gen_Wsi_XmlError = Erro inesperado ao processar {0}\: {1}
Gen_Wsi_NullType = Tipo nulo passado
Gen_Wsi_TypeNotGosu = {0} não é do Gosu, por isso não tem suporte nesta implementação wsi.
Gen_Wsi_TypeNotWSAnnotated = {0} não tem uma anotação @WsiWebService.
Gen_Wsi_TypeNotEXPAnnotated = {0} não tem uma anotação @WsiExportable.
GEN_CAN_NOT_MARSHAL_GOSU_REMOTEABLE_ENUMS = {0} não pode realizar marshalling de GWEnumerations escritas em Gosu
GEN_CAN_NOT_MARSHAL_REMOTEABLE_ENUMS_EXTENDED = {0} não pode realizar marshalling de GWEnumerations que tenham propriedades adicionais
GEN_CAN_NOT_MARSHAL_XML_IN_EXPORTABLE = {0} não pode realizar marshalling de xml em tipos WsiExportable
GEN_CLASS_CANNOT_BE_BOTH_WS_AND_EXPORT = A classe {0} não pode ser @WsiWebService e {1}
GEN_CHECKING = Verificando {0}
GEN_CHANGED = {0} alterado
WS_ERR_Invalid_Supertype = {0} não estende {1}
WS_ERR_Export_Empty = {0} não tem propriedades exportáveis
WS_ERR_Previous_Invalid = {0} é inválido. Foram relatados erros anteriormente
WS_ERR_Entity_Invalid = {0} é inválida. Não há suporte para realizar marshalling de entidades. Crie uma classe WsiExportable com os campos necessários.
WS_ERR_Collection_Invalid = {0} é inválido. Somente matrizes e listas <T> têm suporte.
WF_WARN_Subtype = O subtipo de fluxo de trabalho "{0}" está definido como não externo, mas ou não há um script definido ou o script não foi analisado. Verifique nos logs possíveis falhas de análise.
WF_ERR_Duplicate = Mais de um processo de fluxo de trabalho definido com typecode "{0}" e versão "{1}" idênticos.
WF_ERR_Parse = Não foi possível analisar "{0}" -- {1}\: {2}
WF_ERR_Convert = Não foi possível converter "{0}" -- {1}\: {2}
WF_ERR = Em "{0}"\: {1}

ARRAY = Matriz
BEAN = Bean
BOOLEAN = Booleano
DATETIME = DateTime
FUNCTION = Función
IDENTIFIER = Identificador
METATYPENAME = Tipo
NULLTYPENAME = Nulo
NUMERIC = Número
STRING = Cadena
MSG_SYNTAX_ERROR = Error de sintaxis.
MSG_BAD_IDENTIFIER_NAME = No se pudo resolver el símbolo para \: {0}
MSG_END_OF_STMT = Se espera el final de la instrucción. Posiblemente falta el operador o es erróneo.
MSG_END_OF_EXPRESSION = Se espera el final de la expresión. Posiblemente falta el operador o es erróneo.
MSG_EXPECTING_OPERATOR_TO_FOLLOW_EXPRESSION = Instrucción incompleta. Se espera que el operador siga a la expresión.
MSG_EXPECTING_ARGS = Se esperan argumento[s] para la función, {0}
MSG_EXPECTING_EXPRESSION_CLOSE = Se espera ')' para cerrar la expresión entre paréntesis.
MSG_EXPECTING_FUNCTION_CLOSE = Se espera ')' para cerrar la llamada a la función.
MSG_EXPECTING_TYPE_NAME = Se espera un nombre de tipo.
MSG_PARAMETERIZATION_NOT_SUPPORTED_FOR_TYPE = {0} no admite parametrización.
MSG_NO_ARGUMENTS = La función {0} no acepta ningún argumento.
MSG_NULL_SYMBOL_TABLE = La tabla de símbolos es nula o está vacía.
MSG_TYPE_MISMATCH = El tipo "{1}" no puede convertirse a "{0}"
MSG_VALUE_MISMATCH = No coincide el valor. El valor literal, "{0}", no puede convertirse a {1}.
MSG_WRONG_NUM_OF_ARGS = Número incorrecto de argumentos para la función, {0}
MSG_EXPECTING_NAME_FUNCTION_DEF = Se espera un nombre para la función.
MSG_EXPECTING_LEFTPAREN_FUNCTION_DEF = Se espera '(' para abrir la declaración del argumento de función.
MSG_EXPECTING_RIGHTPAREN_FUNCTION_DEF = Se espera ')' para cerrar la declaración del argumento de función.
MSG_EXPECTING_TYPE_FUNCTION_DEF = Se espera "\:" cláusula para la declaración de función.
MSG_EXPECTING_TYPE_LITERAL_FUNCTION_DEF = Se espera un tipo después de "\:" para la declaración de función.
MSG_EXPECTING_IDENTIFIER_FOREACH = Se espera un identificador para la instrucción "for...in".
MSG_EXPECTING_IDENTIFIER_FOREACH_INDEX = Se espera un identificador para el "índice" de la instrucción "para..en".
MSG_EXPECTING_IDENTIFIER_FOREACH_ITERATOR = Esperaba un identificador en el "iterador" de la instrucción "para...en"\n.
MSG_FOREACH_ITERATOR_NOT_ALLOWED = No se permite "iterator" en una instrucción "for...in" sin una variable de bucle.
MSG_ITERATOR_SYMBOL_ONLY_SUPPORTED_ON_ITERABLE_OBJECTS = Un símbolo "iterador" es compatible solamente con objetos iterables.
MSG_EXPECTING_IDENTIFIER_EXISTS = Se espera un identificador para la expresión "existe"
MSG_EXPECTING_IDENTIFIER_EXISTS_INDEX = Se espera un identificador para el "índice" de la expresión "existe".
MSG_EXPECTING_IN_FOREACH = Se espera la cláusula "in" para la instrucción "for...in".
MSG_EXPECTING_LEFTPAREN_FE = Se espera '(' en la instrucción "for...in".
MSG_EXPECTING_RIGHTPAREN_FE = Se espera ')' en la instrucción "for...in".
MSG_EXPECTING_LEFTPAREN_BLOCK = Se espera '(' en la declaración de tipo de bloque.
MSG_EXPECTING_RIGHTPAREN_BLOCK = Se espera ')' en la declaración de tipo de bloque.
MSG_EXPECTING_COLON_BLOCK = Se espera '\:' en la declaración de tipo de bloque.
MSG_EXPECTING_IN_EXISTS = Se espera la cláusula "in" para la expresión "existe".
MSG_EXPECTING_WHERE_EXISTS = Se espera la cláusula "dónde" para la expresión "existe".
MSG_EXPECTING_LEFTPAREN_EXISTS = Se espera '(' en la expresión "existe".
MSG_EXPECTING_RIGHTPAREN_EXISTS = Se espera ')' en la expresión "existe".
MSG_EXPECTING_LEFTPAREN_EVAL = Se espera '(' para abrir la expresión "eval".
MSG_EXPECTING_RIGHTPAREN_EVAL = Se espera ')' para cerrar la expresión "eval".
MSG_EXPECTING_LEFTPAREN_CATCH = Se espera '(' en la cláusula "atrapar" de la instrucción "intentar...atrapar...finalmente".
MSG_EXPECTING_RIGHTPAREN_CATCH = Se espera ')' en la cláusula "catch" de la instrucción "intentar...atrapar...finalmente".
MSG_EXPECTING_IDENTIFIER_CATCH = Se espera el identificador para la cláusula "catch" de la instrucción "intentar..atrapar...finalmente".
MSG_CATCH_OR_FINALLY_REQUIRED = Se espera una cláusula "atrapar" o "finalmente" en la instrucción "intentar...atrapar...finalmente".
MSG_EXPECTING_LEFTBRACE_STMTBLOCK = Se espera '{' para abrir el bloque de la instrucción.
MSG_EXPECTING_RIGHTBRACE_STMTBLOCK = Se espera '}' para cerrar el bloque de la instrucción.
MSG_EXPECTING_LEFTPAREN_IF = Se espera '(' para abrir la condición "si".
MSG_EXPECTING_RIGHTPAREN_IF = Se espera ')' para cerrar la condición "si".
MSG_EXPECTING_LEFTPAREN_SWITCH = Se espera '(' para abrir la expresión "switch".
MSG_EXPECTING_RIGHTPAREN_SWITCH = Se espera ')' para cerrar expresión "switch".
MSG_EXPECTING_LEFTPAREN_WHILE = Se espera '(' para abrir la condición "mientras".
MSG_EXPECTING_RIGHTPAREN_WHILE = Se espera ')' para cerrar la condición "mientras".
MSG_EXPECTING_LEFTPAREN_EXCEPT = Se espera '(' para abrir la condición "exceptuar".
MSG_EXPECTING_RIGHTPAREN_EXCEPT = Se espera ')' para cerrar la condición "exceptuar".
MSG_EXPECTING_WHILE_DO = Se espera la cláusula "mientras" para cerrar la instrucción "hacer...mientras".
MSG_LOOP_DOESNT_LOOP = El bucle no se repite
MSG_EXPECTING_EQUALS_ASSIGN = Se espera '\=' para la instrucción de asignación.
MSG_EXPECTING_EXPRESSSION_ON_RHS = Se espera una expresión rhs válida para la instrucción de asignación.
MSG_EXPECTING_STATEMENT = Se espera una instrucción.
MSG_EXPECTING_BEANTYPE = Se espera un tipo complejo para acceso de miembro. Encontrado\: {0}
MSG_EXPECTING_ARRAYTYPE_FOREACH = Se espera el tipo de iteración después de la cláusula 'in' en la instrucción "for...in". Encontrado\: {0}
MSG_EXPECTING_ARRAYTYPE_EXISTS = Se espera el tipo matriz después de la cláusula 'in' en la expresión "existe". Encontrado\:
MSG_EXPECTING_IDENTIFIER_ARG_TYPE = Se espera el nombre de tipo después de "\:" para el argumento de la función.
MSG_EXPECTING_ARRAY_BRACKET = Se espera ']' para cerrar el literal de tipo de la matriz.
MSG_EXPECTING_NEW_ARRAY_OR_CTOR = Se espera "[" o ")" para iniciar una nueva operación de objeto o matriz.
MSG_EXPECTING_OPEN_BRACE_FOR_NEW_ARRAY = Se espera '{{' para iniciar una lista de expresiones de valor de matriz.
MSG_EXPECTING_CLOSE_BRACE_FOR_NEW_ARRAY = Se espera '}' para cerrar la lista de expresiones de valor de matriz.
MSG_EXPECTING_CLOSING_ANGLE_BRACKET_FOR_TYPE = Se espera '>' para cerrar el literal de tipo parametrizado.
MSG_EXPECTING_CLOSING_ANGLE_BRACKET_FOR_TYPE_VAR_LIST = Se espera '>' para cerrar lista de variables de tipo.
MSG_COULD_NOT_PARAMETERIZE = No se pudo parametrizar.
MSG_EXPECTING_OPEN_BRACE_FOR_SWITCH = Se espera '{{' para cerrar la instrucción "switch".
MSG_EXPECTING_CLOSE_BRACE_FOR_SWITCH = Se espera '}' para cerrar la instrucción "switch".
MSG_EXPECTING_COLON_TERNARY = Se espera '\:' para la expresión ternaria condicional.
MSG_EXPECTING_REFERENCE_TYPE = Esperaba un tipo de referencia, el tipo primitivo no se permite aquí.
MSG_LOSS_OF_PRECISION_IN_CONDITIONAL_EXP = Los tipos no se pueden convertir sin pérdida de precisión. Conviértalos de forma explícita.
MSG_EXPECTING_CASE_COLON = Se espera '\:' para cerrar la expresión "case".
MSG_DUPLICATE_CASE_EXPRESSION = Expresión de caso duplicado.
MSG_TYPE_MISMATCH_IN_CONDIITIONAL_EXP = Tipo no coincidente en expresión ternaria condicional.
MSG_EXPECTING_IDENTIFIER_VAR = Se espera un nombre de variable.
MSG_EXPECTING_VAR_STMT = Se espera la declaración "var".
MSG_EXPECTING_TYPELITERAL = Se espera un literal de tipo en el lado derecho de la expresión.
MSG_EXPECTING_TYPELITERAL_OR_NAMESPACE = Se espera un literal de tipo o espacio de nombre.
MSG_PRIMITIVES_NOT_ALLOWED_HERE = No se permiten tipos primitivos aquí.
MSG_INCONVERTIBLE_TYPES = Tipos inconvertibles; no se puede emitir {0} a {1}
MSG_BAD_NAMESPACE = '{0}' no es un espacio de nombre válido.
MSG_EXPECTING_ARRAYLENGTH = Se espera la propiedad de matriz 'largo'.
MSG_ENTITYBEANS_ARE_IMMUTABLE = No se puede modificar directamente la propiedad del objeto.
MSG_MULTIPLE_DEFAULT_CLAUSES_NOT_PERMITTED = Se detectaron varias cláusulas 'default' en la instrucción "switch".
MSG_CASE_CLAUSE_MAY_NOT_FOLLOW_DEFAULT_CLAUSE = Una cláusula "case" no puede seguir a la cláusula 'default'.
MSG_METHOD_NOT_VISIBLE = La función, "{0}", no es visible bajo las limitaciones de visibilidad del analizador.
MSG_PROPERTY_NOT_VISIBLE = La propiedad, "{0}", no es visible bajo las limitaciones de visibilidad del analizador.
MSG_OBJECT_RETIRED = El ID, "{0}", hace referencia a un objeto retirado.
MSG_OBJECT_LITERALS_DEPRECATED = Los literales de entidad ya no se utilizan; en su lugar, utilice un generador de consultas.
MSG_DEPRECATED_MEMBER = {0} en {1} ha sido depreciado.
MSG_EXPECTING_ENTITY_TYPE = Se espera un nombre de tipo de entidad en la expresión "buscar".
MSG_EXPECTING_QUERY_PATH = Se espera una expresión de ruta de consulta.
MSG_QUERY_PATH_MUST_BEGIN_WITH = La expresión de ruta de consulta debe comenzar con "{0}"
MSG_EXPECTING_CONDITIONAL_EXPRESSION = Se espera una expresión condicional como "a > b"
MSG_CONDITIONAL_EXPRESSION_EXPECTS_BOOLEAN = se esperaba un booleano.
MSG_EXPECTING_IDENTIFIER_FIND = Se espera un identificador para la expresión "buscar"
MSG_EXPECTING_IN_FIND = Se espera la cláusula "en" para la expresión "buscar".
MSG_EXPECTING_WHERE_FIND = Se espera la cláusula "donde" para la expresión "encontrar".
MSG_EXPECTING_LEFTPAREN_FIND = Se espera '(' en la expresión "buscar".
MSG_EXPECTING_RIGHTPAREN_FIND = Se espera ')' en la expresión "buscar".
MSG_QUERYPATH_MUST_BEGIN_WITH = La ruta de la consulta debe comenzar con su expresión de consulta primaria "{0}".
MSG_QUERY_IN_LHS_OP_NOT_ENTITY = {0} no se resuelve en un tipo de entidad. El operador "in" requiere una propiedad de tipo de entidad en el lhs.
MSG_QUERY_IN_LHS_OP_NOT_ARRAY = {0} no tiene un tipo de matriz adecuado. El operador "in" requiere una propiedad de tipo de entidad en el lhs que tenga un tipo de matriz válido.
MSG_QUERY_EXPECTED_BOOLEAN_EXPRESSION = {0} no es una expresión booleana.
MSG_EXPECTING_READONLY_ENTITY_TYPE = "buscar" se limita a tipos de entidad de sólo lectura. Establezca el elemento de registro "allow-entity-queries" para buscar entidades modificables.
MSG_STR_IMMUTABLE = Las cadenas son inalterables, no se pueden modificar.
MSG_UNTERMINATED_STRING_LITERAL = Literal de cadena sin determinar. Se espera ".
MSG_INVALID_CHAR_AT = Carácter de escape ilegal en la posición {0}
MSG_FUNCTION_CLASH_PARAMS = "{0}" en "{1}" entra en colisión con "{2}" en "{3}"; ambas funciones tienen el mismo borrado, pero ninguna anula a la otra
MSG_UNTERMINATED_COMMENT = Comentario sin determinar. Se espera "*/".
MSG_UNEXPECTED_EOF = Fin de archivo inesperado
MSG_FUNCTION_ALREADY_DEFINED = {0}, ya ha sido definido en {1}
MSG_FUNCTION_CLASH = "{0}" en "{1}" entra en colisión con "{2}" en "{3}"; tipos de devolución no compatibles.
MSG_ATTEMPTING_TO_ASSIGN_WEAKER_ACCESS_PRIVILEGES = "{0}" en "{1}" entra en colisión con "{2}" en "{3}"; se intenta asignar privilegios de acceso más débiles.
MSG_CANNOT_OVERRIDE_FINAL = No se puede anular el miembro final "{0}" de "{1}"
MSG_CANNOT_ASSIGN_VALUE_TO_FINAL_VAR = No se puede asignar un valor a la variable final "{0}"
MSG_VAR_MIGHT_NOT_HAVE_BEEN_INIT = Es posible que no se haya inicializado la variable "{0}"
MSG_VAR_MIGHT_ALREADY_HAVE_BEEN_INIT = Es posible que ya se haya inicializado la variable "{0}"
MSG_VAR_MIGHT_ALREADY_HAVE_BEEN_INIT_LOOP = Es posible que ya se haya inicializado la variable "{0}" en el bucle
MSG_FUNCTION_ALREADY_DEFINED_IN_EXTENDED_CLASS = {0}, ya ha sido definido. Las extensiones no pueden anular funciones.
MSG_DUPLICATE_CLASS_FOUND = Se encontró una clase duplicada en\: {0}.
MSG_DUPLICATE_TYPE_FOUND = Se encontró un tipo duplicado en\: {0}.
MSG_DUPLICATE_ENHANCEMENT_FOUND = Se encontró una mejora duplicada en\: {0}.
MSG_EXPECTING_OPEN_BRACE_FOR_CLASS_DEF = Se espera '{{' para abrir la instrucción "clase".
MSG_EXPECTING_CLOSE_BRACE_FOR_CLASS_DEF = Se espera '}' para cerrar la instrucción "clase".
MSG_EXPECTING_NAME_CLASS_DEF = Se espera un nombre para la clase.
MSG_EXPECTING_ENHANCEMENT_DEF = Se espera una mejora.
MSG_NAMESPACE_CLASS_CONFLICT = La ruta del directorio de la clase no se corresponde con el nombre de paquete.
MSG_NO_SUCH_FUNCTION = No se ha definido la función para {0}.
MSG_CANNOT_EXTEND_PRIMITIVE_TYPE = No se puede ampliar un tipo primitivo {0}.
MSG_CANNOT_EXTEND_FINAL_TYPE = No se puede ampliar un tipo final {0}.
MSG_ENHANCEMENTS_CANNOT_ENHANCE_OTHER_ENHANCEMENTS = No se puede mejorar una mejora {0}.
MSG_CYCLIC_INHERITANCE = Existe implicación de herencia cíclica {0}.
MSG_EXPECTING_OPEN_BRACE_FOR_CONSTRUCTOR_DEF = Se espera '{{' para abrir el cuerpo del constructor.
MSG_EXPECTING_OPEN_BRACE_FOR_FUNCTION_DEF = Se espera '{{' para abrir el cuerpo de la función.
MSG_EXPECTING_CLOSE_BRACE_FOR_FUNCTION_DEF = Se espera '}' para cerrar el cuerpo de la función.
MSG_EXPECTING_CLOSE_BRACE_FOR_CONSTRUCTOR_DEF = Se espera '}' para cerrar el cuerpo del constructor.
MSG_NO_DEFAULT_CTOR_IN = Sin constructor predeterminado en {0}.
MSG_WRONG_NAMESPACE = El nombre de paquete "{0}" no se corresponde con el directorio "{1}".
MSG_WRONG_CLASSNAME = El nombre de clase {0} no se corresponde con el archivo {1}.
MSG_SAME_NAME_AS_CLASS = "{0}" ya se ha definido como nombre de clase para este archivo
MSG_EXPECTING_PROPERTY_GET_OR_SET_MODIFIER = Se espera el modificador 'obtener' o 'config' para la propiedad.
MSG_EXPECTING_NAME_PROPERTY = Se espera un nombre de propiedad para la variable.
MSG_PROPERTY_ALREADY_DEFINED = La propiedad "{0}" ya ha sido definida.
MSG_GETTER_FOR_PROPERTY_ALREADY_DEFINED = La propiedad de la función 'conseguir' ya ha sido definida para "{0}".
MSG_SETTER_FOR_PROPERTY_ALREADY_DEFINED = La propiedad de la función 'set' ya ha sido definida para "{0}".
MSG_PROPERTY_NOT_WRITABLE = "{0}" no es modificable.
MSG_CLASS_PROPERTY_NOT_READABLE = No se puede leer la propiedad, "{0}", de la clase, "{1}".
MSG_CLASS_PROPERTY_NOT_WRITABLE = La propiedad, "{0}", de la clase, "{1}", no es modificable.
MSG_NO_VIEWS_FOR_YOUS = No se admiten vistas. Considere consultar contra "{0}"
MSG_VARIABLE_ALREADY_DEFINED = {0}, ya ha sido definido. Utilice un nombre diferente.
MSG_FUNCTION_DECL_MISSING = Error interno. No se pudo encontrar el símbolo de la función decl para, {0}.
MSG_EXPECTING_DEFAULT_VALUE = Esperaba una asignación de valor predeterminado. Los parámetros necesarios deben preceder los parámetros optativos.
MSG_DEFAULT_VALUE_NOT_ALLOWED = Aquí no se permite el valor predeterminado
MSG_COMPILE_TIME_CONSTANT_REQUIRED = La expresión debe ser constante con el tiempo de compilación aquí.
MSG_OVERLOADING_NOT_ALLOWED_WITH_OPTIONAL_PARAMS = No se permite sobrecargar con parámetros optativos
MSG_MISSING_REQUIRED_ARGUMENTS = Faltan uno o más de los argumentos necesarios
MSG_ARGUMENT_ALREADY_DEFINED = Ya se definió el argumento
MSG_EXPECTING_NAME_PARAM = Esperaba nombre para el parámetro
MSG_EXPECTING_NAMED_ARG = Se espera un argumento con nombre
MSG_PARAM_NOT_FOUND = No se encontró el parámetro
MSG_VARIABLE_REQUEST_DOES_NOT_ALLOW_VALUE = , las variables de solicitud no pueden tener un valor inicial.
MSG_VARIABLE_TYPE_OR_VALUE_REQUIRED = Se espera un "as" y/o "\:" para la instrucción "var".
MSG_VARIABLE_MUST_HAVE_NON_NULL_TYPE = Las variables deben tener un tipo no nulo.  Agregar un tipo explícito para esta variable.
MSG_CONDITION_IS_ALWAYS_TRUE_FALSE = La condición es siempre {0}
MSG_VOID_NOT_ALLOWED = No se permite aquí el tipo'vacío'
MSG_FUNCTIONS_NOT_ALLOWED_IN_THIS_CONTEXT = No se permiten las declaraciones de función en este contexto
MSG_CONSTRUCTORS_NOT_ALLOWD_IN_THIS_CONTEXT = No se permiten constructores en este contexto
MSG_INNER_CLASSES_NOT_ALLOWED_IN_THIS_CONTEXT = No se permiten declaraciones de clase interna en este contexto
MSG_NO_SOURCE_FOUND = No se ha encontrado origen para la clase.
MSG_CANNOT_RETURN_VALUE_FROM_VOID = No se puede devolver un valor de una función nula.
MSG_RETURN_NOT_ALLOWED_HERRE = No se permite aquí una instrucción de devolución.
MSG_MISSING_RETURN_VALUE = Falta el valor devuelto.
MSG_EXPECTING_DECL = Se espera declaración para la variable, función o propiedad.
MSG_FUNCTION_ARG_NAME_CONFLICTS_WITH_CLASS_VAR = El argumento "{0}" de la función {1} entra en conflicto con un campo de clase.
MSG_EXPECTING_ARROW_AFTER_BLOCK_ARGS = Se espera '->' para seguir las declaraciones de argumento de bloque.
MSG_EXPECTING_CLOSE_BRACE_FOR_BLOCK = Se espera '}' para seguir la lista de instrucciones de bloque.
MSG_EXPECTING_ARROW_AFTER_MAP_KEY = Se espera '->' para seguir las declaraciones de argumento de bloque.
MSG_UNEXPECTED_ARROW = No se esperaba '->' en el iniciador de lista
MSG_EXPECTING_CLOSE_BRACE_FOR_INITIALIZER = Se espera '}' para seguir la instrucción de inicialización.
MSG_MODIFIER_ABSTRACT_NOT_ALLOWED_HERE = No se permite el modificador 'abstraer' aquí.
MSG_ABSTRACT_METHOD_CANNOT_BE_ACCESSED_DIRECTLY = No se puede acceder directamente al método abstracto '{0}'
MSG_NOT_ALLOWED_IN_INTERFACE = No se permite en la interfaz.
MSG_UNIMPLEMENTED_METHOD = Función {0} no implementada\: {1}
MSG_INHERITS_UNRELATED_DEFAULTS = {0} hereda los valores predeterminados no relacionados para {1} de {2} y {3}
MSG_INHERITS_ABSTRACT_AND_DEFAULT = {0} hereda los métodos abstractos y predeterminados para {1} de {2} y {3}
MSG_INTERFACE_CANNOT_EXTEND_CLASS = Una interfaz no puede ampliar una clase, sólo interfaces.
MSG_CLASS_CANNOT_EXTEND_INTERFACE = Una clase no puede usar una instrucción 'extender' para ampliar una interfaz.
MSG_CANNOT_EXTEND_ARRAY = "Una clase no puede usar una instrucción 'extend' para ampliar una matriz."
MSG_CLASS_MUST_HAVE_PACKAGE = Una clase debe tener un paquete.
MSG_CLASS_CANNOT_IMPLEMENT_CLASS = Una clase no puede usar una instrucción 'implementar' para implementar una clase.
MSG_ENUM_CANNOT_EXTEND_CLASS = Un constructor enum no puede ampliar una clase
MSG_ENUM_CANNOT_HAVE_ANNOTATIONS = Una constante de enumeración no puede tener anotaciones
MSG_ENUM_CONSTRUCTOR_MUST_BE_PRIVATE = El constructor enum debe declararse privado
MSG_ENUM_CONSTRUCTOR_NOT_ACCESSIBLE = No se puede acceder al constructor de enumeración aquí
MSG_ENUM_MAY_NOT_HAVE_TYPEPARAM = Es posible que la enumeración no tenga parámetros de tipo
MSG_BAD_CAPTURE_TYPE = Los bloques no admiten referencia léxica a este tipo de símbolo.  Asigne a una variable local fuera del bloque para referirse a ella.
MSG_POTENTIALLY_BAD_CAPTURE = Este identificador captura una variable externa que no es totalmente compatible con capturas "fuera de ámbito".  Puede resultar un error de tiempo de ejecución si el identificador evalúa fuera del ámbito más externo envolvente de la función.
MSG_CANNOT_CAPTURE_SYMBOL_IN_BLOCK_IN_ANON_CLASS = No puede capturar símbolos en un bloque anidado dentro de una clase anónima.
MSG_CANNOT_CAPTURE_SYMBOL_IN_ANON_CLASS_IN_BLOCK = No puede capturar símbolos en una clase anónima anidada dentro de un bloque.
MSG_EXPECTING_ENHANCE_KEYWORD = Se espera "mejorar"
MSG_NON_PRIVATE_MEMBERS_MUST_DECLARE_TYPE = Los miembros de datos no privados deben declarar un tipo explícitamente.
MSG_DELEGATES_CANNOT_BE_STATIC = Delegados no pueden ser estáticos.
MSG_DELEGATE_METHOD_CONFLICT = Conflicto de miembro delegado\: {0} y {1}. Implemente el miembro de forma explícita para resolver el conflicto.
MSG_DELEGATES_SHOULD_NOT_SELF_DELEGATE = Los delegados no deben autodelegar.
USING_INTERNAL_CLASS = Esta es una clase interna que cambiará en el futuro.  El uso de esta clase es <b>peligroso y no se admite</b>.
MSG_EXTENSION_CLASS_NOT_FOUND = No se pudo encontrar la clase {0} a ampliar.
MSG_CANNOT_DEREF_PROPERTIES_IN_WHERE = No se puede quitar la referencia a la propiedad en la cláusula dónde. Considere el uso de la cláusula 'existe'.
MSG_CANNOT_CALL_METHOD_WITH_WILDCARD_PARAM = No se puede llamar a una función que tenga parámetros comodín.
MSG_NO_WILDCARDS = Los comodines están en desuso en Gosu. Reemplace el parámetro de tipo con "{0}"
MSG_EXPECTING_COLON_ENHANCEMENT = Se espera '\:' en la mejora.
MSG_EXPECTING_CLOSE_BRACKET_FOR_LIST_LITERAL = Se espera ']' al final del literal de una lista.
MSG_CANNOT_PARAMETERIZE_NONGENERIC = No se puede parametrizar un tipo no genérico.
MSG_TYPE_PARAM_NOT_ASSIGNABLE_TO = El parámetro de tipo {0} no es asignable al tipo de límite {1}.
MSG_TYPE_NOT_ANNOTATION = El tipo {0} no es una anotación.  Debe implementar la interfaz gw.lang.IAnnotation
MSG_MISPLACED_META_ANNOTATION = Esta anotación sólo se puede usar en una clase de anotación.
MSG_MISPLACED_ANNOTATION = Esta anotación no se puede usar en una clase de anotación.
MSG_ANNOTATION_WHEN_NONE_ALLOWED = No se permite que la anotación "{0}" aparezca en una declaración {1}.
MSG_ANNOTATION_USE_SITE_TARGET_NOT_ALLOWED_HERE = La anotación {0} tiene un objetivo de uso en sitio no válido "{1}" para el contexto.
MSG_TOO_MANY_ANNOTATIONS = La anotación "{0}" sólo puede aparecer una vez en una declaración {1}.
MSG_EXPECTING_COLON_ANNOTATION = Se esperaba que '\:' separara el objetivo de uso en sitio y el tipo de anotación.
MSG_INVALID_TYPE = "{0}" no es un tipo válido.
MSG_INVALID_GENERIC_EXCEPTION = Una clase genérica no puede extender "java.lang.Throwable"
MSG_INVALID_INNER_TYPE = No se encontró ninguna clase interna "{0}" en "{1}".
MSG_INVALID_TYPE_WITH_QUALIFIED_NAME = "{0}" tiene un tipo no válido. "{1}".
MSG_NOT_A_STATEMENT = No es una instrucción.
MSG_CANNOT_CONSTRUCT_ABSTRACT_CLASS = "{0}" es abstracto; no se puede construir.
MSG_CANNOT_CONSTRUCT_RECURSIVE_CLASS = "{0}"es recurrente; no se puede construir directamente.
MSG_RECURSIVE_CONSTRUCTOR = Invocación de constructor recurrente.
MSG_MISSING_RETURN = Falta la instrucción de devolución.
MSG_UNREACHABLE_STMT = Instrucción inalcanzable.
MSG_BREAK_OUTSIDE_SWITCH_OR_LOOP = Se usa un salto fuera de la instrucción switch o rizo.
MSG_CONTINUE_OUTSIDE_LOOP = Se continúa utilizando fuera de la instrucción rizo.
MSG_PROPERTY_SET_MUST_HAVE_ONE_PARAMETER = Los operadores de propiedad deben tener exactamente un parámetro.
MSG_PROPERTY_SET_MUST_RETURN_VOID = El operador de propiedad debe devolver un valor nulo.
MSG_MISSING_PROPERTY_RETURN = Falta el tipo de devolución de propiedad.
MSG_IMPLICIT_COERCION_WARNING = Aquí se produce una coerción implícita del tipo {0} a {1}.  Considere hacerla explícita con un "as {1}".
MSG_IMPLICIT_COERCION_ERROR = Debe forzar explícitamente {0} para {1} utilizar la palabra clave 'as'.
MSG_ASYMMETRICAL_COMPARISON = Compresión asimétrica entre {0} y {1}. Considere encasillar uno de los operandos.
MSG_SILLY_ASSIGNMENT = Aquí se produce una asignación inútil de {0} a sí mismo.  Puede ser accidental y deberse a un error del programa.
MSG_UNUSED_VARIABLE = No se usa este {0}.
MSG_LIKELY_JAVA_CAST = Parece tratarse de un intento de realizar un molde estilo Java, que no es un Gosu correcto.  Para moldear una expresión a otro tipo, ponga "as {0}" después de la expresión
MSG_UNEXPECTED_TOKEN = Token inesperado\: {0}
MSG_EXPECTING_INT_ACCESS_TO_ARR_ETC = Se espera acceso int a tipo de matriz, recolección o cadena con el operador [] de matriz.
MSG_EXPECTING_BEAN_TYPE_WITH_REFLECTION_OPERATOR = Se espera tipo bean con el operador de reflexión [].
MSG_PROPERTY_REFLECTION_ONLY_WITH_STRINGS = La reflexión de propiedad Bean sólo puede realizarse con cadenas.
MSG_EXPECTING_BRACKET_TO_CLOSE_DYNAMIC_MEMBER_ACCESS = Se espera el operador ']' para cerrar la expresión de acceso de miembro dinámico.
MSG_WRONG_NUMBER_OF_ARGS_TO_FUNCTION = Número incorrecto de argumentos para la función {0}.  Se esperaban {1}; se obtuvieron {2}.
MSG_WRONG_NUMBER_OF_ARGS_TO_CONSTRUCTOR = Número incorrecto de argumentos para el constructor {0}.  Se esperaban {1}; se obtuvieron {2}.
MSG_SHOULD_HAVE_FOUND_METHOD_AT_LINE = Se debía haber encontrado una función en la línea {0}, columna {1}
MSG_VOID_EXPRESSION_NOT_ALLOWED = Las expresiones en esta posición deben ser no vacía.
MSG_EXPECTING_RETURN_TYPE_OR_FUN_BODY = Se espera tipo de devolución o cuerpo de función.
MSG_INVALID_TYPE_FOR_ANNOTATION_MEMBER = Tipo no válido para el miembro de anotación
MSG_ERRANT_TYPE_VAR = Variable de tipo errante
MSG_USING_VOID_RETURN_TYPE_FROM_NON_NULL_EXPR = Se utiliza tipo de devolución nulo desde una expresión que no admite valores nulos.
MSG_FIELD_TYPE_HAS_NOT_BEEN_INFERRED = Aún no se ha inferido el tipo de este campo y, por lo tanto, no se puede usar.  Esta expresión debe aparecer después de la declaración del campo.
MSG_BEAN_CLASS_IS_NULL = La clase Bean es nula.
MSG_BEAN_MEMBER_PATH_IS_NULL = La ruta de miembro Bean es nula.
MSG_BEAN_MEMBER_PATH_IS_EMPTY = La ruta de miembro Bean está vacía.
MSG_NO_EXPLICIT_TYPE_INFO_FOUND = No se encontró ninguna información de tipo explícita para, {0}
MSG_NO_CONSTRUCTOR_FOUND_FOR_CLASS = No se encontró constructor para la clase, {0}
MSG_WRONG_NUMBER_OF_ARGS_FOR_METHOD_ON_CLASS = Número de argumentos incorrecto para la función, {0}, en la clase, {1}
MSG_NO_METHOD_DESCRIPTOR_FOUND_FOR_METHOD = No se encontró el descriptor de función para la función, {0}, en la clase, {1}
MSG_METHOD_IS_NOT_STATIC = La función "{0}" no es estática en la clase {1}
MSG_METHOD_IS_STATIC = La función "{0}" es estática en la clase {1}
MSG_NO_PROPERTY_DESCRIPTOR_FOUND = No se encontró descriptor de propiedad {0} para la propiedad, {1}, en la clase, {2}
MSG_NO_TYPE_ON_NAMESPACE = No se encontró el tipo {0} en el paquete {1}
MSG_ANY = {0}
MSG_EXPECTING_MEMBER_ACCESS_PATH = Se espera ruta de acceso de miembro.
MSG_CANNOT_CREATE_NEW_ARRAY_FROM_TYPE_VAR = No se puede crear una nueva matriz de instancia desde una variable de tipo.  Sólo se puede acceder al tipo y modificarlo.
MSG_NOT_A_VALID_EXCEPTION_TYPE = {0} no amplía Throwable, y no se puede capturar.
MSG_CANNOT_INFER_ARGUMENT_TYPE_AT_THIS_POSTION = El argumento {0} debe proporcionar una declaración de tipo debido a que no puede inferirse.
MSG_OBSOLETE_CTOR_SYNTAX = Esta sintaxis de constructor es obsoleta. Use la palabra clave 'construct' en su lugar.
MSG_OBSOLETE_NOT_EQUAL_OP = El operador <> está obsoleto y se debe reemplazar con \!\=
MSG_MUST_BE_IN_OUTER_TO_CONSTRUCT_INNER = Debe estar en, o derivarse de, la clase {0} para construir una clase interna no estática {1}.
MSG_TYPE_DOES_NOT_HAVE_EMPTY_CONSTRUCTOR = El tipo {0} no tiene un constructor predeterminado y no se puede crear aquí de forma implícita.
MSG_ENHANCEMENT_DOES_NOT_ACCEPT_THIS_STATEMENT = Las mejoras no pueden tener instrucciones de este tipo.
MSG_CANNOT_OVERRIDE_FUNCTIONS_IN_ENHANCEMENTS = La función "{0}" ya está definida en el tipo {1}.  Las mejoras no pueden anular funciones.
MSG_CANNOT_OVERRIDE_PROPERTIES_IN_ENHANCEMENTS = La propiedad "{0}"ya está definida en el tipo {1}.  Las mejoras no pueden anular propiedades.
MSG_ENHANCED_TYPE_MUST_USE_ENHANCEMENT_TYPEVARS = El tipo mejorado debe usar todas las variables de tipo que se hayan declarado a través de la mejora.
MSG_ABSTRACT_MEMBER_NOT_IN_ABSTRACT_CLASS = El miembro abstracto no se encuentra en la clase abstracta.
MSG_ILLEGAL_USE_OF_MODIFIER = Uso ilegal de modificador, no se puede usar "{0}" con "{1}" aquí
MSG_ILLEGAL_FORWARD_REFERENCE = Referencia hacia adelante ilegal
MSG_MISSING_OVERRIDE_MODIFIER = Falta el modificador 'anulación'. La función {0} anula y/o implementa la función desde {1}.
MSG_RENAME_METHOD = Cambie el nombre de la función. La función {0} entra en conflicto con la función de {1}, con tipos de retorno incompatibles. Las funciones privadas se compilan con acceso "interno", por lo cual entran en conflicto en el tiempo de ejecución cuando están en el mismo paquete.
MSG_STATIC_METHOD_CANNOT_OVERRIDE = La función estática {0} no puede anular o implementar la función de {1}.
MSG_OVERRIDES_OBJECT_METHOD = El método predeterminado {0} anula el método del objeto
MSG_INHEREITED_WITH_DIFF_ARG_TYPES = "{0}" no se puede heredar con diferentes argumentos de tipo\: {1}
MSG_NO_IMPLEMENTS_ALLOWED = No se permite ninguna cláusula de implementos en la interfaz.
MSG_NO_EXTENDS_ALLOWED = No se permite ninguna cláusula de extensiones en la anotación.
MSG_FUNCTION_NOT_OVERRIDE = La función {0} no anula nada
MSG_FUNCTION_NOT_OVERRIDE_PROPERTY = La función {0} no anula nada. ¿Es posible que quiera anular una propiedad '{1}'?
MSG_PROPERTY_OVERRIDES_WITH_INCOMPATIBLE_TYPE = Anulaciones de propiedad con tipo incompatible
MSG_SUBCLASS_OBJECT = {0} hace del objeto una subclase de forma explícita
MSG_AMBIGUOUS_SYMBOL_REFERENCE = Esta referencia es ambigua. Califique completamente el símbolo.
MSG_LIST_TO_ARRAYLIST_WARNING = Coerción implícita a ArrayList. Use ArrayList explícitamente.
MSG_VAR_CASE_MISMATCH = La cláusula "case" adecuada no hace referencia a la variable "{0}".  Cambie esta referencia a "{1}".
MSG_FUNCTION_CASE_MISMATCH = La cláusula "case" adecuada no hace referencia a la función "{0}".  Cambie esta referencia a "{1}".
MSG_PROPERTY_CASE_MISMATCH = La cláusula "case" adecuada no hace referencia a la propiedad "{0}".  Cambie esta referencia a "{1}".
MSG_TYPE_CASE_MISMATCH = La cláusula "case" adecuada no hace referencia al tipo "{0}".  Cambie esta referencia a "{1}".
MSG_NON_STATIC_ACCESS_OF_STATIC_MEMBER = La propiedad "{0}" es estática, pero no se hace referencia a ella de forma estática en el tipo {1}.
MSG_NON_STATIC_ACCESS_WITH_IDENTIFIER_OF_STATIC_MEMBER = La propiedad "{0}" es estática, pero no se hace referencia a ella directamente fuera del tipo {1}.  \nExiste una variable o propiedad conflictiva con el nombre "{2}".  Habilite completamente la expresión como {3}.{0}.
MSG_STATEMENT_ON_SAME_LINE = Varias instrucciones ocupan la misma línea; puede indicar un error lógico involuntario.\nConsidere mover la instrucción a una nueva línea.
MSG_MUST_BE_DEFINED_AS_CLASS = Debe definirse como "clase".
MSG_VOID_RETURN_IN_CTX_EXPECTING_VALUE = Esta función espera que el bloque devuelva un valor.
MSG_NO_STATIC_CONSTRUCTOR = Los constructores no pueden ser estáticos
MSG_NO_ABSTRACT_METHOD_CALL_IN_CONSTR = La función {0} es abstracta y no puede llamarla en el constructor.
MSG_CALLING_OVERRIDABLE_FROM_CTOR = Llamada a función anulable desde el constructor\: {0}
MSG_AMBIGUOUS_METHOD_INVOCATION = Esta es una llamada de función ambigua.
MSG_RETURN_VAL_FROM_VOID_FUNCTION = Intenta que se devuelva un valor de una función nula.
MSG_BAD_ANONYMOUS_CLASS_DECLARATION = Sólo se pueden ampliar de forma anónima los tipos java y gosu.
MSG_SINGLE_ANON_CTOR = Se puede definir una clase anónima en un constructor como máximo
MSG_ANON_CTOR_PARAMS_CONFLICT_WITH_CALL_SITE = Los tipos de parámetro de constructor anónimo están en conflicto con los tipos arg del sitio de llamada
MSG_ASSIGNMENT_IN_IF_STATEMENT = Las asignaciones no son legales dentro de condiciones si.
MSG_ASSIGNMENT_IN_LOOP_STATEMENT = Las asignaciones no son legales dentro de condiciones de bucle.
MSG_JAVA_STYLE_VARIABLE_DECLARATION = Esta es una declaración de variable de estilo java.  Utilice la palabra clave "var" en su lugar.
MSG_NUMERIC_TYPE_EXPECTED = Se espera una expresión numérica.
MSG_GETTER_CANNOT_HAVE_PARAMETERS = Una definición de obtención de propiedad no puede tener parámetros.
MSG_BAD_TEMPLATE_DIRECTIVE = Directiva de plantilla no válida.  Las directivas válidas son "extends" y "params".
MSG_CLASSPATH_STATEMENT_EXPECTS_A_STRING = La instrucción classpath requiere una cadena para la ruta
MSG_COMMA_IS_THE_CLASSPATH_SEPARATOR = La instrucción classpath utiliza comas como separador de rutas independiente de la plataforma
MSG_BITSHIFT_LHS_MUST_BE_INT_OR_LONG = El operando del lado izquierdo debe ser int o largo.
MSG_BITWISE_OPERAND_MUST_BE_INT_OR_LONG = El operando lógico al nivel de bit debe ser int o largo.
MSG_EXPECTING_LEFTPAREN_USING = Se espera '(' para abrir el predicado "utilizar".
MSG_EXPECTING_RIGHTPAREN_USING = Se espera ')' para cerrar el predicado "utilizar".
MSG_BAD_TYPE_FOR_USING_STMT = El predicado de la instrucción a utilizar debe ser Closeable, IDisposable o Lock. Moldeado a IMonitorLock para sincronización estilo Java.
MSG_UNNECESSARY_COERCION = Esta expresión ya es de tipo {0}, por lo tanto, no se requiere moldear a {1}.
MSG_LATER_ASSIGNMENT_MAKES_EXPRESSION_ILLEGAL = Una asignación posterior a {0} cancela la inferencia de tipo que permite este uso.
WSDL_DUPLICATE_WEB_SERVICE = Duplicar nombre de servicio Web.  Sólo se puede definir un servicio Web con el nombre dado.
MSG_NUMBER_LITERAL_TOO_LARGE = Literal de número excesivamente largo.
WSDL_DUPLICATE_METHOD = Duplicar funciones de servicio Web.  Las funciones sobrecargadas deben tener un número de parámetros diferente, incluso si los tipos de parámetro son diferentes.\n{0} entra en conflicto con {1}.
WSDL_NOT_WEBSERVICE = Esta anotación es válida sólo en Web Service
WSDL_UNSUPPORTED_TYPE = El servicio Web no puede hacer referencia al siguiente tipo no compatible\: {0} {1}
WSDL_REFERENCE_ABSTRACT_CLASS = El servicio Web no puede hacer referencia a una clase abstracta\: {0} {1}
WSDL_REFERENCE_INTERFACE = El servicio Web no puede hacer referencia a una interfaz\: {0} {1}
WSDL_REFERENCE_ANNOTATION = El servicio Web no puede hacer referencia a una anotación\: {0} {1}
WSDL_REFERENCE_TRANSACTION_TYPE = El servicio Web no puede hacer referencia a un tipo en el espacio de nombre gw.transaction.*\: {0} {1}
WSDL_REFERENCE_LIST = El servicio Web no puede hacer referencia a tipos de lista\: {0}.  En lugar de esto, pruebe con una matriz con tipo asignado sólidamente (por ejemplo, String[]). {1}
WSDL_REFERENCE_MAP = El servicio Web no puede hacer referencia a tipos de asignación\: {0} {1}
WSDL_REFERENCE_COLLECTION = El servicio Web no puede hacer referencia a tipos de recopilación\: {0}.  En lugar de esto, pruebe con una matriz con tipo asignado sólidamente (por ejemplo, String[]). {1}
WSDL_REFERENCE_PARAMETERIZED_TYPE = El servicio Web no puede hacer referencia a tipos parametrizados\: {0}
WSDL_REFERENCE_GENERIC_TYPE = El servicio Web no puede hacer referencia a tipos genéricos\: {0} {1}
WSDL_REFERENCE_UNSUPPORTED_NAMESPACE = El servicio Web no puede hacer referencia al siguiente tipo. Forma parte de un espacio de nombre incompatible, sólo se permiten tipos del espacio de nombre 'gw.*' (excepto gw.transaction.*)\: {0} {1}
WSDL_REFERENCE_CLASS_WITHOUT_DEFAULT_CONSTRUCTOR = La clase {0} no tiene un constructor predeterminado y un servicio Web no puede hacer referencia a ésta. {1}   //Posiblemente debería ser una advertencia.
WSDL_REFERENCE_WEBSERVICE = El servicio Web no puede hacer referencia a otros tipos de servicio Web\: {0} {1}
WSDL_REFERENCE_SOAP_TYPE = Los servicios Web no pueden hacer referencia a tipos en el nombre de espacio soap.*\: {0} {1}
WSDL_REFERENCE_XML_TYPE = Los servicios Web no pueden referirse a tipos basados en xml\: {0} {1}
WSDL_READONLY_PROPERTIES = Los servicios Web no deben hacer referencia a tipos que tengan propiedades de sólo lectura.  \nEstos tipos no pueden establecer un parámetro para una operación de servicio Web. {0} {1}
WSDL_WRITEONLY_PROPERTIES = Los servicios Web no deben hacer referencia a tipos que tengan propiedades de sólo escritura.  \nEstos tipos no pueden establecer un tipo de devolución para una operación de servicio Web. {0} {1}
WSDL_REFERENCE_CAUSES_NAMESPACE_COLLISION = Este tipo provoca una colisión del espacio de nombre de los servicios Web.\nEstos dos tipos tienen el mismo nombre relativo y serían expuestos a los servicios Web en el mismo espacio de nombre soap.*.{0}.\nCambie el nombre a uno de los siguientes tipos o verifique que no se haga referencia al mismo en un servicio Web. {1} y {2}.  {3}
MSG_DELEGATION_NOT_ALLOWED_HERE = No se permite la delegación aquí
MSG_DELEGATE_MUST_NOT_BE_STATIC = La delegación estática no es compatible
MSG_DELEGATES_REPRESENT_INTERFACES_ONLY = Un delegado sólo puede representar tipos de interfaz
MSG_ONLY_INTERFACES_ALLOWED_HERE = Sólo se permiten interfaces aquí
MSG_ONLY_ONE_CLASS_IN_COMPONENT_TYPE = Sólo se permite una ausencia de interfaz en un tipo de componente
MSG_ONLY_ONE_TYPE_VARIABLE = Una variable de tipo no puede estar seguida por otras cotizaciones
MSG_NO_ARRAY_IN_COMPONENT_TYPE = No se permiten matrices en un tipo de componente
MSG_NO_PRIMITIVE_IN_COMPONENT_TYPE = No se permiten primitivos en un tipo de componente
MSG_COMPOUND_TYPE_NOT_ALLOWED_HERE = No se permite un tipo compuesto aquí
MSG_PARAMETERIZED_TYPE_NOT_ALLOWED_HERE = Aquí no se permite un tipo parametrizado
MSG_DYNAMIC_TYPE_NOT_ALLOWED_HERE = Aquí no se permite un tipo dinámico
MSG_CANNOT_EXTEND_INTERNAL_JAVATYPE = El tipo Java {0} tiene un acceso con protección de paquete y no puede extenderse ni mejorarse en Gosu
MSG_CLASS_DOES_NOT_IMPL = La interfaz delegada no se implementó con la declaración del tipo {0}
MSG_EXPECTING_REPRESENTS = Se espera la cláusula 'representa' para el delegado
MSG_EXPECTING_LEFTPAREN_AGGREGATE = Se espera '(' para abrir el tipo de agregado
MSG_EXPECTING_RIGHTPAREN_AGGREGATE = Se espera ')' para cerrar el tipo de agregado
MSG_MEMBER_ACCESS_REQUIRED_FOR_SUPER = Se requiere acceso de miembro para 'super'
MSG_ALREADY_CONTAINS_TYPE = Tipo ya especificado {0}
MSG_OVERRIDING_FUNCTION_MUST_HAVE_SAME_NUMBER_OF_TYPE_VARS = Para que esta función anule correctamente su función de elemento primario, debe tener {0} variables de tipo
MSG_AGGREGATES_MUST_CONTAIN_MORE = Un tipo agregado debe tener más de un tipo
MSG_INTERFACE_REDUNDANT = Interfaz {0} redundante, {1} amplía {0}
MSG_NONTERMINAL_CASE_CLAUSE = La cláusula case anterior no es terminal; es posible que falte una instrucción interrumpir, continuar o devolver
MSG_ANONYMOUS_CLASS_NOT_ALLOWED_HERE = No se permite una clase anónima aquí
MSG_PARAMETERIZED_ARRAY_COMPONENT = El tipo de componente de matriz parametrizado pierde los parámetros de tipo en tiempo de ejecución
MSG_TEMPLATE_EXCEPTION_GENERATED_SOURCE = Origen generado
MSG_TEMPLATE_MISSING_END_TAG_SCRIPTLET = Falta la etiqueta final '%>' para el scriptlet.
MSG_TEMPLATE_MISSING_END_TAG_EXPRESSION = Falta la etiqueta final '%>' para la expresión.
MSG_TEMPLATE_MISSING_END_TAG_EXPRESSION_ALT = Falta la etiqueta final '}' para la expresión.
MSG_TEMPLATE_MULTIPLE_PARAMS = Se encontraron varias directivas "params".
MSG_TEMPLATE_INVALID_PARAMS = Parámetros no válidos\: {0}
MSG_TEMPLATE_UNKNOWN_DIRECTIVE = Directiva {0} desconocida.  Las directivas válidas son "params" y "extends".
MSG_EQUALS_FOR_INITIALIZER_EXPR = Se espera un '\=' en este inicializador de objeto.
MSG_INITIALIZER_NOT_ALLOWED_ABSTRACT_PROPERTY = Inicializador no admitido en propiedad abstracta.
MSG_EXPECTING_NAME_VALUE_PAIR = Se espera un nombre de propiedad seguido por un '\=' y un valor de expresión.
MSG_REDUNTANT_INITIALIZERS = La propiedad {0} ya tiene un valor de inicializador.
MSG_ONLY_ONE_COLON_IN_INITIALIZERS = Sólo el símbolo de dos puntos puede preceder a un nombre de propiedad en los inicializadores.
MSG_EXPECTING_PROPERTY_NAME = Se espera un nombre de propiedad.
MSG_BLOCK_TYPES_SHOULD_HAVE_ARG_NAMES = Los parámetros de tipo de bloque deberían especificar nombres y adoptar la forma 'argName\:Type'.
MSG_DIMENSION_MULTIPLICATION_UNDEFINED = Multiplicación sin definir entre dimensiones
MSG_DIMENSION_ADDITION_MUST_BE_SAME_TYPE = Los operandos deben ser dimensiones del mismo tipo final
MSG_DIMENSION_DIVIDE_SCALAR_BY_DIMENSION = No se puede dividir el valor escalar por dimensión
MSG_DIMENSION_MUST_BE_FINAL = La aritmética de la dimensión debe implicar tipos finales. {0} no es final.
MSG_DIMENSION_NONSTANDARD_NUMBER_NO_OVERRIDE = Faltan método(s) aritmético(s) en la dimensión, {0}, con el tipo de número no estándar, {1}
MSG_RELATIONAL_OPERATOR_CANNOT_BE_APPLIED_TO_TYPE = El operador relacional '{0}' no puede aplicarse al tipo {1}
MSG_ARITHMETIC_OPERATOR_CANNOT_BE_APPLIED_TO_TYPES = El operador "{0}" no se puede aplicar a "{1}", "{2}"
MSG_ASSIGNMENTS_MUST_BE_ENCLOSED_IN_CURLIES_IN_BLOCKS = Las asignaciones en el cuerpo de un bloque deben encerrarse entre corchetes
MSG_BLOCKS_CAN_HAVE_A_MOST_SIXTEEN_ARGS = Los bloques pueden tener un máximo de 16 args.
MSG_BLOCKS_LITERAL_NOT_ALLOWED_IN_NEW_EXPR = No se permiten literales de bloques en una nueva expresión.
MSG_STATEMENTS_MUST_BE_ENCLOSED_IN_CURLIES_IN_BLOCKS = Las instrucciones "{0}" en el cuerpo de un bloque deben encerrarse entre corchetes
MSG_NOT_AN_ENHANCEABLE_TYPE = {0} no admite mejoras.
MSG_CANNOT_REFERENCE_CLASS_TYPE_VAR_IN_STATIC_CONTEXT = No se puede hacer referencia a variables de tipo de clase en un contexto estático.
MSG_CANNOT_REFERENCE_THIS_IN_STATIC_CONTEXT = No se puede hacer referencia a "esto" en un contexto estático.
MSG_CANNOT_CALL_NON_STATIC_METHOD_FROM_STATIC_CONTEXT = No se puede hacer referencia a métodos no estáticos en un contexto estático.
MSG_CANNOT_REFERENCE_NON_STATIC_PROPERTY_FROM_STATIC_CONTEXT = No se puede hacer referencia a propiedades no estáticas en un contexto estático.
MSG_CANNOT_REFERENCE_NON_STATIC_FEATURE_HERE = No puede hacer referencia aquí a una función no estática
MSG_ONLY_GOSU_JAVA_TYPES = Aquí solo se admiten tipos Gosu y Java
MSG_CANNOT_READ_A_WRITE_ONLY_PROPERTY = Las propiedades de sólo escritura sólo pueden escribirse
MSG_TYPE_IS_NOT_ITERABLE = Se espera tipo repetitivo para operador de expansión - {0}
MSG_INTERVAL_MUST_BE_ITERABLE_HERE = El tipo de intervalo debe ser iterable aquí
MSG_EXTRA_DOT_FOUND_IN_INTERVAL = El operador de intervalo lleva dos puntos; se encontraron tres
MSG_EXPECTING_NUMBER_TO_FOLLOW_DECIMAL = Esperaba un número decimal
MSG_IMPROPER_VALUE_FOR_NUMERIC_TYPE = Este valor {0} no cae dentro del dominio de números de tipo {1}
MSG_PRIMITIVE_TYPE_PARAM = No se admite el tipo primitivo {0} aquí. El tipo {0} se transforma implícitamente en {1} como un parámetro de tipo, use {1} directamente.
MSG_CTOR_HAS_XXX_ACCESS = El constructor tiene acceso a {0}
MSG_TYPE_HAS_XXX_ACCESS = El tipo '{0}' tiene acceso a {1}
MSG_QUERY_SPECIFY_COLUMN = Especifique una columna de consulta
MSG_QUERY_SPECIFY_QUERY_COLUMN = {0} debe especificar una columna en la base de datos que pueda ser consultada
MSG_CANNOT_EXTEND_RAW_GENERIC_TYPE = El tipo genérico '{0}' requiere argumentos de tipo
MSG_TYPE_VAR_VARIANCE_ERROR = La variable de tipo {0} se ha declarado "{1}" pero se utiliza en una posición "{2}" con tipo {3}
MSG_SUPER_CLASS_METHOD_NAME_SAME_AS_SUBCLASS = El método de superclase '{0}' entra en conflicto con el nombre de constructor interno de la clase. Cambie el nombre de método de superclase o el nombre de esta clase.
MSG_NOT_A_SUPERTYPE = {0] no es un tipo super directo
MSG_CALL_TO_SUPER_THIS_MUST_BE_FIRST = La llamada a '{0}()' debe estar en la primera instrucción del constructor
MSG_EXPECTING_OPERATOR_TO_FOLLOW_NEW_EXPRESSION = Instrucción incompleta. Se espera que el operador siga a la nueva expresión.
MSG_EXPECTING_TYPE_TO_FOLLOW_PACKAGE_NAME = Se espera que el tipo siga al nombre de paquete
MSG_QUERY_FUNCTION_EXPRESSION_RESTRICTION = Sólo se permiten referencias a columnas de base de datos o a llamadas de método DBFunction
MSG_QUERY_ORDER_BY_EXPRESSION = Sólo se permiten expresiones que devuelven una columna de base de datos, una ArrayList o una matriz de columnas de base de datos
MSG_QUERY_ARRAYS_NOT_ALLOWED = No se permite aquí acceso a una matriz.
MSG_APPLICATION_MODIFIER_HAS_BEEN_DEPRECATED = El modificador "aplicación" perdió su valor. Utilice la asignación gw.api.web.Scopes.Application en su lugar.
MSG_SESSION_MODIFIER_HAS_BEEN_DEPRECATED = El modificador "sesión" perdió su valor. Utilice gw.api.web.SessionVar en su lugar.
MSG_REQUEST_MODIFIER_HAS_BEEN_DEPRECATED = El modificador "solicitud" perdió su valor. Utilice gw.api.web.RequestVar en su lugar.
MSG_EXECUTION_MODIFIER_HAS_BEEN_DEPRECATED = El modificador "ejecutar" ha perdido su valor y no tiene significado.  Puede quitarlo.
MSG_CANNOT_REFERENCE_OUTER_SYMBOL_WITHIN_ENHANCEMENTS = No se puede hacer referencia a la palabra clave externa dentro de mejoras.  Considere mover esta clase anónima a una clase nombrada.
MSG_CANNOT_REFERENCE_ENCLOSING_PROPERTIES_WITHIN_ENHANCEMENTS = No se puede hacer referencia a los métodos del tipo de encierro dentro de mejoras.  Considere mover esta clase anónima a una clase nombrada.
MSG_CANNOT_REFERENCE_ENCLOSING_METHODS_WITHIN_ENHANCEMENTS = No se puede hacer referencia a los métodos del tipo de encierro dentro de mejoras.  Considere mover esta clase anónima a una clase nombrada.
MSG_INVALID_LITERAL = Este literal no puede convertirse en {0}.  Deberá construir el valor explícitamente.
MSG_PROPERTIES_MUST_AGREE_ON_STATIC_MODIFIERS = Tanto el captador como el fijador de propiedades deben ser estáticos o no estáticos
MSG_PROPERTIES_MUST_AGREE_ON_TYPE = El captor y el colaborador de propiedades deben estar de acuerdo con el tipo de propiedad
MSG_NO_ENCLOSING_INSTANCE_IN_SCOPE = No hay instancia envolvente de tipo '{0}' en ámbito
MSG_EXPECTING_CONDITION_FOR_ASSERT = Se espera condición de 'assert'
MSG_EXPECTING_MESSAGE_FOR_ASSERT = Se espera un mensaje de 'assert'
MSG_ASSERTIONS_NOT_ALLOWED_HERE = No se permite una instrucción Assert aquí
MSG_ARRAY_NOT_SUPPORTED = No se admite el tipo de matriz en {0}
MSG_IMPROPER_USE_OF_KEYWORD = Uso incorrecto de la palabra clave, {0}
MSG_USES_STMT_CONFLICT = Ya se está usando el tipo, {0}
MSG_USES_STMT_DUPLICATE = Duplicado utiliza una declaración
MSG_ARRAY_INDEX_MUST_BE_INT = Las matrices deben indexarse con un valor int
MSG_PARAM_TYPE_CANT_BE_INFERRED_FROM_LATE_BOUND_EXPRESSION = No se puede inferir el tipo de parámetro a partir del tipo de expresión vinculada en tiempo de ejecución
MSG_LOSS_OF_PRECISION_IN_NUMERIC_LITERAL = Esta doble literal pierde la precisión en esta operación.  En su lugar, debe declararla explícitamente como un BigDecimal\: {0}
MSG_COMPILE_TIME_ANNOTATION_FAILED_TO_EXECUTE = No se ejecutó una anotación de tiempo compilada.  El mensaje fue {0}. Vea la consola para seguir la pista de una pila
MSG_METHOD_REIFIES_TO_SAME_SIGNATURE_AS_ANOTHER_METHOD = Un método con el mismo nombre concretiza a la misma firma al nivel bytecode. Cambiar nombre de uno de los métodos.
MSG_TYPE_NOT_REIFIED = {0} debe declararse con el modificador "reificado" para acceder a la variable de tipo "{1}" en el tiempo de ejecución.
MSG_REIFIED_DONT_MATCH = Debe anular la función con la misma configuración de "reificado"
MSG_REIFIED_DONT_MATCH_JAVA = El método genérico reificado {0} anula el método Java en {1}. Invocar a {0} de {1} borra los parámetros de tipo.
NOTHING_TO_REIFY = Nada por reificar
MSG_PROPERTY_AND_FUNCTION_CONFLICT = El método {0} está en conflicto con los métodos implícitos generados por la propiedad {1}
MSG_PROPERTY_AND_FUNCTION_CONFLICT_UPON_REIFICATION = El método {0} está en conflicto con los métodos implícitos generados por la propiedad {1} al reificar
MSG_CANNOT_OVERRIDE_FUNCTION_FROM_ENHANCEMENT = No puede anularse un método definido en un mejoramiento.
MSG_MASKING_ENHANCEMENT_METHODS_MAY_BE_CONFUSING = Este método enmascara un método definido como un mejoramiento en este tipo.  Puede conducir a confusiones semánticas, ya que los métodos de mejoramiento se despachan estáticamente.
MSG_STRING_COERCION_ON_RHS_OF_ADDITIVE_EXPRESSION_MUST_BE_PARENTHESIZED = Puede resultar confuso encasillar a una cadena con una expresión aditiva.  Ponga la expresión entre paréntesis para evaluarla correctamente.
MSG_EXPLICIT_TYPE_RECOMMENDED_FOR_CATCH_STMTS = Debería agregar aquí un tipo atrapado explícitamente.
MSG_SUPER_NOT_ACCESSIBLE_FROM_BLOCK = El súper símbolo no es accesible desde dentro de bloques.
MSG_GENERIC_PROPERTIES_NOT_SUPPORTED = Las propiedades no pueden tener variables de tipo.
MSG_GENERIC_ANNOTATIONS_NOT_SUPPORTED = Las anotaciones no pueden tener variables de tipo.
MSG_CATCH_STMT_CANNOT_EXECUTE = Esta instrucción de atrapar nunca se ejecutará porque una instrucción de atrapar previa atrapa las excepciones de este tipo.
MSG_IMONITOR_LOCK_SHOULD_ONLY_BE_USED_WITHIN_USING_STMTS = La interfaz IMonitorLock puede utilizarse sólo con estilo de expresiones que usan instrucciones para la sincronización tipo histórica de estilos.
MSG_STATIC_MODIFIER_NOT_ALLOWED_HERE = No se permite aquí un modificador 'estático'.
MSG_MODIFIERS_NOT_ALLOWED_HERE = Aquí no se permiten los modificadores.
MSG_CANNOT_INSTANTIATE_NON_STATIC_CLASSES_HERE = Aquí no se puede instanciar una clase no estática.
MSG_WARN_ON_SUSPICIOUS_THIS_COMPARISON = Parece ser una comparación errónea. En gosu, el operador '\=\=' es equivalente a .igual a().  Si desea realizar una equivalencia de instancia, utilice el operador '\=\=\=' en su lugar.
MSG_FL_EXPECTING_FEATURE_NAME = Se esperaba aquí un nombre de función, ya sea un nombre de método, un nombre de propiedad o una 'construct'
MSG_FL_EXPECTING_RIGHT_CARET = Esperaba un '>'
MSG_FL_GENERIC_FUNCTION_REFERENCES_NOT_YET_SUPPORTED = No son compatibles aún las literales de función genérica.
MSG_FL_EXPECTING_RIGHT_PAREN = Esperaba una ')' para cerrar la lista de tipos de argumentos.
MSG_FL_CONSTRUCTOR_NOT_FOUND = No se encontró un constructor con los tipos {0}
MSG_FL_METHOD_NOT_FOUND = No se encuentra un método con el nombre {0} y tipos {1}
MSG_FL_PROPERTY_NOT_FOUND = No se encuentra una propiedad con el nombre {0}
MSG_FL_STATIC_FEATURES_MUST_BE_REFERENCED_FROM_THEIR_TYPES = Una función o constructor estático debe referirse directamente al tipo al que pertenece esa función.
MSG_NO_TYPE_AFTER_CONSTRUCTOR = Constructores no pueden especificar un tipo de devolución.
WS_ERR_Can_Not_Marshal = {0} No se puede ordenar tipo local {2} para {1}
WS_ERR_Annotation_Duplicate_Namespace = En {0}\: namespace duplicado "{1}" ya se usó en "{2}". {3} intenta volver a introducirlo en {4}.
WS_ERR_Annotation_Exception = Se omiten las propiedades de tipo {0} vea el registro para  seguimiento de pilas
WS_ERR_Annotation_Invalid_Namespace = {0}\: Namespace no válido "{1}"
WS_ERR_Annotation_Only_For_WebService = {0}\: La anotación @{1} puede usarse solo en clases anotadas con @WsiWebService
WS_ERR_Annotation_Operation_Duplicate = En {0}\: método {1}, ya hay un método con ese nombre
WS_ERR_Annotation_Operation_OneWay_Invalid = Los métodos de una vía deben tener el tipo de devolución vacío
WS_ERR_Annotation_Operation_Response_Reserved = En {0}\: método {1}, el sufijo "Respuesta" está reservado para elementos de respuesta
WS_ERR_Export_Inner_Only_On_WebService = En {0}\: Las clases internas tipo {1} no son exportables
WS_ERR_Export_Inner_Not_Name_Of_Method = Las clases internas tiene el mismo nombre solicitado para el método {0}
WS_ERR_Export_Inner_Not_Name_Of_Response = Las clases internas tienen el mismo nombre que la respuesta para el método {0}
WS_ERR_Export_No_Constructor = En {0}\: Tipo {1} una clase exportable necesita un constructor público predeterminado
WS_ERR_Export_No_Extends = En {0}\: Tipo {1} una clase exportable no se puede extender a otra clase
WS_ERR_Export_Not_Final = En {0}\: Tipo {1} no es final. Una clase exportable debe ser final
WS_ERR_Export_Not_WebService = En {0}\: Tipo {1} es un servicio web. No se puede exportar un servicio web
WS_ERR_Export_Recursive = No es compatible la recursión, debe asegurar que {0} no es recursivo
WS_WARN_Annontation_Some_Generators_Dont_Support_Schema = {0} Advertencia del parámetro de procesamiento {1}, algunas estructuras de servicios web podrían no entender {2}
WS_WARN_Annontation_Not_Available = {0} no está disponible hasta{1}
WS_WARN_Ignored = {0} \: Se omite la propiedad {1} de tipo {2}
PCF_ERR_Verify = Error PCF al intentar comprobar {0}.
MSG_FL_ONLY_PROPERTIES_MAY_BE_CHAINED = Solo se pueden encadenar literales de propiedad.
Gen_Wsi_InvalidType = {0} no puede ordenar {1}\: {2}
Gen_Wsi_UnsupportedType = {0} es un tipo válido, pero no es compatible con servicios web.
Gen_Wsi_UnsupportedComponentType = {0} no es compatible debido a que su tipo de componente/parámetro no se admite.
Gen_Wsi_NoComponentType = {0} no es compatible, ya que no se ha especificado un tipo de componente o parámetro.
Gen_Wsi_NoBase = {0} clase XmlBase no es admitida directamente.
Gen_Wsi_AnonElement = 0} Los elementos anónimos no son compatibles. Los elementos anónimos son secundarios de otro elemento. Puede intentar usar el tipo del elemento secundario.
Gen_Wsi_AnonType = {0} los tipos anónimos (tipos declarados con declaración en elemento) no son compatibles. Intente utilizar el elemento.
Gen_Wsi_NoSimple = {0} los tipos XSD Simple no son compatibles. Intente crear un tipo complejo o use el tipo extendido.
Gen_Wsi_XmlError = Error inesperado al procesar {0}\: {1}
Gen_Wsi_NullType = Tipo nulo aprobado
Gen_Wsi_TypeNotGosu = {0} no es gosu, por lo que no es compatible con una implementación wsi.
Gen_Wsi_TypeNotWSAnnotated = {0} no posee una anotación @WsiWebService.
Gen_Wsi_TypeNotEXPAnnotated = {0} no posee una anotación @WsiExportable.
GEN_CAN_NOT_MARSHAL_GOSU_REMOTEABLE_ENUMS = {0} no pueden ordenar GWEnumerations escritas en Gosu
GEN_CAN_NOT_MARSHAL_REMOTEABLE_ENUMS_EXTENDED = {0} no puede ordenar GWEnumerations que tengan propiedades adicionales
GEN_CAN_NOT_MARSHAL_XML_IN_EXPORTABLE = {0} no puede ordenar xml en tipos WsiExportable
GEN_CLASS_CANNOT_BE_BOTH_WS_AND_EXPORT = {0} clase no puede ser @WsiWebService y {1}
GEN_CHECKING = Verificando {0}
GEN_CHANGED = {0} modificada
WS_ERR_Invalid_Supertype = {0} no es extensiva {1}
WS_ERR_Export_Empty = {0} no tiene propiedades exportables
WS_ERR_Previous_Invalid = {0} no es válido. Errores informados anteriormente
WS_ERR_Entity_Invalid = {0} no es válida. Sin compatibilidad para ordenar entidades, genere una clase WsiExportable con los campos requeridos.
WS_ERR_Collection_Invalid = {0} no es válido. Solo se permiten matrices y listas <T>.
WF_WARN_Subtype = El subtipo de flujo de trabajo "{0}" está definido como no externo, pero no se ha definido un script o el script no se pudo analizar. Verifique si hay errores de análisis en los registros.
WF_ERR_Duplicate = Hay más de un proceso de flujo de trabajo con typecode "{0}" y versión "{1}" idénticos.
WF_ERR_Parse = No se pudo analizar "{0}" -- {1}\: {2}
WF_ERR_Convert = No se pudo convertir "{0}" -- {1}\: {2}
WF_ERR = En "{0}"\: {1}

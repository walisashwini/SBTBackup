ARRAY = Série
BEAN = Composant logiciel
BOOLEAN = Booléen
DATETIME = HeureDate
FUNCTION = Fonction
IDENTIFIER = Identificateur
METATYPENAME = Type
NULLTYPENAME = Nul
NUMERIC = Nombre
STRING = Caractère
MSG_SYNTAX_ERROR = Erreur de syntaxe.
MSG_BAD_IDENTIFIER_NAME = Impossible de résoudre le symbole pour \: {0}
MSG_END_OF_STMT = En attente de la fin de la déclaration. Possibilité d'opérateur inapproprié ou manquant.
MSG_END_OF_EXPRESSION = En attente de la fin de l'expression. Possibilité d'opérateur inapproprié ou manquant.
MSG_EXPECTING_OPERATOR_TO_FOLLOW_EXPRESSION = Déclaration incomplète. En attente que l'opérateur suive l'expression.
MSG_EXPECTING_ARGS = En attente d'argument[s] pour la fonction, {0}
MSG_EXPECTING_EXPRESSION_CLOSE = En attente de ')' pour fermer l'expression entre parenthèses.
MSG_EXPECTING_FUNCTION_CLOSE = En attente de ')' pour fermer l'appel de fonction.
MSG_EXPECTING_TYPE_NAME = En attente d'un nom de type.
MSG_PARAMETERIZATION_NOT_SUPPORTED_FOR_TYPE = {0} ne prend pas en charge le paramétrage.
MSG_NO_ARGUMENTS = La fonction {0} n'accepte aucun argument.
MSG_NULL_SYMBOL_TABLE = La table de symboles est nulle ou vide.
MSG_TYPE_MISMATCH = Le type "{1}" ne peut pas être converti en "{0}"
MSG_VALUE_MISMATCH = Valeur inappropriée. La valeur littérale, "{0}", ne peut pas être convertie en un {1}.
MSG_WRONG_NUM_OF_ARGS = Nombre d'arguments inapproprié pour la fonction, {0}
MSG_EXPECTING_NAME_FUNCTION_DEF = En attente d'un nom pour la fonction.
MSG_EXPECTING_LEFTPAREN_FUNCTION_DEF = En attente de '(' pour ouvrir la déclaration d'argument de la fonction.
MSG_EXPECTING_RIGHTPAREN_FUNCTION_DEF = En attente de ')' pour fermer la déclaration d'argument de la fonction.
MSG_EXPECTING_TYPE_FUNCTION_DEF = En attente de la clause "\:" pour la déclaration de fonction.
MSG_EXPECTING_TYPE_LITERAL_FUNCTION_DEF = En attente du type après "\:" pour la déclaration de fonction.
MSG_EXPECTING_IDENTIFIER_FOREACH = En attente de l'identificateur pour la déclaration "for...in".
MSG_EXPECTING_IDENTIFIER_FOREACH_INDEX = En attente de l'identificateur dans "index" de la déclaration "for...in".
MSG_EXPECTING_IDENTIFIER_FOREACH_ITERATOR = Attente de l'identifiant dans l'"iterateur" de la déclaration "for...in".
MSG_FOREACH_ITERATOR_NOT_ALLOWED = « itérateur » n'est pas autorisé pour une déclaration de type « for...in » sans variable de boucle.
MSG_ITERATOR_SYMBOL_ONLY_SUPPORTED_ON_ITERABLE_OBJECTS = Un symbole d'"itérateur" est uniquement pris en charge pour les objets Iterable.
MSG_EXPECTING_IDENTIFIER_EXISTS = En attente de l'identificateur pour l'expression "exists"
MSG_EXPECTING_IDENTIFIER_EXISTS_INDEX = En attente de l'identificateur dans "index" de l'expression "exists"
MSG_EXPECTING_IN_FOREACH = En attente de la clause "in" pour la déclaration "for...in".
MSG_EXPECTING_LEFTPAREN_FE = En attente de '(' dans la déclaration "for...in".
MSG_EXPECTING_RIGHTPAREN_FE = En attente de ')' dans la déclaration "for...in".
MSG_EXPECTING_LEFTPAREN_BLOCK = En attente de '(' dans la déclaration de type de bloc.
MSG_EXPECTING_RIGHTPAREN_BLOCK = En attente de ')' dans la déclaration de type de bloc.
MSG_EXPECTING_COLON_BLOCK = En attente de '\:' dans la déclaration de type de bloc.
MSG_EXPECTING_IN_EXISTS = En attente de "in" pour l'expression "exists".
MSG_EXPECTING_WHERE_EXISTS = En attente de "where" pour l'expression "exists".
MSG_EXPECTING_LEFTPAREN_EXISTS = En attente de '(' dans l'expression "exists".
MSG_EXPECTING_RIGHTPAREN_EXISTS = En attente de ')' dans l'expression "exists".
MSG_EXPECTING_LEFTPAREN_EVAL = En attente de '(' pour ouvrir l'expression "eval".
MSG_EXPECTING_RIGHTPAREN_EVAL = En attente de ')' pour fermer l'expression "eval".
MSG_EXPECTING_LEFTPAREN_CATCH = En attente de '(' dans la clause "catch" de la déclaration "try...catch...finally".
MSG_EXPECTING_RIGHTPAREN_CATCH = En attente de ')' dans la clause "catch" de la déclaration "try...catch...finally".
MSG_EXPECTING_IDENTIFIER_CATCH = En attente de l'identificateur pour la clause "catch" de la déclaration "try...catch...finally".
MSG_CATCH_OR_FINALLY_REQUIRED = En attente d'une clause "catch" ou "finally" dans la déclaration "try...catch...finally".
MSG_EXPECTING_LEFTBRACE_STMTBLOCK = En attente de '{' pour ouvrir le bloc de déclaration.
MSG_EXPECTING_RIGHTBRACE_STMTBLOCK = En attente de '}' pour fermer le bloc de déclaration.
MSG_EXPECTING_LEFTPAREN_IF = En attente de '(' pour ouvrir la condition "if".
MSG_EXPECTING_RIGHTPAREN_IF = En attente de ')' pour fermer la condition "if".
MSG_EXPECTING_LEFTPAREN_SWITCH = En attente de '(' pour ouvrir l'expression "switch".
MSG_EXPECTING_RIGHTPAREN_SWITCH = En attente de ')' pour fermer l'expression "switch".
MSG_EXPECTING_LEFTPAREN_WHILE = En attente de '(' pour ouvrir la condition "while".
MSG_EXPECTING_RIGHTPAREN_WHILE = En attente de ')' pour fermer la condition "while".
MSG_EXPECTING_LEFTPAREN_EXCEPT = En attente de '(' pour ouvrir la condition "except".
MSG_EXPECTING_RIGHTPAREN_EXCEPT = En attente de ')' pour fermer la condition "except".
MSG_EXPECTING_WHILE_DO = Attente que l'instruction "while" ferme la déclaration "do...while".
MSG_LOOP_DOESNT_LOOP = La boucle ne fonctionne pas.
MSG_EXPECTING_EQUALS_ASSIGN = En attente de '\=' pour la déclaration d'attribution.
MSG_EXPECTING_EXPRESSSION_ON_RHS = En attente d'une expression rhs valide pour la déclaration d'attribution.
MSG_EXPECTING_STATEMENT = En attente de la déclaration.
MSG_EXPECTING_BEANTYPE = En attente du type complexe pour l'accès membre. Trouvé \: {0}
MSG_EXPECTING_ARRAYTYPE_FOREACH = En attente du type itératif après la clause « in » dans la déclaration « for...in ». Trouvé \: {0}
MSG_EXPECTING_ARRAYTYPE_EXISTS = En attente du type de série après la clause 'in' dans l'expression "exists". Trouvé \:
MSG_EXPECTING_IDENTIFIER_ARG_TYPE = En attente du nom de type après "\:" pour l'argument de fonction.
MSG_EXPECTING_ARRAY_BRACKET = En attente de ']' pour fermer le littéral du type de série.
MSG_EXPECTING_NEW_ARRAY_OR_CTOR = En attente de '[' ou '(' pour initier une nouvelle opération relative à une série ou un objet.
MSG_EXPECTING_OPEN_BRACE_FOR_NEW_ARRAY = En attente de '{{' pour initier une liste d'expressions de valeurs de série.
MSG_EXPECTING_CLOSE_BRACE_FOR_NEW_ARRAY = En attente de '}' pour fermer une liste d'expressions de valeurs de série.
MSG_EXPECTING_CLOSING_ANGLE_BRACKET_FOR_TYPE = En attente de '>' pour fermer le littéral du type paramétré.
MSG_EXPECTING_CLOSING_ANGLE_BRACKET_FOR_TYPE_VAR_LIST = En attente de '>' pour fermer la liste de variables de type.
MSG_COULD_NOT_PARAMETERIZE = Impossible de paramétrer.
MSG_EXPECTING_OPEN_BRACE_FOR_SWITCH = En attente de '{{' pour ouvrir la déclaration "switch".
MSG_EXPECTING_CLOSE_BRACE_FOR_SWITCH = En attente de '}' pour fermer la déclaration "switch".
MSG_EXPECTING_COLON_TERNARY = En attente de '\:' pour une expression ternaire conditionnelle.
MSG_EXPECTING_REFERENCE_TYPE = En attente d'un type référence ; le type primitif n'est pas autorisé ici.
MSG_LOSS_OF_PRECISION_IN_CONDITIONAL_EXP = Les types ne peuvent pas être convertis sans perte de précision. Veuillez les convertir explicitement.
MSG_EXPECTING_CASE_COLON = En attente de '\:' pour fermer l'expression "case".
MSG_DUPLICATE_CASE_EXPRESSION = Expression CASE en double.
MSG_TYPE_MISMATCH_IN_CONDIITIONAL_EXP = Incohérence de type dans l'expression ternaire conditionnelle.
MSG_EXPECTING_IDENTIFIER_VAR = En attente d'un nom de variable.
MSG_EXPECTING_VAR_STMT = En attente de la déclaration "var".
MSG_EXPECTING_TYPELITERAL = En attente d'un littéral de type sur le côté droit de l'expression.
MSG_EXPECTING_TYPELITERAL_OR_NAMESPACE = En attente d'un littéral de type ou d'un espace de nom.
MSG_PRIMITIVES_NOT_ALLOWED_HERE = Types primitifs non autorisés ici.
MSG_INCONVERTIBLE_TYPES = Types non convertibles ; impossible de convertir {0} en {1}
MSG_BAD_NAMESPACE = '{0}' n'est pas un espace de nom valide.
MSG_EXPECTING_ARRAYLENGTH = En attente de la propriété de série 'length'.
MSG_ENTITYBEANS_ARE_IMMUTABLE = La propriété de l'objet ne peut pas être directement modifiée.
MSG_MULTIPLE_DEFAULT_CLAUSES_NOT_PERMITTED = Plusieurs clauses 'default' ont été détectées dans la déclaration "switch".
MSG_CASE_CLAUSE_MAY_NOT_FOLLOW_DEFAULT_CLAUSE = La clause "case" ne peut pas suivre la clause 'default'.
MSG_METHOD_NOT_VISIBLE = La fonction, "{0}", n'est pas visible en raison des contraintes de visibilité de l'analyseur.
MSG_PROPERTY_NOT_VISIBLE = La propriété, "{0}", n'est pas visible en raison des contraintes de visibilité de l'analyseur.
MSG_OBJECT_RETIRED = L'identifiant, "{0}", fait référence à un objet supprimé.
MSG_OBJECT_LITERALS_DEPRECATED = Les valeurs littérales d'entités ont été dépréciées. Utilisez un générateur de requêtes à la place.
MSG_DEPRECATED_MEMBER = {0} dans {1} a été déprécié.
MSG_EXPECTING_ENTITY_TYPE = En attente d'un nom de type d'entité dans l'expression "find".
MSG_EXPECTING_QUERY_PATH = En attente d'une expression de chemin de requête.
MSG_QUERY_PATH_MUST_BEGIN_WITH = L' expression de chemin de requête doit commencer par "{0}"
MSG_EXPECTING_CONDITIONAL_EXPRESSION = En attente d'une expression conditionnelle telle que "a > b"
MSG_CONDITIONAL_EXPRESSION_EXPECTS_BOOLEAN = En attente d'une valeur booléenne.
MSG_EXPECTING_IDENTIFIER_FIND = En attente de l'identificateur pour l'expression "find"
MSG_EXPECTING_IN_FIND = En attente de la clause "in" pour l'expression "find".
MSG_EXPECTING_WHERE_FIND = En attente de la clause "where" pour l'expression "find".
MSG_EXPECTING_LEFTPAREN_FIND = En attente de '(' dans l'expression "find".
MSG_EXPECTING_RIGHTPAREN_FIND = En attente de ')' dans l'expression "find".
MSG_QUERYPATH_MUST_BEGIN_WITH = Le chemin de requête doit commencer par son expression de requête parente "{0}"
MSG_QUERY_IN_LHS_OP_NOT_ENTITY = {0} ne se résout pas en un type d'entité. L'opérateur "in" requiert une propriété de type d'entité sur lhs.
MSG_QUERY_IN_LHS_OP_NOT_ARRAY = {0} n'a pas le type de série approprié. L'opérateur "in" requiert une propriété de type d'entité sur lhs qui ait un type de série valide.
MSG_QUERY_EXPECTED_BOOLEAN_EXPRESSION = {0} n'est pas une expression booléenne.
MSG_EXPECTING_READONLY_ENTITY_TYPE = "find" est restreint aux types d'entité en lecture seule. Définissez l'élément de registre "allow-entity-queries" pour trouver des entités inscriptibles.
MSG_STR_IMMUTABLE = Les chaînes sont immuables, elles ne sont pas modifiables.
MSG_UNTERMINATED_STRING_LITERAL = Littéral de la chaîne non terminé. En attente de ".
MSG_INVALID_CHAR_AT = Caractère d'échappement incorrect à l'emplacement {0}
MSG_FUNCTION_CLASH_PARAMS = « {0} » dans « {1} » est en conflit avec « {2} » dans « {3} » ; les deux fonctions ont la même suppression, pourtant aucune ne remplace l'autre
MSG_UNTERMINATED_COMMENT = Commentaire non terminé. En attente de "*/".
MSG_UNEXPECTED_EOF = Fin de fichier inattendue
MSG_FUNCTION_ALREADY_DEFINED = {0}, est déjà défini dans {1}
MSG_FUNCTION_CLASH = "{0}" dans "{1}" est en conflit avec "{2}" dans "{3}" ; types de retour non compatibles.
MSG_ATTEMPTING_TO_ASSIGN_WEAKER_ACCESS_PRIVILEGES = "{0}" dans "{1}" est en conflit avec "{2}" dans "{3}" ; tentative d'attribuer des privilèges d'accès plus faibles.
MSG_CANNOT_OVERRIDE_FINAL = Impossible de remplacer le membre final "{0}" à partir de "{1}"
MSG_CANNOT_ASSIGN_VALUE_TO_FINAL_VAR = Impossible d'attribuer une valeur à la var finale « {0} »
MSG_VAR_MIGHT_NOT_HAVE_BEEN_INIT = La var « {0} » n'a peut-être pas été initialisée.
MSG_VAR_MIGHT_ALREADY_HAVE_BEEN_INIT = La var « {0} » a peut-être déjà été initialisée.
MSG_VAR_MIGHT_ALREADY_HAVE_BEEN_INIT_LOOP = La var « {0} » a peut-être déjà été initialisée en boucle.
MSG_FUNCTION_ALREADY_DEFINED_IN_EXTENDED_CLASS = {0}, est déjà défini. Les extensions ne peuvent pas remplacer les fonctions.
MSG_DUPLICATE_CLASS_FOUND = Classe en double trouvée à \: {0}.
MSG_DUPLICATE_TYPE_FOUND = Type en double trouvé à \: {0}.
MSG_DUPLICATE_ENHANCEMENT_FOUND = Amélioration en double trouvée à \: {0}.
MSG_EXPECTING_OPEN_BRACE_FOR_CLASS_DEF = En attente de '{{' pour ouvrir la déclaration "class".
MSG_EXPECTING_CLOSE_BRACE_FOR_CLASS_DEF = En attente de '}' pour fermer la déclaration "class".
MSG_EXPECTING_NAME_CLASS_DEF = En attente d'un nom pour la classe.
MSG_EXPECTING_ENHANCEMENT_DEF = En attente d'une amélioration.
MSG_NAMESPACE_CLASS_CONFLICT = Le chemin du répertoire de la classe ne correspond pas au nom du package.
MSG_NO_SUCH_FUNCTION = Aucune fonction définie pour {0}.
MSG_CANNOT_EXTEND_PRIMITIVE_TYPE = Impossible d'étendre un type primitif {0}.
MSG_CANNOT_EXTEND_FINAL_TYPE = Impossible d'étendre un type final {0}.
MSG_ENHANCEMENTS_CANNOT_ENHANCE_OTHER_ENHANCEMENTS = Impossible d'améliorer une amélioration {0}.
MSG_CYCLIC_INHERITANCE = Héritage cyclique impliquant {0}.
MSG_EXPECTING_OPEN_BRACE_FOR_CONSTRUCTOR_DEF = En attente de '{{' pour ouvrir le corps de constructeur.
MSG_EXPECTING_OPEN_BRACE_FOR_FUNCTION_DEF = En attente de '{{' pour ouvrir le corps de fonction.
MSG_EXPECTING_CLOSE_BRACE_FOR_FUNCTION_DEF = En attente de '}' pour fermer le corps de fonction.
MSG_EXPECTING_CLOSE_BRACE_FOR_CONSTRUCTOR_DEF = En attente de '}' pour fermer le corps de constructeur.
MSG_NO_DEFAULT_CTOR_IN = Aucun constructeur par défaut dans {0}.
MSG_WRONG_NAMESPACE = Le nom de package "{0}" ne correspond pas au répertoire "{1}".
MSG_WRONG_CLASSNAME = Le nom de classe "{0}" ne correspond pas au fichier "{1}".
MSG_SAME_NAME_AS_CLASS = « {0} » est déjà défini comme nom de catégorie pour ce fichier
MSG_EXPECTING_PROPERTY_GET_OR_SET_MODIFIER = En attente du modificateur 'get' ou 'set' pour la propriété.
MSG_EXPECTING_NAME_PROPERTY = En attente d'un nom de propriété pour la variable.
MSG_PROPERTY_ALREADY_DEFINED = La propriété "{0}" est déjà définie.
MSG_GETTER_FOR_PROPERTY_ALREADY_DEFINED = La fonction 'get' de la propriété a déjà été définie pour "{0}".
MSG_SETTER_FOR_PROPERTY_ALREADY_DEFINED = La fonction 'set' de la propriété a déjà été définie pour "{0}".
MSG_PROPERTY_NOT_WRITABLE = "{0}" n'est pas inscriptible.
MSG_CLASS_PROPERTY_NOT_READABLE = La propriété, "{0}", de classe, "{1}", n'est pas lisible.
MSG_CLASS_PROPERTY_NOT_WRITABLE = La propriété, "{0}", de classe, "{1}", n'est pas inscriptible.
MSG_NO_VIEWS_FOR_YOUS = Les vues ne sont pas prises en charge. Envisager d'interroger "{0}"
MSG_VARIABLE_ALREADY_DEFINED = {0}, est déjà défini. Veuillez utiliser un nom différent.
MSG_FUNCTION_DECL_MISSING = Erreur interne. Impossible de trouver le symbole de la fonction decl pour, {0}.
MSG_EXPECTING_DEFAULT_VALUE = En attente d'attribution d'une valeur par défaut. Les paramètres requis doivent précéder les paramètres facultatifs.
MSG_DEFAULT_VALUE_NOT_ALLOWED = Valeur par défaut non autorisée ici
MSG_COMPILE_TIME_CONSTANT_REQUIRED = L'expression doit être une constante de temps de compilation ici.
MSG_OVERLOADING_NOT_ALLOWED_WITH_OPTIONAL_PARAMS = Les paramètres facultatifs ne permettent pas la surcharge
MSG_MISSING_REQUIRED_ARGUMENTS = Un ou plusieurs arguments requis sont manquants
MSG_ARGUMENT_ALREADY_DEFINED = L'argument est déjà défini
MSG_EXPECTING_NAME_PARAM = En attente d'un nom pour le paramètre
MSG_EXPECTING_NAMED_ARG = En attente d'un argument nommé
MSG_PARAM_NOT_FOUND = Paramètre introuvable
MSG_VARIABLE_REQUEST_DOES_NOT_ALLOW_VALUE = , les variables de la requête ne peuvent pas avoir une valeur initiale.
MSG_VARIABLE_TYPE_OR_VALUE_REQUIRED = En attente de "as" et/ou "\:" pour la déclaration "var".
MSG_VARIABLE_MUST_HAVE_NON_NULL_TYPE = Le type des variables ne doit pas être nul. Ajoutez un type explicite pour cette variable.
MSG_CONDITION_IS_ALWAYS_TRUE_FALSE = La condition est toujours {0}
MSG_VOID_NOT_ALLOWED = Le type "nul" n'est pas autorisé ici
MSG_FUNCTIONS_NOT_ALLOWED_IN_THIS_CONTEXT = Les déclarations de fonction ne sont pas autorisées dans ce contexte
MSG_CONSTRUCTORS_NOT_ALLOWD_IN_THIS_CONTEXT = Les constructeurs ne sont pas autorisés dans ce contexte.
MSG_INNER_CLASSES_NOT_ALLOWED_IN_THIS_CONTEXT = Les déclarations de classe interne ne sont pas autorisées dans ce contexte
MSG_NO_SOURCE_FOUND = Aucune source n'a été trouvée pour la classe.
MSG_CANNOT_RETURN_VALUE_FROM_VOID = Impossible de renvoyer une valeur depuis une fonction nulle.
MSG_RETURN_NOT_ALLOWED_HERRE = La déclaration return n'est pas autorisée ici.
MSG_MISSING_RETURN_VALUE = Valeur de retour manquante.
MSG_EXPECTING_DECL = En attente de déclaration pour var, fonction ou propriété.
MSG_FUNCTION_ARG_NAME_CONFLICTS_WITH_CLASS_VAR = L'argument "{0}" de la fonction {1} est en conflit avec un champ de la classe.
MSG_EXPECTING_ARROW_AFTER_BLOCK_ARGS = En attente de '->' pour suivre les déclarations d'un argument de bloc.
MSG_EXPECTING_CLOSE_BRACE_FOR_BLOCK = En attente de '}' pour suivre la liste de déclarations de bloc.
MSG_EXPECTING_ARROW_AFTER_MAP_KEY = En attente de '->' pour suivre les déclarations d'un argument de bloc.
MSG_UNEXPECTED_ARROW = '->' inattendu dans l'initialiseur de liste
MSG_EXPECTING_CLOSE_BRACE_FOR_INITIALIZER = En attente de '}' pour suivre la déclaration de l'initialiseur.
MSG_MODIFIER_ABSTRACT_NOT_ALLOWED_HERE = 'abstract' du modificateur non autorisé.
MSG_ABSTRACT_METHOD_CANNOT_BE_ACCESSED_DIRECTLY = Impossible d'accéder directement à la méthode abstraite '{0}'.
MSG_NOT_ALLOWED_IN_INTERFACE = Non autorisé dans l'interface.
MSG_UNIMPLEMENTED_METHOD = Fonction {0} non implémentée \: {1}
MSG_INHERITS_UNRELATED_DEFAULTS = {0} Hérite de valeurs par défaut non liées pour {1} de {2} et {3}
MSG_INHERITS_ABSTRACT_AND_DEFAULT = {0} Hérite des méthodes abstraites et par défaut pour {1} de {2} et {3}
MSG_INTERFACE_CANNOT_EXTEND_CLASS = Une interface ne peut pas étendre une classe, seulement des interfaces.
MSG_CLASS_CANNOT_EXTEND_INTERFACE = Une classe ne peut pas étendre une interface.
MSG_CANNOT_EXTEND_ARRAY = « Une classe ne peut pas étendre une série. »
MSG_CLASS_MUST_HAVE_PACKAGE = Une classe doit comporter un package.
MSG_CLASS_CANNOT_IMPLEMENT_CLASS = Une classe ne peut pas 'implémenter' une classe.
MSG_ENUM_CANNOT_EXTEND_CLASS = Une énumération ne peut pas étendre une classe
MSG_ENUM_CANNOT_HAVE_ANNOTATIONS = Les constantes d'énumération ne peuvent pas comporter d'annotations.
MSG_ENUM_CONSTRUCTOR_MUST_BE_PRIVATE = Le constructeur d'énumération doit être déclaré comme privé
MSG_ENUM_CONSTRUCTOR_NOT_ACCESSIBLE = Le constructeur d'énumération n'est pas accessible ici.
MSG_ENUM_MAY_NOT_HAVE_TYPEPARAM = L'énumération ne peut pas comporter de paramètres de type.
MSG_BAD_CAPTURE_TYPE = Les blocs ne prennent pas en charge les références lexicales à ce type de symbole. Attribuer à une variable locale hors du bloc pour s'y référer.
MSG_POTENTIALLY_BAD_CAPTURE = Cet identificateur capture une variable externe qui ne prend pas intégralement en charge la capture "hors de portée". Une erreur d'exécution risque de se produire si l'évaluation de l'identificateur s'effectue au-delà de la portée de la fonction englobante externe.
MSG_CANNOT_CAPTURE_SYMBOL_IN_BLOCK_IN_ANON_CLASS = Vous ne pouvez pas capturer de symboles dans un bloc imbriqué dans une classe anonyme.
MSG_CANNOT_CAPTURE_SYMBOL_IN_ANON_CLASS_IN_BLOCK = Vous ne pouvez pas capturer de symboles dans une classe anonyme imbriquée dans un bloc.
MSG_EXPECTING_ENHANCE_KEYWORD = Attente de "enhance"
MSG_NON_PRIVATE_MEMBERS_MUST_DECLARE_TYPE = Les membres avec des données non privées doivent déclarer un type explicitement.
MSG_DELEGATES_CANNOT_BE_STATIC = Les délégués ne peuvent pas être statiques.
MSG_DELEGATE_METHOD_CONFLICT = Conflit de membre délégué \: {0} et {1}. Implémentez le membre explicitement pour résoudre le conflit.
MSG_DELEGATES_SHOULD_NOT_SELF_DELEGATE = Les délégués ne peuvent pas se déléguer eux-mêmes.
USING_INTERNAL_CLASS = Ceci est une classe interne qui changera à l'avenir. L'utilisation de cette classe est <b>dangereuse et non prise en charge</b>.
MSG_EXTENSION_CLASS_NOT_FOUND = Impossible de trouver une classe {0} à étendre.
MSG_CANNOT_DEREF_PROPERTIES_IN_WHERE = Impossible de déréférencer une propriété avec la clause "where". Envisager d'utiliser la clause 'exists'.
MSG_CANNOT_CALL_METHOD_WITH_WILDCARD_PARAM = Impossible d'appeler la fonction avec des paramètres génériques.
MSG_NO_WILDCARDS = Les caractères génériques sont dépréciés dans Gosu. Veuillez remplacer le paramètre type par « {0} »
MSG_EXPECTING_COLON_ENHANCEMENT = En attente de '\:' en cours d'amélioration.
MSG_EXPECTING_CLOSE_BRACKET_FOR_LIST_LITERAL = En attente de ']' à la fin d'un littéral de liste.
MSG_CANNOT_PARAMETERIZE_NONGENERIC = Impossible de paramétrer un type non générique.
MSG_TYPE_PARAM_NOT_ASSIGNABLE_TO = Le paramètre de type {0} n'est pas attribuable au type limitant {1}.
MSG_TYPE_NOT_ANNOTATION = Le type {0} n'est pas une annotation. Il doit être une annotation Java ou implémenter l'interface gw.lang.IAnnotation
MSG_MISPLACED_META_ANNOTATION = Cette annotation ne peut être utilisée que sur une classe d'annotations.
MSG_MISPLACED_ANNOTATION = Cette annotation ne peut pas être utilisée sur une classe d'annotations.
MSG_ANNOTATION_WHEN_NONE_ALLOWED = L'annotation "{0}" n'est pas autorisée à apparaître dans une déclaration {1}.
MSG_ANNOTATION_USE_SITE_TARGET_NOT_ALLOWED_HERE = L'annotation "{0}" a une cible use-site non valide "{1}" pour le contexte.
MSG_TOO_MANY_ANNOTATIONS = L'annotation "{0}" ne peut apparaître qu'une seule fois dans une déclaration {1}.
MSG_EXPECTING_COLON_ANNOTATION = En attente de '\:' pour séparer la cible use-site et le type d'annotation.
MSG_INVALID_TYPE = {0} n'est pas un type valide.
MSG_INVALID_GENERIC_EXCEPTION = La classe générique ne peut pas développer 'java.lang.Throwable'
MSG_INVALID_INNER_TYPE = Aucune classe intérieure « {0} » trouvée sur « {1} ».
MSG_INVALID_TYPE_WITH_QUALIFIED_NAME = "{0}" comporte un type non valide \: "{1}".
MSG_NOT_A_STATEMENT = Ce n'est pas une déclaration.
MSG_CANNOT_CONSTRUCT_ABSTRACT_CLASS = "{0}" est abstrait et ne peut pas être construit.
MSG_CANNOT_CONSTRUCT_RECURSIVE_CLASS = "{0}" est récursif et ne peut pas être construit directement.
MSG_RECURSIVE_CONSTRUCTOR = Invocation de constructeur récursif.
MSG_MISSING_RETURN = Déclaration de retour manquante.
MSG_UNREACHABLE_STMT = Impossible d'atteindre la déclaration.
MSG_BREAK_OUTSIDE_SWITCH_OR_LOOP = Déclaration de rupture non autorisée ici.
MSG_CONTINUE_OUTSIDE_LOOP = Déclaration Continue non autorisée ici.
MSG_PROPERTY_SET_MUST_HAVE_ONE_PARAMETER = La méthode de définition de propriétés doit avoir exactement un paramètre.
MSG_PROPERTY_SET_MUST_RETURN_VOID = La méthode de définition de propriétés doit retourner une valeur nulle.
MSG_MISSING_PROPERTY_RETURN = Type de retour de propriété manquant.
MSG_IMPLICIT_COERCION_WARNING = Une contrainte implicite du type {0} à {1} se produit ici. Envisager de la rendre explicite avec un "as {1}".
MSG_IMPLICIT_COERCION_ERROR = Vous devez définir une contrainte explicite de {0} à {1} à l'aide du mot clé 'as'.
MSG_ASYMMETRICAL_COMPARISON = Comparaison asymétrique entre {0} et {1}. Envisagez la conversion de l'un des opérandes.
MSG_SILLY_ASSIGNMENT = Une auto-attribution inutile de {0} se produit ici.  Il peut s'agir d'une erreur d'inadvertance ou d'une erreur du programme.
MSG_UNUSED_VARIABLE = Ce {0} n'est pas utilisé.
MSG_LIKELY_JAVA_CAST = Il semble y avoir une tentative de conversion de type Java, ce qui ne correspond pas à un Gosu correct.  Pour convertir une expression en un type différent, mettez "as {0}" après l'expression
MSG_UNEXPECTED_TOKEN = Jeton inattendu \: {0}
MSG_EXPECTING_INT_ACCESS_TO_ARR_ETC = En attente d'un accès int au type Série, Collection ou Chaîne avec l'opérateur [] de série.
MSG_EXPECTING_BEAN_TYPE_WITH_REFLECTION_OPERATOR = En attente du type de composant logiciel avec l'opérateur de réflexion [].
MSG_PROPERTY_REFLECTION_ONLY_WITH_STRINGS = La réflexion de la propriété du composant logiciel peut uniquement être réalisée avec des Chaînes.
MSG_EXPECTING_BRACKET_TO_CLOSE_DYNAMIC_MEMBER_ACCESS = En attente que l'opérateur ']' ferme l'expression d'accès membre dynamique.
MSG_WRONG_NUMBER_OF_ARGS_TO_FUNCTION = Nombre d'arguments inapproprié pour la fonction {0}. {1} prévu, a obtenu {2}.
MSG_WRONG_NUMBER_OF_ARGS_TO_CONSTRUCTOR = Nombre d'arguments inapproprié pour le constructeur {0}. {1} prévu, a obtenu {2}.
MSG_SHOULD_HAVE_FOUND_METHOD_AT_LINE = Aurait dû trouver une fonction à la ligne {0}, colonne {1}
MSG_VOID_EXPRESSION_NOT_ALLOWED = Les expressions situées à cet emplacement ne doivent pas être nulles.
MSG_EXPECTING_RETURN_TYPE_OR_FUN_BODY = En attente du type de retour ou du corps de fonction.
MSG_INVALID_TYPE_FOR_ANNOTATION_MEMBER = Type non valide pour le membre d'annotation
MSG_ERRANT_TYPE_VAR = Var de type changeant
MSG_USING_VOID_RETURN_TYPE_FROM_NON_NULL_EXPR = Utilisation du type de retour nul à partir d'une expression non nulle.
MSG_FIELD_TYPE_HAS_NOT_BEEN_INFERRED = Le type de ce champ n'a pas encore été inféré et ne peut donc pas être utilisé.  Cette expression doit apparaître après la déclaration de champ.
MSG_BEAN_CLASS_IS_NULL = La classe du composant logiciel est nulle \!
MSG_BEAN_MEMBER_PATH_IS_NULL = Le chemin d'accès membre au composant logiciel est nul \!
MSG_BEAN_MEMBER_PATH_IS_EMPTY = Le chemin d'accès membre au composant logiciel est vide \!
MSG_NO_EXPLICIT_TYPE_INFO_FOUND = Aucune information de type explicite n'a été trouvée pour, {0}
MSG_NO_CONSTRUCTOR_FOUND_FOR_CLASS = Aucun constructeur n'a été trouvé pour la classe, {0}
MSG_WRONG_NUMBER_OF_ARGS_FOR_METHOD_ON_CLASS = Nombre d'arguments inapproprié pour la fonction, {0}, dans la classe {1}
MSG_NO_METHOD_DESCRIPTOR_FOUND_FOR_METHOD = Aucun descripteur de fonction n'a été trouvé pour la fonction, {0}, dans la classe, {1}
MSG_METHOD_IS_NOT_STATIC = La fonction "{0}" n'est pas statique dans la classe {1}
MSG_METHOD_IS_STATIC = La fonction "{0}" est statique dans la classe {1}
MSG_NO_PROPERTY_DESCRIPTOR_FOUND = Aucun descripteur de propriété {0} n'a été trouvé pour la propriété, {1}, dans la classe, {2}
MSG_NO_TYPE_ON_NAMESPACE = Aucun type {0} n'a été trouvé dans le package {1}
MSG_ANY = {0}
MSG_EXPECTING_MEMBER_ACCESS_PATH = En attente du chemin d'accès membre.
MSG_CANNOT_CREATE_NEW_ARRAY_FROM_TYPE_VAR = Impossible de créer une nouvelle série d'instances à partir d'une variable de type.  Il est uniquement possible d'accéder au type et d'y écrire.
MSG_NOT_A_VALID_EXCEPTION_TYPE = {0} n'étend pas Throwable et ne peut pas être saisi.
MSG_CANNOT_INFER_ARGUMENT_TYPE_AT_THIS_POSTION = L'argument {0} doit fournir une déclaration de type, car il ne peut pas être inféré.
MSG_OBSOLETE_CTOR_SYNTAX = Cette syntaxe de constructeur est obsolète. Utilisez le mot-clé 'construct' à la place.
MSG_OBSOLETE_NOT_EQUAL_OP = L'opérateur <> est obsolète et doit être remplacé par \!\=
MSG_MUST_BE_IN_OUTER_TO_CONSTRUCT_INNER = Doit appartenir ou être dérivé de la classe {0} pour construire une classe interne non statique {1}.
MSG_TYPE_DOES_NOT_HAVE_EMPTY_CONSTRUCTOR = Le type {0} ne possède pas un constructeur par défaut et ne peut pas être implicitement créé ici.
MSG_ENHANCEMENT_DOES_NOT_ACCEPT_THIS_STATEMENT = Les améliorations ne peuvent pas avoir de déclarations de ce type.
MSG_CANNOT_OVERRIDE_FUNCTIONS_IN_ENHANCEMENTS = La fonction "{0}" est déjà définie dans le type {1}.  Les améliorations ne peuvent pas remplacer les fonctions.
MSG_CANNOT_OVERRIDE_PROPERTIES_IN_ENHANCEMENTS = La propriété "{0}" est déjà définie dans le type {1}.  Les améliorations ne peuvent pas remplacer les propriétés.
MSG_ENHANCED_TYPE_MUST_USE_ENHANCEMENT_TYPEVARS = Le type amélioré doit utiliser tous les types de variables déclarés par l'amélioration.
MSG_ABSTRACT_MEMBER_NOT_IN_ABSTRACT_CLASS = Membre abstrait qui n'appartient pas à la classe abstraite.
MSG_ILLEGAL_USE_OF_MODIFIER = Utilisation illégale du modificateur, "{0}" ne peut pas être utilisé avec "{1}" ici
MSG_ILLEGAL_FORWARD_REFERENCE = Référence anticipée incorrecte
MSG_MISSING_OVERRIDE_MODIFIER = Modificateur 'override' manquant. La fonction {0} remplace et/ou implémente la fonction à partir de {1}.
MSG_RENAME_METHOD = Renommer la fonction. La fonction {0} entre en conflit avec la fonction de {1}, elle renvoie des types incompatibles. Les fonctions privées sont compilées avec un accès "interne", c'est pourquoi elles créent des conflits en cas d'exécution dans un même package.
MSG_STATIC_METHOD_CANNOT_OVERRIDE = La fonction statique {0} ne peut pas remplacer/implémenter la fonction dans {1}.
MSG_OVERRIDES_OBJECT_METHOD = La méthode par défaut {0} remplace la méthode Objet
MSG_INHEREITED_WITH_DIFF_ARG_TYPES = « {0} » ne peut pas être hérité avec des arguments de types différents \: {1}
MSG_NO_IMPLEMENTS_ALLOWED = Aucune clause d'implémentation autorisée pour l'interface.
MSG_NO_EXTENDS_ALLOWED = Aucune clause d'extension autorisée pour l'annotation.
MSG_FUNCTION_NOT_OVERRIDE = La fonction {0} ne remplace rien
MSG_FUNCTION_NOT_OVERRIDE_PROPERTY = La fonction {0} ne remplace rien. Vous voulez peut-être remplacer une propriété '{1}' ?
MSG_PROPERTY_OVERRIDES_WITH_INCOMPATIBLE_TYPE = Remplacements de propriété avec un type incompatible
MSG_SUBCLASS_OBJECT = {0} sous-classe explicitement Object
MSG_AMBIGUOUS_SYMBOL_REFERENCE = Cette référence est ambiguë. Veuillez qualifier pleinement le symbole.
MSG_LIST_TO_ARRAYLIST_WARNING = Une contrainte implicite s'applique à ArrayList. Veuillez utiliser ArrayList explicitement.
MSG_VAR_CASE_MISMATCH = La var "{0}" n'est pas référencée par le 'case' approprié.  Veuillez changer cette référence en "{1}".
MSG_FUNCTION_CASE_MISMATCH = La fonction "{0}" n'est pas référencée par le 'case' approprié.  Veuillez changer cette référence en "{1}".
MSG_PROPERTY_CASE_MISMATCH = La propriété "{0}" n'est pas référencée par le 'case' approprié.  Veuillez changer cette référence en "{1}".
MSG_TYPE_CASE_MISMATCH = Le type "{0}" n'est pas référencé par le 'case' approprié.  Veuillez changer cette référence en "{1}".
MSG_NON_STATIC_ACCESS_OF_STATIC_MEMBER = La propriété "{0}" est statique, mais n'est pas référencée de manière statique sur le type {1}.
MSG_NON_STATIC_ACCESS_WITH_IDENTIFIER_OF_STATIC_MEMBER = La propriété "{0}" est statique, mais n'est pas référencée directement sur le type {1}.  \nIl y a une variable ou propriété "{2}" qui entraîne un conflit.  Veuillez qualifier l'expression en tant que {3}.{0}.
MSG_STATEMENT_ON_SAME_LINE = Plusieurs déclarations occupent la même ligne ; cela peut indiquer une erreur logique non intentionnelle.\nEnvisager de déplacer la déclaration dans une nouvelle ligne.
MSG_MUST_BE_DEFINED_AS_CLASS = Doit être défini comme "class".
MSG_VOID_RETURN_IN_CTX_EXPECTING_VALUE = Cette fonction attend que le bloc renvoie une valeur.
MSG_NO_STATIC_CONSTRUCTOR = Les constructeurs ne peuvent pas être statiques.
MSG_NO_ABSTRACT_METHOD_CALL_IN_CONSTR = La fonction {0} est abstraite et ne peut pas être appelée par le constructeur.
MSG_CALLING_OVERRIDABLE_FROM_CTOR = Appel de la fonction remplaçable du constructeur. {0}
MSG_AMBIGUOUS_METHOD_INVOCATION = Cet appel de fonction est ambigu.
MSG_RETURN_VAL_FROM_VOID_FUNCTION = Vous essayez de renvoyer une valeur d'une fonction nulle.
MSG_BAD_ANONYMOUS_CLASS_DECLARATION = Seuls les types java et gosu peuvent être étendus de manière anonyme.
MSG_SINGLE_ANON_CTOR = Une classe anonyme peut définir un constructeur maximum
MSG_ANON_CTOR_PARAMS_CONFLICT_WITH_CALL_SITE = Les types paramètre de constructeur anonyme sont en conflit avec les types argument sur le site d'appel
MSG_ASSIGNMENT_IN_IF_STATEMENT = Les attributions ne sont pas légales dans les conditions "if"
MSG_ASSIGNMENT_IN_LOOP_STATEMENT = Les attributions ne sont pas légales dans les conditions de boucle
MSG_JAVA_STYLE_VARIABLE_DECLARATION = Ceci est une déclaration de variable de type java.  Veuillez utiliser le mot-clé 'var' à la place.
MSG_NUMERIC_TYPE_EXPECTED = Expression numérique prévue.
MSG_GETTER_CANNOT_HAVE_PARAMETERS = Une définition 'get' de propriété ne peut pas comporter de paramètres.
MSG_BAD_TEMPLATE_DIRECTIVE = Instruction de modèle non valide.  Les instructions valides sont "extends" et "params".
MSG_CLASSPATH_STATEMENT_EXPECTS_A_STRING = la déclaration classpath requiert une chaîne pour le chemin
MSG_COMMA_IS_THE_CLASSPATH_SEPARATOR = la déclaration classpath utilise des virgules comme séparateur de chemin indépendant de la plate-forme.
MSG_BITSHIFT_LHS_MUST_BE_INT_OR_LONG = L'opérande de gauche doit être un entier (int) ou un entier long (long).
MSG_BITWISE_OPERAND_MUST_BE_INT_OR_LONG = L'opérande logique de manipulation de bits doit être un entier (int) ou un entier long (long).
MSG_EXPECTING_LEFTPAREN_USING = En attente de '(' pour ouvrir le prédicat "using".
MSG_EXPECTING_RIGHTPAREN_USING = En attente de ')' pour fermer le prédicat "using".
MSG_BAD_TYPE_FOR_USING_STMT = Le prédicat de la déclaration d'utilisation doit être Closeable, IDisposable ou Lock. Convertir en IMonitorLock pour la synchronisation de type Java.
MSG_UNNECESSARY_COERCION = Cette expression est déjà du type {0}, il est donc inutile de la convertir vers {1}.
MSG_LATER_ASSIGNMENT_MAKES_EXPRESSION_ILLEGAL = Une attribution ultérieure à {0} annule l'inférence de type qui rend possible son utilisation.
WSDL_DUPLICATE_WEB_SERVICE = Nom de service Web en double. Uniquement un service Web avec le nom donné peut être défini.
MSG_NUMBER_LITERAL_TOO_LARGE = Le littéral du chiffre est trop long.
WSDL_DUPLICATE_METHOD = Fonctions de service Web en double. Les fonctions surchargées doivent avoir un nombre de paramètres différent, même si les types de paramètres sont différents.\n{0} est en conflit avec {1}.
WSDL_NOT_WEBSERVICE = Cette annotation est disponible uniquement sur service Web
WSDL_UNSUPPORTED_TYPE = Le service Web ne peut pas référencer le type suivant non pris en charge \: {0} {1}
WSDL_REFERENCE_ABSTRACT_CLASS = Le service Web ne peut pas référencer une classe abstraite \: {0} {1}
WSDL_REFERENCE_INTERFACE = Le service Web ne peut pas référencer une interface \: {0} {1}
WSDL_REFERENCE_ANNOTATION = Le service Web ne peut pas référencer une annotation \: {0} {1}
WSDL_REFERENCE_TRANSACTION_TYPE = Le service Web ne peut pas référencer un type dans l'espace de nom gw.transaction.* \: {0} {1}
WSDL_REFERENCE_LIST = Le service Web ne peut pas référencer les types de liste \: {0}.  A la place, essayez une série fortement typée (ex. Chaîne[]). {1}
WSDL_REFERENCE_MAP = Le service Web ne peut pas référencer les types de mappage \: {0} {1}
WSDL_REFERENCE_COLLECTION = Le service Web ne peut pas référencer les types de collection \: {0}.  À la place, essayez une série fortement typée (ex. Chaîne[]). {1}
WSDL_REFERENCE_PARAMETERIZED_TYPE = Le service Web ne peut pas référencer des types paramétrés \: {0}
WSDL_REFERENCE_GENERIC_TYPE = Le service Web ne peut pas référencer des types généralisés \: {0} {1}
WSDL_REFERENCE_UNSUPPORTED_NAMESPACE = Le service Web ne peut pas référencer le type suivant. Il fait partie d'un espace de nom non pris en charge ; seuls les types d'es pace de nom 'gw.*' (sauf gw.transaction.*) sont autorisés \: {0} {1}
WSDL_REFERENCE_CLASS_WITHOUT_DEFAULT_CONSTRUCTOR = La classe {0} n'a pas de constructeur par défaut et ne peut pas être référencée par un service Web. {1}   //Cela doit être un avertissement.
WSDL_REFERENCE_WEBSERVICE = Le service Web ne peut pas référencer d'autres types de services web \: {0} {1}
WSDL_REFERENCE_SOAP_TYPE = Les services Web ne peuvent pas référencer des types dans l'espace de nom soap.* \: {0} {1}
WSDL_REFERENCE_XML_TYPE = Les services Web RPC ne peuvent pas référencer des types XML \: {0} {1}
WSDL_READONLY_PROPERTIES = Les services Web ne devraient pas référencer des types ayant des propriétés en lecture seule.  \nCes types ne peuvent pas être définis comme paramètre pour une opération de service Web. {0} {1}
WSDL_WRITEONLY_PROPERTIES = Les services Web ne devraient pas référencer des types ayant des propriétés en écriture seule.  \nCes types ne peuvent pas être définis comme type de retour pour une opération de service Web. {0} {1}
WSDL_REFERENCE_CAUSES_NAMESPACE_COLLISION = Ce type entraîne une collision d'espaces de nom de services web.\nCes deux types ont le même nom relatif et seraient exposés aux services Web dans le même soap d'espace de nom.*.{0}.\nRenommer l'un des types suivants ou s'assurer qu'il n'est pas référencé dans un service web \: {1} et {2}.  {3}
MSG_DELEGATION_NOT_ALLOWED_HERE = La délégation n'est pas autorisée ici
MSG_DELEGATE_MUST_NOT_BE_STATIC = La délégation statique n'est pas prise en charge
MSG_DELEGATES_REPRESENT_INTERFACES_ONLY = Un délégué peut uniquement représenter des types d'interface
MSG_ONLY_INTERFACES_ALLOWED_HERE = Seules les interfaces sont autorisées ici
MSG_ONLY_ONE_CLASS_IN_COMPONENT_TYPE = Seule une non-interface est autorisée dans un type de composant
MSG_ONLY_ONE_TYPE_VARIABLE = Une variable de type ne peut pas être suivie par d'autres liaisons
MSG_NO_ARRAY_IN_COMPONENT_TYPE = Les séries ne sont pas autorisées dans un type composant
MSG_NO_PRIMITIVE_IN_COMPONENT_TYPE = Les primitifs ne sont pas autorisés dans un type composant
MSG_COMPOUND_TYPE_NOT_ALLOWED_HERE = Le type composé n'est pas autorisé ici
MSG_PARAMETERIZED_TYPE_NOT_ALLOWED_HERE = Le type paramétré n'est pas autorisé ici
MSG_DYNAMIC_TYPE_NOT_ALLOWED_HERE = Le type dynamique n'est pas autorisé ici
MSG_CANNOT_EXTEND_INTERNAL_JAVATYPE = Le type Java {0} dispose d'un accès protégé par package et ne peut pas être étendu ni amélioré dans Gosu.
MSG_CLASS_DOES_NOT_IMPL = Interface de délégué non implémentée par le type déclarant \: {0}
MSG_EXPECTING_REPRESENTS = En attente de la clause 'represents' pour le délégué.
MSG_EXPECTING_LEFTPAREN_AGGREGATE = En attente de '(' pour ouvrir le type d'agrégat
MSG_EXPECTING_RIGHTPAREN_AGGREGATE = En attente de ')' pour fermer le type d'agrégat
MSG_MEMBER_ACCESS_REQUIRED_FOR_SUPER = Accès membre requis pour 'super'
MSG_ALREADY_CONTAINS_TYPE = Type {0} déjà spécifié
MSG_OVERRIDING_FUNCTION_MUST_HAVE_SAME_NUMBER_OF_TYPE_VARS = Pour remplacer correctement sa fonction parente, cette fonction doit posséder {0} variables de type
MSG_AGGREGATES_MUST_CONTAIN_MORE = Un type d'agrégat doit comporter plusieurs types
MSG_INTERFACE_REDUNDANT = L'interface {0} redondante, {1} étend {0}
MSG_NONTERMINAL_CASE_CLAUSE = La clause case antérieure est non terminale ; il est possible que la déclaration break, continue ou return soit manquante.
MSG_ANONYMOUS_CLASS_NOT_ALLOWED_HERE = Classe anonyme non autorisée ici
MSG_PARAMETERIZED_ARRAY_COMPONENT = Le type de composant de série paramétré perd le ou les paramètres de type à l'exécution.
MSG_TEMPLATE_EXCEPTION_GENERATED_SOURCE = Source générée
MSG_TEMPLATE_MISSING_END_TAG_SCRIPTLET = Fin de balise '%>' manquante pour le scriptlet.
MSG_TEMPLATE_MISSING_END_TAG_EXPRESSION = Fin de balise '%>' manquante pour l'expression.
MSG_TEMPLATE_MISSING_END_TAG_EXPRESSION_ALT = Fin de balise '}' manquante pour l'expression.
MSG_TEMPLATE_MULTIPLE_PARAMS = Plusieurs instructions "params" ont été trouvées.
MSG_TEMPLATE_INVALID_PARAMS = Paramètres non valides \: {0}
MSG_TEMPLATE_UNKNOWN_DIRECTIVE = Instruction inconnue {0}.  Les instructions valides sont "params" et "extends".
MSG_EQUALS_FOR_INITIALIZER_EXPR = En attente d'un '\=' dans cet initialiseur d'objets.
MSG_INITIALIZER_NOT_ALLOWED_ABSTRACT_PROPERTY = L'initialisateur n'est pas autorisé sur la propriété abstraite.
MSG_EXPECTING_NAME_VALUE_PAIR = En attente d'un nom de propriété suivi d'un '\=' et d'une valeur d'expression
MSG_REDUNTANT_INITIALIZERS = La propriété {0} a déjà une valeur d'initialiseur.
MSG_ONLY_ONE_COLON_IN_INITIALIZERS = Les noms de propriété dans les initialiseurs ne peuvent être précédés que du signe deux-points.
MSG_EXPECTING_PROPERTY_NAME = En attente d'un nom de propriété.
MSG_BLOCK_TYPES_SHOULD_HAVE_ARG_NAMES = Les paramètres de type de bloc doivent spécifier des noms et avoir la forme 'argName\:Type'.
MSG_DIMENSION_MULTIPLICATION_UNDEFINED = Multiplication non définie entre les dimensions
MSG_DIMENSION_ADDITION_MUST_BE_SAME_TYPE = Les opérandes doivent être des dimensions du même type final
MSG_DIMENSION_DIVIDE_SCALAR_BY_DIMENSION = Impossible de diviser le scalaire en dimensions
MSG_DIMENSION_MUST_BE_FINAL = L'arithmétique de la dimension doit impliquer des types finaux. {0} n'est pas final.
MSG_DIMENSION_NONSTANDARD_NUMBER_NO_OVERRIDE = Méthode[s] arithmétiques manquantes sur Dimension, {0}, avec type Number non standard, {1}
MSG_RELATIONAL_OPERATOR_CANNOT_BE_APPLIED_TO_TYPE = L'opérateur relationnel '{0}' ne peut pas être appliqué au type {1}
MSG_ARITHMETIC_OPERATOR_CANNOT_BE_APPLIED_TO_TYPES = L'opérateur « {0} » ne peut pas être appliqué à « {1} », « {2} »
MSG_ASSIGNMENTS_MUST_BE_ENCLOSED_IN_CURLIES_IN_BLOCKS = Les attributions d'un corps de bloc doivent être entourées d'accolades
MSG_BLOCKS_CAN_HAVE_A_MOST_SIXTEEN_ARGS = Les blocs peuvent posséder au maximum 16 arguments.
MSG_BLOCKS_LITERAL_NOT_ALLOWED_IN_NEW_EXPR = Les valeurs littérales de blocs ne sont pas autorisées dans les expressions nouvelles.
MSG_STATEMENTS_MUST_BE_ENCLOSED_IN_CURLIES_IN_BLOCKS = Les déclarations "{0}" d'un corps de bloc doivent être entourés d'accolades
MSG_NOT_AN_ENHANCEABLE_TYPE = {0} ne prend pas en charge les améliorations.
MSG_CANNOT_REFERENCE_CLASS_TYPE_VAR_IN_STATIC_CONTEXT = Vous ne pouvez pas référencer des variables de type de classe dans un contexte statique.
MSG_CANNOT_REFERENCE_THIS_IN_STATIC_CONTEXT = Vous ne pouvez pas référencer 'this' dans un contexte statique.
MSG_CANNOT_CALL_NON_STATIC_METHOD_FROM_STATIC_CONTEXT = Vous ne pouvez pas référencer des méthodes non statiques dans un contexte statique.
MSG_CANNOT_REFERENCE_NON_STATIC_PROPERTY_FROM_STATIC_CONTEXT = Vous ne pouvez pas référencer des propriétés non statiques dans un contexte statique.
MSG_CANNOT_REFERENCE_NON_STATIC_FEATURE_HERE = Vous ne pouvez pas référencer une fonction non statique ici
MSG_ONLY_GOSU_JAVA_TYPES = Seuls les types Java et Gosu sont autorisés ici
MSG_CANNOT_READ_A_WRITE_ONLY_PROPERTY = Les propriétés en écriture seule peuvent uniquement être écrites.
MSG_TYPE_IS_NOT_ITERABLE = En attente d'un type itératif pour l'opérateur d'expansion - {0}
MSG_INTERVAL_MUST_BE_ITERABLE_HERE = Le type d'intervalle doit être itératif ici
MSG_EXTRA_DOT_FOUND_IN_INTERVAL = L'opérateur d'intervalle comporte deux points. Trois points trouvés.
MSG_EXPECTING_NUMBER_TO_FOLLOW_DECIMAL = En attente d'un nombre décimal
MSG_IMPROPER_VALUE_FOR_NUMERIC_TYPE = La valeur {0} n'appartient pas au domaine des nombres de type {1}
MSG_PRIMITIVE_TYPE_PARAM = Le type primitif {0} n'est pas autorisé ici. Le type {0} est implicitement transformé en {1} comme paramètre de type ; veuillez utiliser {1} directement.
MSG_CTOR_HAS_XXX_ACCESS = Le constructeur a un accès {0}
MSG_TYPE_HAS_XXX_ACCESS = Le type '{0}' a un accès {1}
MSG_QUERY_SPECIFY_COLUMN = Spécifiez une colonne de requête
MSG_QUERY_SPECIFY_QUERY_COLUMN = {0} doit spécifier une colonne dans la base de données qui soit interrogeable
MSG_CANNOT_EXTEND_RAW_GENERIC_TYPE = Le type générique '{0}' requiert le ou les arguments de type
MSG_TYPE_VAR_VARIANCE_ERROR = La variable du type {0} est déclarée « {1} » mais est utilisée dans une position « {2} » de type {3}
MSG_SUPER_CLASS_METHOD_NAME_SAME_AS_SUBCLASS = La méthode de superclasse '{0}' est en conflit avec le nom de constructeur interne de cette classe. Veuillez modifier le nom de la méthode de superclasse ou ce nom de classe.
MSG_NOT_A_SUPERTYPE = {0] n'est pas un super type direct
MSG_CALL_TO_SUPER_THIS_MUST_BE_FIRST = L'appel à '{0}()' doit être la première déclaration dans le constructeur
MSG_EXPECTING_OPERATOR_TO_FOLLOW_NEW_EXPRESSION = Déclaration incomplète. En attente que l'opérateur suive la nouvelle expression.
MSG_EXPECTING_TYPE_TO_FOLLOW_PACKAGE_NAME = En attente que le type suive le nom du package
MSG_QUERY_FUNCTION_EXPRESSION_RESTRICTION = Seules les références aux colonnes de la base de données ou aux appels de méthode DBFunction sont autorisées
MSG_QUERY_ORDER_BY_EXPRESSION = Seules les expressions d'accès membre contenant des colonnes de base de données sont autorisées.
MSG_QUERY_ARRAYS_NOT_ALLOWED = L'accès à une série n'est pas autorisé ici.
MSG_APPLICATION_MODIFIER_HAS_BEEN_DEPRECATED = Le modificateur "application" a été déprécié. Utilisez plutôt la structure gw.api.web.Scopes.Application.
MSG_SESSION_MODIFIER_HAS_BEEN_DEPRECATED = Le modificateur « session » a été déprécié. Utilisez plutôt gw.api.web.SessionVar.
MSG_REQUEST_MODIFIER_HAS_BEEN_DEPRECATED = Le modificateur « request » a été déprécié. Utilisez plutôt gw.api.web.RequestVar.
MSG_EXECUTION_MODIFIER_HAS_BEEN_DEPRECATED = Le modificateur "execution" a été déprécié et est inutile. Vous pouvez tout simplement le supprimer.
MSG_CANNOT_REFERENCE_OUTER_SYMBOL_WITHIN_ENHANCEMENTS = Le mot-clé externe ne peut pas être référencé dans les améliorations. Envisager de déplacer cette classe anonyme vers une classe nommée.
MSG_CANNOT_REFERENCE_ENCLOSING_PROPERTIES_WITHIN_ENHANCEMENTS = Les méthodes du type englobant ne peuvent pas être référencées dans les améliorations. Envisager de déplacer cette classe anonyme vers une classe nommée.
MSG_CANNOT_REFERENCE_ENCLOSING_METHODS_WITHIN_ENHANCEMENTS = Les méthodes du type englobant ne peuvent pas être référencées dans les améliorations. Envisager de déplacer cette classe anonyme vers une classe nommée.
MSG_INVALID_LITERAL = Ce littéral ne peut pas être converti vers un {0}.  Vous devez construire explicitement la valeur.
MSG_PROPERTIES_MUST_AGREE_ON_STATIC_MODIFIERS = Les accesseurs Get et Set de propriétés doivent tous les deux être statiques ou non statiques
MSG_PROPERTIES_MUST_AGREE_ON_TYPE = Les accesseurs Get et Set de propriétés doivent porter sur le même type de propriété
MSG_NO_ENCLOSING_INSTANCE_IN_SCOPE = Aucune instance englobante de type '{0}' dans la portée
MSG_EXPECTING_CONDITION_FOR_ASSERT = En attente d'une condition pour l'« assertion »
MSG_EXPECTING_MESSAGE_FOR_ASSERT = En attente d'un message pour l'« assertion »
MSG_ASSERTIONS_NOT_ALLOWED_HERE = Déclaration d'assertion non autorisée ici.
MSG_ARRAY_NOT_SUPPORTED = Type de série non pris en charge pour {0}
MSG_IMPROPER_USE_OF_KEYWORD = Incohérence d'utilisation de mot-clé, {0}
MSG_USES_STMT_CONFLICT = Type déjà en cours d'utilisation, {0}
MSG_USES_STMT_DUPLICATE = Le doublon utilise une déclaration
MSG_ARRAY_INDEX_MUST_BE_INT = Les séries doivent être indexées à l'aide d'une valeur "int"
MSG_PARAM_TYPE_CANT_BE_INFERRED_FROM_LATE_BOUND_EXPRESSION = Le type de paramètre ne peut pas être inféré à partir d'un type d'expression lié tardif.
MSG_LOSS_OF_PRECISION_IN_NUMERIC_LITERAL = Ce littéral de valeur double est moins précis dans le cadre de cette opération. Vous devez le déclarer explicitement en tant que BigDecimal \: {0}
MSG_COMPILE_TIME_ANNOTATION_FAILED_TO_EXECUTE = L'exécution d'une annotation de compilation a échoué. Le message était {0}. Accédez à la console pour consulter la trace de pile.
MSG_METHOD_REIFIES_TO_SAME_SIGNATURE_AS_ANOTHER_METHOD = Une méthode portant le même nom est réifiée par la même signature au niveau du code d'octet. Renommez l'une de ces méthodes.
MSG_TYPE_NOT_REIFIED = {0} doit être déclaré avec le modificateur "concrétisé" pour accéder à la variable de type "{1}" lors de l'exécution.
MSG_REIFIED_DONT_MATCH = Doit remplacer la fonction avec la même configuration "concrétisée"
MSG_REIFIED_DONT_MATCH_JAVA = La méthode réifiée générique {0} remplace une méthode Java dans {1}. L'invocation de {0} à partir de {1} efface les paramètres de type.
NOTHING_TO_REIFY = Rien à concrétiser
MSG_PROPERTY_AND_FUNCTION_CONFLICT = La méthode {0} crée un conflit avec les méthodes implicites générées par la propriété {1}
MSG_PROPERTY_AND_FUNCTION_CONFLICT_UPON_REIFICATION = La méthode {0} crée un conflit avec les méthodes implicites générées par la propriété {1} lors de la réification
MSG_CANNOT_OVERRIDE_FUNCTION_FROM_ENHANCEMENT = Une méthode définie sur une amélioration ne peut pas être remplacée.
MSG_MASKING_ENHANCEMENT_METHODS_MAY_BE_CONFUSING = Cette méthode masque une méthode définie sur une amélioration de ce type. Elle risque de générer une sémantique ambiguë, en raison de la distribution statique des méthodes d'amélioration.
MSG_STRING_COERCION_ON_RHS_OF_ADDITIVE_EXPRESSION_MUST_BE_PARENTHESIZED = La conversion vers une chaîne au sein d'une expression additive peut s'avérer ambiguë. Placez l'expression entre parenthèses pour l'évaluer convenablement.
MSG_EXPLICIT_TYPE_RECOMMENDED_FOR_CATCH_STMTS = Il est recommandé d'ajouter un type explicite pour cette instruction catch.
MSG_SUPER_NOT_ACCESSIBLE_FROM_BLOCK = Le symbole super n'est pas accessible à partir des blocs.
MSG_GENERIC_PROPERTIES_NOT_SUPPORTED = Les propriétés ne peuvent pas posséder de variable de type.
MSG_GENERIC_ANNOTATIONS_NOT_SUPPORTED = Les annotations ne peuvent pas posséder de variable de type.
MSG_CATCH_STMT_CANNOT_EXECUTE = Cette déclaration catch ne pourra pas s'exécuter, car une déclaration catch antérieure intercepte déjà les exceptions de ce type.
MSG_IMONITOR_LOCK_SHOULD_ONLY_BE_USED_WITHIN_USING_STMTS = L'interface IMonitorLock doit s'utiliser uniquement au sein des déclarations using d'expression pour la synchronisation héritée.
MSG_STATIC_MODIFIER_NOT_ALLOWED_HERE = Le modificateur 'static' n'est pas autorisé ici.
MSG_MODIFIERS_NOT_ALLOWED_HERE = Les modificateurs ne sont pas autorisés ici.
MSG_CANNOT_INSTANTIATE_NON_STATIC_CLASSES_HERE = Impossible d'instancier une classe non statique ici.
MSG_WARN_ON_SUSPICIOUS_THIS_COMPARISON = La comparaison semble incorrecte. En langage Gosu, l'opérateur '\=\=' équivaut à .equals(). Pour définir une équivalence d'instance, utilisez plutôt l'opérateur '\=\=\='.
MSG_FL_EXPECTING_FEATURE_NAME = Nom de fonction attendu (nom de méthode, nom de propriété ou mot-clé 'construct')
MSG_FL_EXPECTING_RIGHT_CARET = '>' attendu
MSG_FL_GENERIC_FUNCTION_REFERENCES_NOT_YET_SUPPORTED = Les valeurs littérales de fonction générique ne sont pas encore prises en charge.
MSG_FL_EXPECTING_RIGHT_PAREN = ')' attendu pour fermer la liste de type d'argument.
MSG_FL_CONSTRUCTOR_NOT_FOUND = Aucun constructeur associé aux types {0} n'a été détecté.
MSG_FL_METHOD_NOT_FOUND = Aucune méthode associée au nom {0} et aux types {1} n'a été détectée.
MSG_FL_PROPERTY_NOT_FOUND = Aucune propriété associée au nom {0} n'a été détectée.
MSG_FL_STATIC_FEATURES_MUST_BE_REFERENCED_FROM_THEIR_TYPES = Un constructeur ou une fonction statique doit être référencé(e) directement sur le type auquel la fonction appartient.
MSG_NO_TYPE_AFTER_CONSTRUCTOR = Les constructeurs ne peuvent pas spécifier de type de retour.
WS_ERR_Can_Not_Marshal = {0} Impossible de convertir le type local {2} pour {1}.
WS_ERR_Annotation_Duplicate_Namespace = Sur {0} \: espace de noms en double « {1} » déjà utilisé dans « {2} ». {3} tentatives de l'introduire de nouveau pour {4}.
WS_ERR_Annotation_Exception = Les propriétés du type {0} seront ignorées. Accédez au journal pour consulter la trace de pile.
WS_ERR_Annotation_Invalid_Namespace = {0} \: espace de noms incorrect \: « {1} »
WS_ERR_Annotation_Only_For_WebService = {0} \: l'annotation @{1} peut uniquement s'utiliser dans les classes comportant l'annotation @WsiWebService
WS_ERR_Annotation_Operation_Duplicate = Sur {0} \: méthode {1}, il existe déjà une méthode de ce nom
WS_ERR_Annotation_Operation_OneWay_Invalid = Le type de retour des méthodes unidirectionnelles doit être nul.
WS_ERR_Annotation_Operation_Response_Reserved = Sur {0} \: méthode {1}, le suffixe 'Response' est réservé aux éléments de réponse
WS_ERR_Export_Inner_Only_On_WebService = Sur {0} \: les classes internes de type {1} ne sont pas exportables
WS_ERR_Export_Inner_Not_Name_Of_Method = Les classes internes ont le même nom que la requête pour la méthode {0}
WS_ERR_Export_Inner_Not_Name_Of_Response = Les classes internes ont le même nom que la réponse pour la méthode {0}
WS_ERR_Export_No_Constructor = Sur {0} \: le type {1} est une classe exportable et doit avoir un constructeur public par défaut
WS_ERR_Export_No_Extends = Sur {0} \: type {1}, une classe exportable ne peut pas étendre une autre classe
WS_ERR_Export_Not_Final = Sur {0} \: le type {1} n'est pas final. Une classe exportable doit être finale
WS_ERR_Export_Not_WebService = Sur {0} \: le type {1} est un service Web. Un service Web ne peut pas être exportable
WS_ERR_Export_Recursive = La récursivité n'est pas prise en charge ; vérifiez que la classe {0} n'est pas récursive.
WS_WARN_Annontation_Some_Generators_Dont_Support_Schema = {0} Avertissement lié au traitement du paramètre {1} ; certaines infrastructures de service Web risquent de ne pas pouvoir interpréter {2}
WS_WARN_Annontation_Not_Available = {0} n'est pas disponible avant {1}
WS_WARN_Ignored = {0} \: la propriété {1} du type {2} sera ignorée.
PCF_ERR_Verify = Une erreur s'est produite au moment de vérifier {0}.
MSG_FL_ONLY_PROPERTIES_MAY_BE_CHAINED = Seules les valeurs littérales de biens peuvent être chaînées.
Gen_Wsi_InvalidType = {0} ne peut pas convertir les paramètres {1} \: {2}
Gen_Wsi_UnsupportedType = {0} est un type correct mais n'est pas pris en charge avec les services Web.
Gen_Wsi_UnsupportedComponentType = {0} n'est pas pris en charge car son type de composant/paramètre n'est pas pris en charge.
Gen_Wsi_NoComponentType = {0} n'est pas pris en charge car aucun type de composant/paramètre n'est spécifié.
Gen_Wsi_NoBase = La classe XmlBase {0} n'est pas directement prise en charge.
Gen_Wsi_AnonElement = 0} Les éléments anonymes ne sont pas pris en charge. Un élément anonyme est un enfant d'un autre élément. Essayez d'utiliser le type de l'élément enfant.
Gen_Wsi_AnonType = {0} Les types anonymes (types déclarés avec une déclaration dans l'élément) ne sont pas pris en charge. Essayez d'utiliser l'élément.
Gen_Wsi_NoSimple = Les types XSD simples {0} ne sont pas pris en charge. Essayez de créer un type complexe ou utilisez le type étendu.
Gen_Wsi_XmlError = Erreur inattendue lors du traitement de {0} \: {1}
Gen_Wsi_NullType = Type nul transmis
Gen_Wsi_TypeNotGosu = {0} n'est pas en Gosu et n'est donc pas pris en charge par l'implémentation wsi.
Gen_Wsi_TypeNotWSAnnotated = {0} n'a pas l'annotation @WsiWebService.
Gen_Wsi_TypeNotEXPAnnotated = {0} n'a pas l'annotation @WsiExportable.
GEN_CAN_NOT_MARSHAL_GOSU_REMOTEABLE_ENUMS = {0} ne peut pas convertir les paramètres GWEnumerations écrit en Gosu
GEN_CAN_NOT_MARSHAL_REMOTEABLE_ENUMS_EXTENDED = {0} ne peut pas convertir les paramètres GWEnumerations ayant des propriétés supplémentaires
GEN_CAN_NOT_MARSHAL_XML_IN_EXPORTABLE = {0} ne peut pas convertir les paramètres xml dans des types WsiExportable
GEN_CLASS_CANNOT_BE_BOTH_WS_AND_EXPORT = La classe {0} ne peut pas être à la fois @WsiWebService et {1}
GEN_CHECKING = Vérification de {0}
GEN_CHANGED = Modification de {0}
WS_ERR_Invalid_Supertype = {0} n'étend pas {1}
WS_ERR_Export_Empty = {0} n'a pas de propriétés exportables
WS_ERR_Previous_Invalid = {0} est incorrect. Erreurs signalées précédemment
WS_ERR_Entity_Invalid = {0} est incorrect. Les entités marshalling ne sont pas prises en charge. Créez une classe WsiExportable avec les champs requis.
WS_ERR_Collection_Invalid = {0} est incorrect. Seules les séries et les listes en <T> sont prises en charge.
WF_WARN_Subtype = Le sous-type de workflow « {0} » est défini comme non externe. Cependant, soit aucun script n'a été défini, soit l'analyse du script a échoué. Vérifiez les journaux pour savoir si des analyses ont échoué.
WF_ERR_Duplicate = Plusieurs traitements de workflow sont définis avec les mêmes typecode « {0} » et version « {1} ».
WF_ERR_Parse = Impossible d'analyser « {0} » -- {1}\: {2}
WF_ERR_Convert = Impossible de convertir « {0} » -- {1}\: {2}
WF_ERR = Sur « {0} » \: {1}

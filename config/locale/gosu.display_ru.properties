ARRAY = Массив данных
BEAN = Компонент
BOOLEAN = Логическое значение
DATETIME = ДатаВремя
FUNCTION = Функция
IDENTIFIER = Идентификатор
METATYPENAME = Тип
NULLTYPENAME = Неопределенное значение
NUMERIC = Номер
STRING = Строка
MSG_SYNTAX_ERROR = Синтаксическая ошибка.
MSG_BAD_IDENTIFIER_NAME = Не удалось разрешить символ для\: {0}
MSG_END_OF_STMT = Ожидается конец оператора. Возможно, оператор неверный или отсутствует.
MSG_END_OF_EXPRESSION = Ожидается конец выражения. Возможно, оператор неверный или отсутствует.
MSG_EXPECTING_OPERATOR_TO_FOLLOW_EXPRESSION = Неполная выписка. После выражения должен следовать оператор.
MSG_EXPECTING_ARGS = Ожидается аргумент[ы] для функции, {0}
MSG_EXPECTING_EXPRESSION_CLOSE = Ожидается, что ')' должна закрывать выражение в скобках.
MSG_EXPECTING_FUNCTION_CLOSE = Ожидается, что ')' должна закрывать вызов функции.
MSG_EXPECTING_TYPE_NAME = Ожидается название типа.
MSG_PARAMETERIZATION_NOT_SUPPORTED_FOR_TYPE = {0} не поддерживает параметризацию.
MSG_NO_ARGUMENTS = Функция {0} не принимает аргументов.
MSG_NULL_SYMBOL_TABLE = Таблица символов нулевая или пустая.
MSG_TYPE_MISMATCH = Тип "{1}" не может быть преобразован в "{0}"
MSG_VALUE_MISMATCH = Несоответствие значений. Значение литерала, "{0}", не может быть преобразовано в {1}.
MSG_WRONG_NUM_OF_ARGS = Неверное число аргументов для функции, {0}
MSG_EXPECTING_NAME_FUNCTION_DEF = Ожидается имя для функции.
MSG_EXPECTING_LEFTPAREN_FUNCTION_DEF = Ожидается, что '(' должна открывать объявление аргумента функции.
MSG_EXPECTING_RIGHTPAREN_FUNCTION_DEF = Ожидается, что ')' должна закрывать объявление аргумента функции.
MSG_EXPECTING_TYPE_FUNCTION_DEF = Ожидается условие "\:" для объявления функции.
MSG_EXPECTING_TYPE_LITERAL_FUNCTION_DEF = Ожидается тип после "\:" для объявления функции.
MSG_EXPECTING_IDENTIFIER_FOREACH = Ожидается идентификатор для оператора "for...in".
MSG_EXPECTING_IDENTIFIER_FOREACH_INDEX = Ожидается идентификатор в "индексе" оператора "for...in".
MSG_EXPECTING_IDENTIFIER_FOREACH_ITERATOR = Ожидается идентификатор в "итераторе" оператора "for...in".
MSG_FOREACH_ITERATOR_NOT_ALLOWED = "итератор" недопустим в "для...в" выписке без переменного цикла.
MSG_ITERATOR_SYMBOL_ONLY_SUPPORTED_ON_ITERABLE_OBJECTS = Символ "iterator" поддерживается только для итерируемых объектов.
MSG_EXPECTING_IDENTIFIER_EXISTS = Ожидается идентификатор для выражения "exists"
MSG_EXPECTING_IDENTIFIER_EXISTS_INDEX = Ожидается идентификатор в "индексе" выражения "exists".
MSG_EXPECTING_IN_FOREACH = Ожидается условие "in" для оператора "for...in".
MSG_EXPECTING_LEFTPAREN_FE = Ожидается '(' в операторе "for...in".
MSG_EXPECTING_RIGHTPAREN_FE = Ожидается ')' в операторе "for...in".
MSG_EXPECTING_LEFTPAREN_BLOCK = Ожидается '(' в объявлении типа блока.
MSG_EXPECTING_RIGHTPAREN_BLOCK = Ожидается ')' в объявлении типа блока.
MSG_EXPECTING_COLON_BLOCK = Ожидается '\:' в объявлении типа блока.
MSG_EXPECTING_IN_EXISTS = Ожидается условие "in" для выражения "exists".
MSG_EXPECTING_WHERE_EXISTS = Ожидается условие "where" для выражения "exists".
MSG_EXPECTING_LEFTPAREN_EXISTS = Ожидается '(' в выражении "exists".
MSG_EXPECTING_RIGHTPAREN_EXISTS = Ожидается ')' в выражении "exists".
MSG_EXPECTING_LEFTPAREN_EVAL = Ожидается, что '(' должна открывать выражение "eval".
MSG_EXPECTING_RIGHTPAREN_EVAL = Ожидается, что ')' должна закрывать выражение "eval".
MSG_EXPECTING_LEFTPAREN_CATCH = Ожидается '(' в условии "catch" оператора "try...catch...finally".
MSG_EXPECTING_RIGHTPAREN_CATCH = Ожидается ')' в условии "catch" оператора "try...catch...finally".
MSG_EXPECTING_IDENTIFIER_CATCH = Ожидается идентификатор для условия "catch" оператора "try...catch...finally".
MSG_CATCH_OR_FINALLY_REQUIRED = Ожидается условие "catch" или "finally" в операторе "try...catch...finally".
MSG_EXPECTING_LEFTBRACE_STMTBLOCK = Ожидается, что { должна открывать блок выписки.
MSG_EXPECTING_RIGHTBRACE_STMTBLOCK = Ожидается, что '}' должна закрывать блок оператора.
MSG_EXPECTING_LEFTPAREN_IF = Ожидается, что '(' должна открывать условие "if".
MSG_EXPECTING_RIGHTPAREN_IF = Ожидается, что ')' должна закрывать условие "if".
MSG_EXPECTING_LEFTPAREN_SWITCH = Ожидается, что '(' должна открывать выражение "switch".
MSG_EXPECTING_RIGHTPAREN_SWITCH = Ожидается, что ')' должна закрывать выражение "switch".
MSG_EXPECTING_LEFTPAREN_WHILE = Ожидается, что '(' должна открывать условие "while".
MSG_EXPECTING_RIGHTPAREN_WHILE = Ожидается, что ')' должна закрывать условие "while".
MSG_EXPECTING_LEFTPAREN_EXCEPT = Ожидается, что '(' должна открывать условие "except".
MSG_EXPECTING_RIGHTPAREN_EXCEPT = Ожидается, что ')' должна закрывать условие "except".
MSG_EXPECTING_WHILE_DO = Условие "while" должно закрывать оператор "do...while".
MSG_LOOP_DOESNT_LOOP = Цикл не является циклом
MSG_EXPECTING_EQUALS_ASSIGN = Ожидается '\=' для оператора присваивания.
MSG_EXPECTING_EXPRESSSION_ON_RHS = Ожидается действительное выражение справа для оператора присваивания.
MSG_EXPECTING_STATEMENT = Ожидается оператор.
MSG_EXPECTING_BEANTYPE = Ожидается сложный тип для доступа к элементу. Найдено\: {0}
MSG_EXPECTING_ARRAYTYPE_FOREACH = Ожидается тип массива данных после условия 'in' в операторе "for...in". Найдено\: {0}
MSG_EXPECTING_ARRAYTYPE_EXISTS = Ожидается тип массива после условия 'in' в выражении "exists". Найдено\:
MSG_EXPECTING_IDENTIFIER_ARG_TYPE = Ожидается имя типа после "\:" для аргумента функции.
MSG_EXPECTING_ARRAY_BRACKET = Ожидается, что ']' должна закрывать литерал типа массива данных.
MSG_EXPECTING_NEW_ARRAY_OR_CTOR = Ожидается, что [ или ) должна начинать новый массив данных или операцию с объектом.
MSG_EXPECTING_OPEN_BRACE_FOR_NEW_ARRAY = Ожидается, что '{{' должны начинать список выражений значений массивов.
MSG_EXPECTING_CLOSE_BRACE_FOR_NEW_ARRAY = Ожидается, что '}' должна закрывать список выражений значений массивов.
MSG_EXPECTING_CLOSING_ANGLE_BRACKET_FOR_TYPE = Ожидается, что '>' должно закрывать литерал параметризованного типа.
MSG_EXPECTING_CLOSING_ANGLE_BRACKET_FOR_TYPE_VAR_LIST = Ожидается, что '>' должно закрывать список переменных типа.
MSG_COULD_NOT_PARAMETERIZE = Не удалось параметризировать.
MSG_EXPECTING_OPEN_BRACE_FOR_SWITCH = Ожидается, что '{{' должны открывать оператор "switch".
MSG_EXPECTING_CLOSE_BRACE_FOR_SWITCH = Ожидается, что '}' должна закрывать оператор "switch".
MSG_EXPECTING_COLON_TERNARY = Ожидается '\:' для условного тройного выражения.
MSG_EXPECTING_REFERENCE_TYPE = Ожидается ссылочный тип. Простой тип здесь не допускается.
MSG_LOSS_OF_PRECISION_IN_CONDITIONAL_EXP = Типы невозможно преобразовать без потери точности. Преобразуйте их явным образом.
MSG_EXPECTING_CASE_COLON = Ожидается, что '\:' должно закрывать выражение "case".
MSG_DUPLICATE_CASE_EXPRESSION = Дублировать выражение дела.
MSG_TYPE_MISMATCH_IN_CONDIITIONAL_EXP = Несоответствие типов в условном тройном выражении.
MSG_EXPECTING_IDENTIFIER_VAR = Ожидается имя переменной.
MSG_EXPECTING_VAR_STMT = Ожидается объявление "var".
MSG_EXPECTING_TYPELITERAL = Ожидается литерал типа в правой части выражения.
MSG_EXPECTING_TYPELITERAL_OR_NAMESPACE = Ожидается литерал типа или пространство имен.
MSG_PRIMITIVES_NOT_ALLOWED_HERE = Использование простых типов недопустимо.
MSG_INCONVERTIBLE_TYPES = Типы, не подлежащие конвертации; невозможно преобразование {0} в {1}
MSG_BAD_NAMESPACE = {0} не является допустимым пространством имен.
MSG_EXPECTING_ARRAYLENGTH = Ожидается свойство массива данных "length".
MSG_ENTITYBEANS_ARE_IMMUTABLE = Свойство объекта не может быть изменено напрямую.
MSG_MULTIPLE_DEFAULT_CLAUSES_NOT_PERMITTED = Несколько условий 'default' обнаружено в операторе "switch".
MSG_CASE_CLAUSE_MAY_NOT_FOLLOW_DEFAULT_CLAUSE = Условие оператора выбора не может следовать после условия 'default'.
MSG_METHOD_NOT_VISIBLE = Функция, "{0}", не видна из-за ограничений видимости анализатора.
MSG_PROPERTY_NOT_VISIBLE = Свойство, "{0}", невидимо из-за ограничений видимости анализатора.
MSG_OBJECT_RETIRED = Идентификатор, "{0}", ссылается на отмененный объект.
MSG_OBJECT_LITERALS_DEPRECATED = Литералы объектов устарели. Вместо этого используйте  средство формирования запросов.
MSG_DEPRECATED_MEMBER = {0} в {1} является устаревшим.
MSG_EXPECTING_ENTITY_TYPE = Ожидается имя типа объекта в выражении "find".
MSG_EXPECTING_QUERY_PATH = Ожидается выражение пути запроса.
MSG_QUERY_PATH_MUST_BEGIN_WITH = Выражение пути запроса должно начинаться с "{0}"
MSG_EXPECTING_CONDITIONAL_EXPRESSION = Ожидается условное выражение, например, "a > b"
MSG_CONDITIONAL_EXPRESSION_EXPECTS_BOOLEAN = ожидается логическое значение.
MSG_EXPECTING_IDENTIFIER_FIND = Ожидается идентификатор для выражения "find"
MSG_EXPECTING_IN_FIND = Ожидается условие "in" для выражения "find".
MSG_EXPECTING_WHERE_FIND = Ожидается условие "where" для выражения "find".
MSG_EXPECTING_LEFTPAREN_FIND = Ожидается '(' в выражении "find".
MSG_EXPECTING_RIGHTPAREN_FIND = Ожидается ')' в выражении "find".
MSG_QUERYPATH_MUST_BEGIN_WITH = Путь к запросу должен начинаться с выражения родительского запроса "{0}".
MSG_QUERY_IN_LHS_OP_NOT_ENTITY = {0} не выдает тип объекта. Оператор "in" требует свойство типа объекта в lhs.
MSG_QUERY_IN_LHS_OP_NOT_ARRAY = {0} не имеет соответствующего типа массива данных. Оператор "in" требует свойство типа объекта в lhs, которое имеет допустимый тип массива данных.
MSG_QUERY_EXPECTED_BOOLEAN_EXPRESSION = {0} не является логическим выражением.
MSG_EXPECTING_READONLY_ENTITY_TYPE = "find" ограничивается типами объектов, доступных только для чтения. Установите элемент реестра "allow-entity-queries", чтобы найти объекты, доступные для записи.
MSG_STR_IMMUTABLE = Строки являются неизменяемыми и не подлежат модификации.
MSG_UNTERMINATED_STRING_LITERAL = Незавершенный строковый литерал. Ожидается ".
MSG_INVALID_CHAR_AT = Недопустимый экранирующий символ в положении {0}
MSG_FUNCTION_CLASH_PARAMS = "{0}" в "{1}" конфликтует с "{2}" в "{3}"; обе функции имеют одно и то же стирание типов, но ни одна их них не переопределяет другую
MSG_UNTERMINATED_COMMENT = Незаконченный комментарий. Ожидается "*/".
MSG_UNEXPECTED_EOF = Неожиданное окончание файла
MSG_FUNCTION_ALREADY_DEFINED = {0}, уже определена в {1}
MSG_FUNCTION_CLASH = "{0}" в "{1}" сталкивается с "{2}" в "{3}"; типы возвращаемых значений несовместимы.
MSG_ATTEMPTING_TO_ASSIGN_WEAKER_ACCESS_PRIVILEGES = "{0}" в "{1}" сталкивается с "{2}" в "{3}"; пытаясь назначить меньшие привилегии доступа.
MSG_CANNOT_OVERRIDE_FINAL = Невозможно переопределить последний элемент "{0}" из "{1}"
MSG_CANNOT_ASSIGN_VALUE_TO_FINAL_VAR = Не удалось назначить значение для конечной переменной "{0}"
MSG_VAR_MIGHT_NOT_HAVE_BEEN_INIT = Переменная "{0}" уже инициализирована
MSG_VAR_MIGHT_ALREADY_HAVE_BEEN_INIT = Переменная "{0}" уже инициализирована
MSG_VAR_MIGHT_ALREADY_HAVE_BEEN_INIT_LOOP = Переменная "{0}" уже могла быть инициализирована
MSG_FUNCTION_ALREADY_DEFINED_IN_EXTENDED_CLASS = {0}, уже определена. Расширения не могут переопределять функции.
MSG_DUPLICATE_CLASS_FOUND = Дубликат класса обнаружен в\: {0}.
MSG_DUPLICATE_TYPE_FOUND = Дублированный тип обнаружен в\: {0}.
MSG_DUPLICATE_ENHANCEMENT_FOUND = Дубликат расширения обнаружен в\: {0}.
MSG_EXPECTING_OPEN_BRACE_FOR_CLASS_DEF = Ожидается, что '{{' должны открывать оператор "class".
MSG_EXPECTING_CLOSE_BRACE_FOR_CLASS_DEF = Ожидается, что '}' должна закрывать оператор "class".
MSG_EXPECTING_NAME_CLASS_DEF = Ожидается имя для класса.
MSG_EXPECTING_ENHANCEMENT_DEF = Ожидается расширение.
MSG_NAMESPACE_CLASS_CONFLICT = Путь к каталогу класса не соответствует имени пакета.
MSG_NO_SUCH_FUNCTION = Нет определенных функций для {0}.
MSG_CANNOT_EXTEND_PRIMITIVE_TYPE = Невозможно расширить простой тип {0}.
MSG_CANNOT_EXTEND_FINAL_TYPE = Невозможно расширить тип final {0}.
MSG_ENHANCEMENTS_CANNOT_ENHANCE_OTHER_ENHANCEMENTS = Невозможно расширить расширение {0}.
MSG_CYCLIC_INHERITANCE = Циклическое наследование с участием {0}.
MSG_EXPECTING_OPEN_BRACE_FOR_CONSTRUCTOR_DEF = Ожидается, что '{{' должны открывать тело конструктора.
MSG_EXPECTING_OPEN_BRACE_FOR_FUNCTION_DEF = Ожидается, что '{{' должны открывать тело функции.
MSG_EXPECTING_CLOSE_BRACE_FOR_FUNCTION_DEF = Ожидается, что '}' должна закрывать тело функции.
MSG_EXPECTING_CLOSE_BRACE_FOR_CONSTRUCTOR_DEF = Ожидается, что '}' должна закрывать тело конструктора.
MSG_NO_DEFAULT_CTOR_IN = Нет конструктора по умолчанию в {0}.
MSG_WRONG_NAMESPACE = Имя пакета "{0}" не соответствует каталогу "{1}".
MSG_WRONG_CLASSNAME = Имя класса {0} не соответствует файлу {1}.
MSG_SAME_NAME_AS_CLASS = "{0}" уже определено как имя класса для этого файла
MSG_EXPECTING_PROPERTY_GET_OR_SET_MODIFIER = Ожидается модификатор 'get' или 'set' для свойства.
MSG_EXPECTING_NAME_PROPERTY = Ожидается имя свойства для переменной.
MSG_PROPERTY_ALREADY_DEFINED = Свойство "{0}" уже определено.
MSG_GETTER_FOR_PROPERTY_ALREADY_DEFINED = Функция свойства 'get' уже определена для "{0}".
MSG_SETTER_FOR_PROPERTY_ALREADY_DEFINED = Функция свойства 'set' уже определена для "{0}".
MSG_PROPERTY_NOT_WRITABLE = "{0}" недоступно для записи.
MSG_CLASS_PROPERTY_NOT_READABLE = Свойство "{0}", класса "{1}", недоступно для чтения.
MSG_CLASS_PROPERTY_NOT_WRITABLE = Свойство "{0}" класса "{1}", недоступно для записи.
MSG_NO_VIEWS_FOR_YOUS = Представления не поддерживаются. Попробуйте запрос в отношении "{0}"
MSG_VARIABLE_ALREADY_DEFINED = {0}, уже определена. Используйте другое имя.
MSG_FUNCTION_DECL_MISSING = Внутренняя ошибка. Не удалось найти символ функции объявления для, {0}.
MSG_EXPECTING_DEFAULT_VALUE = Ожидается присваивание значения по умолчанию. Обязательные параметры должны предшествовать дополнительным.
MSG_DEFAULT_VALUE_NOT_ALLOWED = Здесь не допускается использование значения по умолчанию
MSG_COMPILE_TIME_CONSTANT_REQUIRED = Выражение должно быть постоянной времени компиляции.
MSG_OVERLOADING_NOT_ALLOWED_WITH_OPTIONAL_PARAMS = Перегрузка с дополнительными параметрами не допускается
MSG_MISSING_REQUIRED_ARGUMENTS = Отсутствует один или несколько обязательных аргументов
MSG_ARGUMENT_ALREADY_DEFINED = Аргумент уже определен
MSG_EXPECTING_NAME_PARAM = Ожидается имя для параметра
MSG_EXPECTING_NAMED_ARG = Ожидается аргумент с именем
MSG_PARAM_NOT_FOUND = Параметр не найден
MSG_VARIABLE_REQUEST_DOES_NOT_ALLOW_VALUE = , переменные запроса не могут иметь начальное значение.
MSG_VARIABLE_TYPE_OR_VALUE_REQUIRED = Ожидается "as" и/или "\:" для оператора "var".
MSG_VARIABLE_MUST_HAVE_NON_NULL_TYPE = Переменные должны быть ненулевого типа.  Добавьте явный тип для этой переменной.
MSG_CONDITION_IS_ALWAYS_TRUE_FALSE = Всегда использовать условие {0}
MSG_VOID_NOT_ALLOWED = Тип 'void' недопустим здесь
MSG_FUNCTIONS_NOT_ALLOWED_IN_THIS_CONTEXT = Объявления функций недопустимы в данном контексте
MSG_CONSTRUCTORS_NOT_ALLOWD_IN_THIS_CONTEXT = В данном контексте конструкторы недопустимы
MSG_INNER_CLASSES_NOT_ALLOWED_IN_THIS_CONTEXT = Объявления внутренних классов не разрешены в данном контексте
MSG_NO_SOURCE_FOUND = Источник для класса не найден.
MSG_CANNOT_RETURN_VALUE_FROM_VOID = Невозможно вернуть значение из пустой функции.
MSG_RETURN_NOT_ALLOWED_HERRE = Оператор возврата здесь недопустим.
MSG_MISSING_RETURN_VALUE = Отсутствует возвращаемое значение.
MSG_EXPECTING_DECL = Ожидается объявление для переменной, функции или свойства.
MSG_FUNCTION_ARG_NAME_CONFLICTS_WITH_CLASS_VAR = Аргумент "{0}" функции {1} конфликтует с полем класса.
MSG_EXPECTING_ARROW_AFTER_BLOCK_ARGS = Ожидается, что '->' должен следовать после объявлений аргументов блока.
MSG_EXPECTING_CLOSE_BRACE_FOR_BLOCK = Ожидается, что '}' должна следовать за списком операторов блока.
MSG_EXPECTING_ARROW_AFTER_MAP_KEY = Ожидается, что '->' должен следовать после объявлений аргументов блока.
MSG_UNEXPECTED_ARROW = Неожиданное '->' в инициализаторе списка
MSG_EXPECTING_CLOSE_BRACE_FOR_INITIALIZER = Ожидается, что '}' должна следовать за оператором инициализатора.
MSG_MODIFIER_ABSTRACT_NOT_ALLOWED_HERE = Модификатор 'abstract' здесь не допускается.
MSG_ABSTRACT_METHOD_CANNOT_BE_ACCESSED_DIRECTLY = Невозможно получить прямой доступ к абстрактному методу {0}
MSG_NOT_ALLOWED_IN_INTERFACE = Не допускается в интерфейсе.
MSG_UNIMPLEMENTED_METHOD = Функция {0} не реализована\: {1}
MSG_INHERITS_UNRELATED_DEFAULTS = {0} наследует несвязанные значения по умолчанию для {1} от {2} и {3}
MSG_INHERITS_ABSTRACT_AND_DEFAULT = {0} наследует абстрактный метод и метод по умолчанию для {1} от {2} и {3}
MSG_INTERFACE_CANNOT_EXTEND_CLASS = Интерфейс не может расширять класс, только интерфейсы.
MSG_CLASS_CANNOT_EXTEND_INTERFACE = Класс не может 'расширять' интерфейс.
MSG_CANNOT_EXTEND_ARRAY = "Класс не может 'расширить' массив."
MSG_CLASS_MUST_HAVE_PACKAGE = Класс должен иметь пакет.
MSG_CLASS_CANNOT_IMPLEMENT_CLASS = Класс не может 'внедрять' класс.
MSG_ENUM_CANNOT_EXTEND_CLASS = Перечисление не может расширить класс
MSG_ENUM_CANNOT_HAVE_ANNOTATIONS = Постоянная перечисления не может иметь аннотации
MSG_ENUM_CONSTRUCTOR_MUST_BE_PRIVATE = Конструктор перечисления должен быть объявлен приватным
MSG_ENUM_CONSTRUCTOR_NOT_ACCESSIBLE = Конструктор перечисления недоступен здесь
MSG_ENUM_MAY_NOT_HAVE_TYPEPARAM = Перечисление не может иметь параметры типа
MSG_BAD_CAPTURE_TYPE = Блоки не поддерживают лексическую ссылку на этот тип символа.  Присвойте локальной переменной вне блока ссылку на него.
MSG_POTENTIALLY_BAD_CAPTURE = Данный идентификатор захватывает внешнюю переменную, которая не полностью поддерживает захват "out of scope".  Если идентификатор производит оценку за пределами диапазона крайней внешней функции, может произойти ошибка выполнения.
MSG_CANNOT_CAPTURE_SYMBOL_IN_BLOCK_IN_ANON_CLASS = Невозможно захватить символы в блоке, вложенном в анонимный класс.
MSG_CANNOT_CAPTURE_SYMBOL_IN_ANON_CLASS_IN_BLOCK = Невозможно захватить символы в анонимном классе, вложенном в блок.
MSG_EXPECTING_ENHANCE_KEYWORD = Ожидается "enhance"
MSG_NON_PRIVATE_MEMBERS_MUST_DECLARE_TYPE = Элементы с неконфиденциальными данными должны заявлять тип явно.
MSG_DELEGATES_CANNOT_BE_STATIC = Делегаты не могут быть статическими.
MSG_DELEGATE_METHOD_CONFLICT = Конфликт элемента делегата\: {0} и {1}. Чтобы разрешить конфликт, реализуйте элемент явным образом.
MSG_DELEGATES_SHOULD_NOT_SELF_DELEGATE = Делегаты не должны сами себя делегировать.
USING_INTERNAL_CLASS = Это внутренний класс, который изменится в будущем.  Использование этого класса <b>опасно и не поддерживается</b>.
MSG_EXTENSION_CLASS_NOT_FOUND = Не удалось найти класс {0} для расширения.
MSG_CANNOT_DEREF_PROPERTIES_IN_WHERE = Невозможно отменить ссылку на свойство в условии where. Попробуйте использовать условие 'exists'.
MSG_CANNOT_CALL_METHOD_WITH_WILDCARD_PARAM = Невозможно вызвать функцию с универсальными параметрами.
MSG_NO_WILDCARDS = Подстановочные знаки амортизируются в Gosu. Измените параметр типа на "{0}"
MSG_EXPECTING_COLON_ENHANCEMENT = Ожидается '\:' в расширении.
MSG_EXPECTING_CLOSE_BRACKET_FOR_LIST_LITERAL = Ожидается ']' в конце литерала списка.
MSG_CANNOT_PARAMETERIZE_NONGENERIC = Невозможно параметризировать необщий тип.
MSG_TYPE_PARAM_NOT_ASSIGNABLE_TO = Параметр типа {0} не может быть назначен ограничивающему типу {1}.
MSG_TYPE_NOT_ANNOTATION = Тип {0} не является аннотацией.  Требуется аннотация java или интерфейс внедрения gw.lang.IAnnotation
MSG_MISPLACED_META_ANNOTATION = Данная аннотация может использоваться только в классе аннотаций.
MSG_MISPLACED_ANNOTATION = Данная аннотация не может использоваться в классе аннотаций.
MSG_ANNOTATION_WHEN_NONE_ALLOWED = Аннотация "{0}" не допускается в объявлении {1}.
MSG_ANNOTATION_USE_SITE_TARGET_NOT_ALLOWED_HERE = В аннотации "{0}" содержится недопустимый адрес целевого сайта "{1}" для контекста.
MSG_TOO_MANY_ANNOTATIONS = Аннотация "{0}" может использоваться только один раз в объявлении {1}.
MSG_EXPECTING_COLON_ANNOTATION = Для разделения целевого сайта и типа аннотации ожидался символ "\:".
MSG_INVALID_TYPE = "{0}" не является допустимым типом.
MSG_INVALID_GENERIC_EXCEPTION = С помощью общего класса невозможно развернуть java.lang.Throwable
MSG_INVALID_INNER_TYPE = Внутренние классы не "{0}" обнаружены в "{1}".
MSG_INVALID_TYPE_WITH_QUALIFIED_NAME = "{0}" имеет недопустимый тип\: "{1}".
MSG_NOT_A_STATEMENT = Не оператор.
MSG_CANNOT_CONSTRUCT_ABSTRACT_CLASS = "{0}" является абстрактным; построение невозможно.
MSG_CANNOT_CONSTRUCT_RECURSIVE_CLASS = "{0}" является рекурсивным, прямое построение невозможно.
MSG_RECURSIVE_CONSTRUCTOR = Вызов рекурсивного конструктора.
MSG_MISSING_RETURN = Оператор возврата отсутствует.
MSG_UNREACHABLE_STMT = Недоступный оператор.
MSG_BREAK_OUTSIDE_SWITCH_OR_LOOP = Оператор завершения здесь недопустим.
MSG_CONTINUE_OUTSIDE_LOOP = Оператор продолжения здесь недопустим.
MSG_PROPERTY_SET_MUST_HAVE_ONE_PARAMETER = Механизмы установки свойств должны иметь один и только один параметр.
MSG_PROPERTY_SET_MUST_RETURN_VOID = Установщик свойства должен возвращать пустой тип.
MSG_MISSING_PROPERTY_RETURN = Отсутствует тип возвращаемого свойства.
MSG_IMPLICIT_COERCION_WARNING = Здесь происходит неявное приведение от типа {0} к {1}.  Попробуйте сделать это явным с "as {1}".
MSG_IMPLICIT_COERCION_ERROR = Необходимо явно преобразовать {0} в {1} с помощью ключевого слова 'as'.
MSG_ASYMMETRICAL_COMPARISON = Асимметричное сравнение между {0} и {1}. Попробуйте преобразовать тип одного из операндов.
MSG_SILLY_ASSIGNMENT = Здесь происходит бесполезное присваивание {0} самому себе.  Это может быть непреднамеренным, а также из-за ошибки в программе.
MSG_UNUSED_VARIABLE = {0} не используется.
MSG_LIKELY_JAVA_CAST = Похоже, это попытка преобразования в стиле java, что не соответствует Gosu.  Для преобразования выражения в другой тип поместите "as {0}" после выражения
MSG_UNEXPECTED_TOKEN = Неожиданный маркер\: {0}
MSG_EXPECTING_INT_ACCESS_TO_ARR_ETC = Ожидается доступ типа int к типу массива данных, коллекции или строки с оператором массива данных [].
MSG_EXPECTING_BEAN_TYPE_WITH_REFLECTION_OPERATOR = Ожидается тип компонента с оператором отражения [].
MSG_PROPERTY_REFLECTION_ONLY_WITH_STRINGS = Отражение свойства компонента возможно только со строками.
MSG_EXPECTING_BRACKET_TO_CLOSE_DYNAMIC_MEMBER_ACCESS = Оператор ']' должен закрывать выражение динамического доступа к элементу.
MSG_WRONG_NUMBER_OF_ARGS_TO_FUNCTION = Неверное число аргументов для функции {0}.  Ожидалось {1}, получено {2}.
MSG_WRONG_NUMBER_OF_ARGS_TO_CONSTRUCTOR = Неверное число аргументов для конструктора {0}.  Ожидалось {1}, получено {2}.
MSG_SHOULD_HAVE_FOUND_METHOD_AT_LINE = Необходимо было найти функцию в строке {0}, столбце {1}
MSG_VOID_EXPRESSION_NOT_ALLOWED = Выражения в этом положении не должны быть пустыми.
MSG_EXPECTING_RETURN_TYPE_OR_FUN_BODY = Ожидается тип возвращаемого значения или тело функции.
MSG_INVALID_TYPE_FOR_ANNOTATION_MEMBER = Недопустимый тип для элемента аннотации
MSG_ERRANT_TYPE_VAR = Переменная блуждающего типа
MSG_USING_VOID_RETURN_TYPE_FROM_NON_NULL_EXPR = Использование пустого типа возврата из ненулевых выражений.
MSG_FIELD_TYPE_HAS_NOT_BEEN_INFERRED = Тип данного поля еще не выведен и, следовательно, не может использоваться.  Данное выражение должно находиться после объявления поля.
MSG_BEAN_CLASS_IS_NULL = Класс компонента пуст\!
MSG_BEAN_MEMBER_PATH_IS_NULL = Путь к элементу компонента нулевой\!
MSG_BEAN_MEMBER_PATH_IS_EMPTY = Путь к элементу компонента пуст\!
MSG_NO_EXPLICIT_TYPE_INFO_FOUND = Не найдено информации о явном типе для, {0}
MSG_NO_CONSTRUCTOR_FOUND_FOR_CLASS = Не найден конструктор для класса, {0}
MSG_WRONG_NUMBER_OF_ARGS_FOR_METHOD_ON_CLASS = Недопустимое количество аргументов для функции, {0}, в классе, {1}
MSG_NO_METHOD_DESCRIPTOR_FOUND_FOR_METHOD = Дескриптор функции не найден для функции, {0}, в классе, {1}
MSG_METHOD_IS_NOT_STATIC = Функция "{0}" не является статической в классе {1}
MSG_METHOD_IS_STATIC = Функция "{0}" является статической в классе {1}
MSG_NO_PROPERTY_DESCRIPTOR_FOUND = Дескриптор свойства {0} не найден для свойства {1} в классе {2}
MSG_NO_TYPE_ON_NAMESPACE = Тип {0} не найден в пакете {1}
MSG_ANY = {0}
MSG_EXPECTING_MEMBER_ACCESS_PATH = Ожидается путь доступа к элементу.
MSG_CANNOT_CREATE_NEW_ARRAY_FROM_TYPE_VAR = Невозможно создать новый экземпляр массива данных из переменной типа.  Данный тип доступен только для просмотра и записи.
MSG_NOT_A_VALID_EXCEPTION_TYPE = {0} не расширяет Throwable, и захват невозможен.
MSG_CANNOT_INFER_ARGUMENT_TYPE_AT_THIS_POSTION = Аргумент {0} должен предоставлять объявление типа, поскольку он не может быть выведен.
MSG_OBSOLETE_CTOR_SYNTAX = Этот синтаксис конструктора является устаревшим. Вместо этого используйте ключевое слово 'construct'.
MSG_OBSOLETE_NOT_EQUAL_OP = Оператор <> устарел и должен быть заменен на \!\=
MSG_MUST_BE_IN_OUTER_TO_CONSTRUCT_INNER = Должно быть внутри класса {0} или являться производным от него для построения нестатического внутреннего класса {1}.
MSG_TYPE_DOES_NOT_HAVE_EMPTY_CONSTRUCTOR = Тип {0} не имеет конструктора по умолчанию и не может быть неявно создан здесь.
MSG_ENHANCEMENT_DOES_NOT_ACCEPT_THIS_STATEMENT = Расширения не могут иметь операторов данного типа.
MSG_CANNOT_OVERRIDE_FUNCTIONS_IN_ENHANCEMENTS = Функция "{0}" уже определена в типе {1}.  Расширения не могут переопределять функции.
MSG_CANNOT_OVERRIDE_PROPERTIES_IN_ENHANCEMENTS = Свойство "{0}" уже определено в типе {1}.  Расширения не могут переопределять свойства.
MSG_ENHANCED_TYPE_MUST_USE_ENHANCEMENT_TYPEVARS = Улучшенный тип должен использовать все переменные типа, заявленные для улучшения.
MSG_ABSTRACT_MEMBER_NOT_IN_ABSTRACT_CLASS = Абстрактный элемент не в абстрактном классе.
MSG_ILLEGAL_USE_OF_MODIFIER = Недопустимое использование модификатора. Здесь невозможно использовать "{0}" с "{1}"
MSG_ILLEGAL_FORWARD_REFERENCE = Недопустимая опережающая ссылка
MSG_MISSING_OVERRIDE_MODIFIER = Отсутствует модификатор 'override'. Функция {0} переопределяет или реализует функцию из {1}.
MSG_RENAME_METHOD = Функцию необходимо переименовать. Функция {0} вызывает конфликт с функцией из {1}, для которого выдается сообщение о несоответствии типов. Частные функции компилируются с параметром доступа "internal" (внутренний), и поэтому они вызывают конфликт при выполнении в одном и том же пакетном сеансе.
MSG_STATIC_METHOD_CANNOT_OVERRIDE = С помощью статической функции {0} невозможно заменить/реализовать функцию в {1}.
MSG_OVERRIDES_OBJECT_METHOD = Метод по умолчанию {0} переопределяет метод объектов
MSG_INHEREITED_WITH_DIFF_ARG_TYPES = "{0}" не может наследоваться с различными аргументами типа\: {1}
MSG_NO_IMPLEMENTS_ALLOWED = Условия реализации недопустимы для интерфейса.
MSG_NO_EXTENDS_ALLOWED = В аннотации нельзя использовать условие "extends".
MSG_FUNCTION_NOT_OVERRIDE = Функция {0} ничего не переопределяет
MSG_FUNCTION_NOT_OVERRIDE_PROPERTY = Функция {0} ничего не переопределяет. Возможно, вы пытаетесь переопределить свойство {1}?
MSG_PROPERTY_OVERRIDES_WITH_INCOMPATIBLE_TYPE = Свойство переопределяет несовместимый тип
MSG_SUBCLASS_OBJECT = {0} явно разделяет объект на подклассы
MSG_AMBIGUOUS_SYMBOL_REFERENCE = Это неоднозначная ссылка. Определите символ полностью.
MSG_LIST_TO_ARRAYLIST_WARNING = Неявное приведение к ArrayList. Используйте ArrayList явно.
MSG_VAR_CASE_MISMATCH = На переменную "{0}" не ссылается правильный оператор выбора.  Измените эту ссылку на "{1}".
MSG_FUNCTION_CASE_MISMATCH = На функцию "{0}" не ссылается правильный оператор выбора.  Измените эту ссылку на "{1}".
MSG_PROPERTY_CASE_MISMATCH = На свойство "{0}" не ссылается правильный оператор выбора.  Измените эту ссылку на "{1}".
MSG_TYPE_CASE_MISMATCH = На тип "{0}" не ссылается правильный оператор выбора.  Измените эту ссылку на "{1}".
MSG_NON_STATIC_ACCESS_OF_STATIC_MEMBER = Свойство "{0}" является статическим, но на него не ссылается статически тип {1}.
MSG_NON_STATIC_ACCESS_WITH_IDENTIFIER_OF_STATIC_MEMBER = Свойство "{0}" является статическим, но на него не ссылается непосредственно тип {1}.    \nСуществует конфликтующая переменная или свойство под названием "{2}". Дайте полное определение выражения в формате {3}.{0}.
MSG_STATEMENT_ON_SAME_LINE = Несколько операторов, расположенных в одной строке, могут указывать на непреднамеренную логическую ошибку.\nПопробуйте переместить оператор на новую строку.
MSG_MUST_BE_DEFINED_AS_CLASS = Необходимо определить как "class".
MSG_VOID_RETURN_IN_CTX_EXPECTING_VALUE = Данной функции требуется блок для возврата значения.
MSG_NO_STATIC_CONSTRUCTOR = Конструкторы не могут быть статическими
MSG_NO_ABSTRACT_METHOD_CALL_IN_CONSTR = Функция {0} является абстрактной и не может быть вызвана в конструкторе.
MSG_CALLING_OVERRIDABLE_FROM_CTOR = Вызов переопределяемой функции из конструктора\: {0}
MSG_AMBIGUOUS_METHOD_INVOCATION = Это вызов неоднозначной функции.
MSG_RETURN_VAL_FROM_VOID_FUNCTION = Вы пытаетесь вернуть значение из пустой функции.
MSG_BAD_ANONYMOUS_CLASS_DECLARATION = Только типы java и gosu могут быть анонимно расширены.
MSG_SINGLE_ANON_CTOR = Анонимный класс может определять максимум один конструктор
MSG_ANON_CTOR_PARAMS_CONFLICT_WITH_CALL_SITE = Типы параметров анонимного конструктора конфликтуют с типами аргументов в месте вызова
MSG_ASSIGNMENT_IN_IF_STATEMENT = Присваивания недопустимы внутри условий
MSG_ASSIGNMENT_IN_LOOP_STATEMENT = Присваивания недопустимы внутри условий цикла
MSG_JAVA_STYLE_VARIABLE_DECLARATION = Это объявление переменной в стиле java.  Вместо этого используйте ключевое слово "var".
MSG_NUMERIC_TYPE_EXPECTED = Ожидается числовое выражение.
MSG_GETTER_CANNOT_HAVE_PARAMETERS = Определение свойства get не может иметь параметров.
MSG_BAD_TEMPLATE_DIRECTIVE = Неверная директива шаблона.  Допустимыми директивами являются "extends" и "params".
MSG_CLASSPATH_STATEMENT_EXPECTS_A_STRING = Оператору пути к классам требуется строка для пути
MSG_COMMA_IS_THE_CLASSPATH_SEPARATOR = Оператор пути к классу использует запятые в качестве независимого от платформы разделителя пути
MSG_BITSHIFT_LHS_MUST_BE_INT_OR_LONG = Левый операнд должен быть int или long.
MSG_BITWISE_OPERAND_MUST_BE_INT_OR_LONG = Побитовый логический операнд должен быть int или long.
MSG_EXPECTING_LEFTPAREN_USING = Ожидается, что '(' должна открывать предикат "using".
MSG_EXPECTING_RIGHTPAREN_USING = Ожидается, что ')' должна закрывать предикат "using".
MSG_BAD_TYPE_FOR_USING_STMT = Используемым предикатом оператора должен быть Closeable, IDisposable или Lock. Приведение к IMonitorLock для синхронизации в стиле Java.
MSG_UNNECESSARY_COERCION = Данное выражение уже принадлежит к типу {0}, поэтому его приведение к {1} не является обязательным.
MSG_LATER_ASSIGNMENT_MAKES_EXPRESSION_ILLEGAL = Более позднее присваивание {0} отменяет интерфейс типа, который делает это использование возможным.
WSDL_DUPLICATE_WEB_SERVICE = Дубликат имени веб-службы.  Только одна веб-служба с заданным именем может быть определена.
MSG_NUMBER_LITERAL_TOO_LARGE = Слишком большой литерал числа.
WSDL_DUPLICATE_METHOD = Дублирующие функции веб-службы.  Перегруженные функции должны иметь разное количество параметров, даже если типы параметров различны.\n{0} конфликтует с {1}.
WSDL_NOT_WEBSERVICE = Эта аннотация доступна только на веб-службе
WSDL_UNSUPPORTED_TYPE = Веб-служба не может ссылаться на следующий неподдерживаемый тип\: {0} {1}
WSDL_REFERENCE_ABSTRACT_CLASS = Веб-служба не может ссылаться на абстрактный класс\: {0} {1}
WSDL_REFERENCE_INTERFACE = Веб-служба не может ссылаться на интерфейс\: {0} {1}
WSDL_REFERENCE_ANNOTATION = Веб-служба не может ссылаться на аннотацию\: {0} {1}
WSDL_REFERENCE_TRANSACTION_TYPE = Веб-служба не может ссылаться на тип в пространстве имен gw.transaction.*\: {0} {1}
WSDL_REFERENCE_LIST = Веб-служба не может ссылаться на типы списков\: {0}.  Вместо этого попробуйте строго типизированный массив данных (например, String[]). {1}
WSDL_REFERENCE_MAP = Веб-служба не может ссылаться на типы отображения\: {0} {1}
WSDL_REFERENCE_COLLECTION = Веб-служба не может ссылаться на типы коллекций\: {0}  Вместо этого попробуйте строго типизированный массив данных (например, String[]). {1}
WSDL_REFERENCE_PARAMETERIZED_TYPE = Веб-служба не может ссылаться на параметризованные типы\: {0}
WSDL_REFERENCE_GENERIC_TYPE = Веб-служба не может ссылаться на обобщенные типы\: {0} {1}
WSDL_REFERENCE_UNSUPPORTED_NAMESPACE = Веб-служба не может ссылаться на следующий тип. Это часть неподдерживаемого пространства имен, разрешены только типы из пространства имен 'gw.*' (кроме gw.transaction.*)\: {0} {1}
WSDL_REFERENCE_CLASS_WITHOUT_DEFAULT_CONSTRUCTOR = Класс {0} не имеет конструктора по умолчанию, и на него не может ссылаться веб-служба. {1}   //Возможно, это должно быть предупреждение.
WSDL_REFERENCE_WEBSERVICE = Веб-служба не может ссылаться на другие типы веб-служб\: {0} {1}
WSDL_REFERENCE_SOAP_TYPE = Веб-службы не могут ссылаться на типы в пространстве имен soap.*\: {0} {1}
WSDL_REFERENCE_XML_TYPE = Веб-службы RPC не могут ссылаться на типы, основанные на xml\: {0} {1}
WSDL_READONLY_PROPERTIES = Веб-службы не должны ссылаться на типы, которые имеют свойства, доступные только для чтения.  \nТакие типы не могут быть установлены в качестве параметров для работы веб-службы. {0} {1}
WSDL_WRITEONLY_PROPERTIES = Веб-службы не должны ссылаться на типы, которые имеют свойства, доступные только для записи.  \nТакие типы не могут быть установлены как возвращаемый тип для работы веб-службы. {0} {1}
WSDL_REFERENCE_CAUSES_NAMESPACE_COLLISION = Данный тип вызывает столкновение пространств имен веб-служб.\nЭти два типа имеют одинаковые относительные имена и могут предоставляться веб-службам в одном пространстве имен soap.*.{0}.\nПереименуйте один из следующих типов, чтобы на них не ссылались в веб-службе\: {1} и {2}.  {3}
MSG_DELEGATION_NOT_ALLOWED_HERE = Делегирование здесь не допускается
MSG_DELEGATE_MUST_NOT_BE_STATIC = Статическое делегирование не поддерживается
MSG_DELEGATES_REPRESENT_INTERFACES_ONLY = Делегат может представлять только типы интерфейса
MSG_ONLY_INTERFACES_ALLOWED_HERE = Здесь допустимы только интерфейсы
MSG_ONLY_ONE_CLASS_IN_COMPONENT_TYPE = Только один неинтерфейс разрешен в типе компонента
MSG_ONLY_ONE_TYPE_VARIABLE = За переменной типа не могут следовать другие ограничения
MSG_NO_ARRAY_IN_COMPONENT_TYPE = В типе компонента не допускаются массивы
MSG_NO_PRIMITIVE_IN_COMPONENT_TYPE = В типе компонента не допускаются примитивы
MSG_COMPOUND_TYPE_NOT_ALLOWED_HERE = Здесь не допускается составной тип
MSG_PARAMETERIZED_TYPE_NOT_ALLOWED_HERE = Здесь не допускается использовать параметризованный тип
MSG_DYNAMIC_TYPE_NOT_ALLOWED_HERE = Динамический тип здесь недопустим
MSG_CANNOT_EXTEND_INTERNAL_JAVATYPE = Тип Java {0} имеет пакетно-защищенный доступ и не может быть развернут или усовершенствован в Gosu
MSG_CLASS_DOES_NOT_IMPL = Интерфейс делегата не реализован с помощью заявленного типа\: {0}
MSG_EXPECTING_REPRESENTS = Ожидается условие 'represents' для делегата
MSG_EXPECTING_LEFTPAREN_AGGREGATE = Ожидается, что '(' должна открывать агрегатный тип
MSG_EXPECTING_RIGHTPAREN_AGGREGATE = Ожидается, что ')' должна закрывать агрегатный тип
MSG_MEMBER_ACCESS_REQUIRED_FOR_SUPER = Для 'super' необходим доступ к элементу
MSG_ALREADY_CONTAINS_TYPE = Уже указанный тип {0}
MSG_OVERRIDING_FUNCTION_MUST_HAVE_SAME_NUMBER_OF_TYPE_VARS = Чтобы данная функция правильно переопределила свою родительскую функцию, она должна содержать переменные типа {0}
MSG_AGGREGATES_MUST_CONTAIN_MORE = Агрегатный тип должен содержать более одного типа
MSG_INTERFACE_REDUNDANT = Интерфейс {0} избыточный, {1} превышает {0}
MSG_NONTERMINAL_CASE_CLAUSE = Предшествующее условие оператора выбора является нетерминальным; возможно, отсутствует оператор прерывания, продолжения или возврата
MSG_ANONYMOUS_CLASS_NOT_ALLOWED_HERE = Здесь недопустим анонимный класс
MSG_PARAMETERIZED_ARRAY_COMPONENT = Тип компонента параметризованного массива данных теряет параметр[ы] типа во время выполнения
MSG_TEMPLATE_EXCEPTION_GENERATED_SOURCE = Сгенерированный исходный код
MSG_TEMPLATE_MISSING_END_TAG_SCRIPTLET = Отсутствует конечный тег '%>' для скриптлета.
MSG_TEMPLATE_MISSING_END_TAG_EXPRESSION = Отсутствует конечный тег '%>' для выражения.
MSG_TEMPLATE_MISSING_END_TAG_EXPRESSION_ALT = Отсутствует конечный тег '}' для выражения.
MSG_TEMPLATE_MULTIPLE_PARAMS = Найдено несколько директив "params".
MSG_TEMPLATE_INVALID_PARAMS = Неверные параметры\: {0}
MSG_TEMPLATE_UNKNOWN_DIRECTIVE = Неизвестная директива {0}.  Допустимыми директивами являются "params" и "extends".
MSG_EQUALS_FOR_INITIALIZER_EXPR = Ожидается '\=' в данном инициализаторе объекта.
MSG_INITIALIZER_NOT_ALLOWED_ABSTRACT_PROPERTY = Инициализатор для абстрактного свойства не допускается.
MSG_EXPECTING_NAME_VALUE_PAIR = После имени свойства должен следовать '\=' и значения выражения.
MSG_REDUNTANT_INITIALIZERS = Свойство {0} уже имеет некоторое значение инициализатора.
MSG_ONLY_ONE_COLON_IN_INITIALIZERS = Только одно двоеточие может находиться перед именем свойства в инициализаторах.
MSG_EXPECTING_PROPERTY_NAME = Ожидается имя свойства.
MSG_BLOCK_TYPES_SHOULD_HAVE_ARG_NAMES = Параметры типа блока должны указывать имена и находиться в форме 'argName\:Type'.
MSG_DIMENSION_MULTIPLICATION_UNDEFINED = Умножение не определено между измерениями
MSG_DIMENSION_ADDITION_MUST_BE_SAME_TYPE = Оба операнда должны быть измерениями одного типа final
MSG_DIMENSION_DIVIDE_SCALAR_BY_DIMENSION = Деление скаляра на измерение невозможно
MSG_DIMENSION_MUST_BE_FINAL = Арифметика измерения должна включать типы final. {0} не относится к типу final.
MSG_DIMENSION_NONSTANDARD_NUMBER_NO_OVERRIDE = Отсутствуют арифметические методы для таблицы {0} с нестандартным типом номера {1}
MSG_RELATIONAL_OPERATOR_CANNOT_BE_APPLIED_TO_TYPE = Оператор отношения {0} не может быть применен к типу {1}
MSG_ARITHMETIC_OPERATOR_CANNOT_BE_APPLIED_TO_TYPES = Оператор "{0}" нельзя применить к "{1}", "{2}"
MSG_ASSIGNMENTS_MUST_BE_ENCLOSED_IN_CURLIES_IN_BLOCKS = Присваивания в блоке должны быть заключены в фигурные скобки
MSG_BLOCKS_CAN_HAVE_A_MOST_SIXTEEN_ARGS = Блоки могут иметь не более 16 аргументов.
MSG_BLOCKS_LITERAL_NOT_ALLOWED_IN_NEW_EXPR = Литералы блоков недопустимы в новом выражении.
MSG_STATEMENTS_MUST_BE_ENCLOSED_IN_CURLIES_IN_BLOCKS = Операторы "{0}" в блоке должны быть заключены в фигурные скобки
MSG_NOT_AN_ENHANCEABLE_TYPE = {0} не поддерживает расширения.
MSG_CANNOT_REFERENCE_CLASS_TYPE_VAR_IN_STATIC_CONTEXT = Невозможно ссылаться на переменные типа класса в статическом контексте.
MSG_CANNOT_REFERENCE_THIS_IN_STATIC_CONTEXT = Невозможно ссылаться на "это" в статическом контексте.
MSG_CANNOT_CALL_NON_STATIC_METHOD_FROM_STATIC_CONTEXT = Невозможно ссылаться на нестатические методы в статическом контексте.
MSG_CANNOT_REFERENCE_NON_STATIC_PROPERTY_FROM_STATIC_CONTEXT = Невозможно ссылаться на нестатические свойства в статическом контексте.
MSG_CANNOT_REFERENCE_NON_STATIC_FEATURE_HERE = Ссылка на нестатическое свойство здесь недопустима
MSG_ONLY_GOSU_JAVA_TYPES = Здесь разрешены типы только Gosu и Java
MSG_CANNOT_READ_A_WRITE_ONLY_PROPERTY = Свойства, доступные только для записи, могут быть только записаны
MSG_TYPE_IS_NOT_ITERABLE = Ожидается итерируемый тип для оператора расширения - {0}
MSG_INTERVAL_MUST_BE_ITERABLE_HERE = Здесь тип интервала должен быть итерируемым
MSG_EXTRA_DOT_FOUND_IN_INTERVAL = Интервальный оператор имеет две точки, обнаружено три
MSG_EXPECTING_NUMBER_TO_FOLLOW_DECIMAL = Ожидается десятичное число
MSG_IMPROPER_VALUE_FOR_NUMERIC_TYPE = Значение {0} не попадает в область номеров типа {1}
MSG_PRIMITIVE_TYPE_PARAM = Здесь недопустим простой тип {0}. Тип {0} неявно преобразован в {1} как параметр типа. Используйте {1} напрямую.
MSG_CTOR_HAS_XXX_ACCESS = Конструктор имеет {0} доступ
MSG_TYPE_HAS_XXX_ACCESS = Тип {0} имеет доступ {1}
MSG_QUERY_SPECIFY_COLUMN = Укажите столбец запроса
MSG_QUERY_SPECIFY_QUERY_COLUMN = {0} должен определить столбец в базе данных, который можно запросить
MSG_CANNOT_EXTEND_RAW_GENERIC_TYPE = Универсальный тип {0} требует аргумента[ов] типа
MSG_TYPE_VAR_VARIANCE_ERROR = Переменная типа {0} объявлена как "{1}", но используется в позиции "{2}" с типом {3}
MSG_SUPER_CLASS_METHOD_NAME_SAME_AS_SUBCLASS = Метод суперкласса {0} конфликтует с именем внутреннего конструктора данного класса. Измените имя метода суперкласса или имя данного класса.
MSG_NOT_A_SUPERTYPE = {0] не является прямым супертипом
MSG_CALL_TO_SUPER_THIS_MUST_BE_FIRST = Вызов {0}() должен быть первым оператором в конструкторе
MSG_EXPECTING_OPERATOR_TO_FOLLOW_NEW_EXPRESSION = Неполный оператор. После нового выражения должен следовать оператор.
MSG_EXPECTING_TYPE_TO_FOLLOW_PACKAGE_NAME = Ожидается тип после имени пакета
MSG_QUERY_FUNCTION_EXPRESSION_RESTRICTION = Разрешены только ссылки на столбцы базы данных или вызовы метода DBFunction
MSG_QUERY_ORDER_BY_EXPRESSION = Допускаются только выражения доступа к элементу, которые содержат столбцы базы данных.
MSG_QUERY_ARRAYS_NOT_ALLOWED = Доступ к массиву данных здесь не допускается.
MSG_APPLICATION_MODIFIER_HAS_BEEN_DEPRECATED = Модификатор "приложения" устарел. Вместо него используйте сопоставление gw.api.web.Scopes.Application.
MSG_SESSION_MODIFIER_HAS_BEEN_DEPRECATED = Модификатор "сеанса" устарел. Вместо него используйте gw.api.web.SessionVar.
MSG_REQUEST_MODIFIER_HAS_BEEN_DEPRECATED = Модификатор "запроса" устарел. Вместо него используйте gw.api.web.RequestVar.
MSG_EXECUTION_MODIFIER_HAS_BEEN_DEPRECATED = Модификатор "execution" является устаревшим и не имеет значения.  Его можно просто удалить.
MSG_CANNOT_REFERENCE_OUTER_SYMBOL_WITHIN_ENHANCEMENTS = Невозможно ссылаться на внешнее ключевое слово внутри расширений.  Попробуйте переместить этот анонимный класс в класс с именем.
MSG_CANNOT_REFERENCE_ENCLOSING_PROPERTIES_WITHIN_ENHANCEMENTS = Невозможно ссылаться на методы внешнего типа внутри расширений.  Попробуйте переместить этот анонимный класс в класс с именем.
MSG_CANNOT_REFERENCE_ENCLOSING_METHODS_WITHIN_ENHANCEMENTS = Невозможно ссылаться на методы внешнего типа внутри расширений.  Попробуйте переместить этот анонимный класс в класс с именем.
MSG_INVALID_LITERAL = Литерал не может быть конвертирован в {0}.  Требуется построить значение явным образом.
MSG_PROPERTIES_MUST_AGREE_ON_STATIC_MODIFIERS = Механизмы получения и установки свойств должны быть оба статическими или нестатическими
MSG_PROPERTIES_MUST_AGREE_ON_TYPE = Механизмы получения и установки свойств должны согласовать тип свойства
MSG_NO_ENCLOSING_INSTANCE_IN_SCOPE = Нет внешних элементов типа '{0}' в области действия
MSG_EXPECTING_CONDITION_FOR_ASSERT = Ожидание условия для утверждения
MSG_EXPECTING_MESSAGE_FOR_ASSERT = Ожидание сообщение для утверждения
MSG_ASSERTIONS_NOT_ALLOWED_HERE = Выписка утверждения недопустима здесь
MSG_ARRAY_NOT_SUPPORTED = Тип массива данных не поддерживается для {0}
MSG_IMPROPER_USE_OF_KEYWORD = Неверный способ использования ключевого слова, {0}
MSG_USES_STMT_CONFLICT = Тип уже используется, {0}
MSG_USES_STMT_DUPLICATE = Выписка дублированного использования
MSG_ARRAY_INDEX_MUST_BE_INT = Массивы данных должны быть проиндексированы с целочисленным значением
MSG_PARAM_TYPE_CANT_BE_INFERRED_FROM_LATE_BOUND_EXPRESSION = Тип параметра невозможно вывести из последнего типа связанного выражения
MSG_LOSS_OF_PRECISION_IN_NUMERIC_LITERAL = Этот двойной литерал теряет точность в данной операции.  Необходимо явно объявить его как BigDecimal вместо\: {0}
MSG_COMPILE_TIME_ANNOTATION_FAILED_TO_EXECUTE = Не удалось выполнить аннотацию времени компиляции.  Сообщение было {0}.  См. консоль для трассировки стека.
MSG_METHOD_REIFIES_TO_SAME_SIGNATURE_AS_ANOTHER_METHOD = Метод с таким же именем реализует ту же подпись на уровне байт-кода.  Переименуйте один из методов.
MSG_TYPE_NOT_REIFIED = {0} должен быть объявлен только с модификатором "reified" для доступа к переменной типа "{1}" при выполнении.
MSG_REIFIED_DONT_MATCH = Должна переопределяться функция с той же настройкой "reified"
MSG_REIFIED_DONT_MATCH_JAVA = Реализованный универсальный метод {0} переопределяет метод Java в {1}. При вызове {0} из {1} стираются параметры типа.
NOTHING_TO_REIFY = Элементы для воплощения отсутствуют
MSG_PROPERTY_AND_FUNCTION_CONFLICT = Метод {0} конфликтует с неявными методами, созданными свойством {1}
MSG_PROPERTY_AND_FUNCTION_CONFLICT_UPON_REIFICATION = Метод {0} конфликтует с неявными методами, созданными свойством {1} после материализации
MSG_CANNOT_OVERRIDE_FUNCTION_FROM_ENHANCEMENT = Невозможно переопределить метод, определенный в расширении.
MSG_MASKING_ENHANCEMENT_METHODS_MAY_BE_CONFUSING = Данный метод маскирует метод, определенный для расширения в этом типе.  Это может привести к неожиданной семантике, поскольку методы расширения отправляются статически.
MSG_STRING_COERCION_ON_RHS_OF_ADDITIVE_EXPRESSION_MUST_BE_PARENTHESIZED = Преобразование типа в строку в аддитивном выражении может привести к путанице.  Для правильной оценки заключите выражение в скобки.
MSG_EXPLICIT_TYPE_RECOMMENDED_FOR_CATCH_STMTS = Здесь необходимо добавить явно захваченный тип.
MSG_SUPER_NOT_ACCESSIBLE_FROM_BLOCK = Супер-символ недоступен внутри блоков.
MSG_GENERIC_PROPERTIES_NOT_SUPPORTED = Свойства не могут содержать переменные типа.
MSG_GENERIC_ANNOTATIONS_NOT_SUPPORTED = Аннотации не могут содержать переменные типа.
MSG_CATCH_STMT_CANNOT_EXECUTE = Этот оператор catch не будет выполняться, поскольку предыдущий оператор catch уже захватывает исключения из этого типа.
MSG_IMONITOR_LOCK_SHOULD_ONLY_BE_USED_WITHIN_USING_STMTS = Интерфейс IMonitorLock может использоваться только внутри операторов в виде выражения для синхронизации устаревшего стиля.
MSG_STATIC_MODIFIER_NOT_ALLOWED_HERE = Модификатор 'static' здесь недопустим.
MSG_MODIFIERS_NOT_ALLOWED_HERE = Модификаторы здесь не допускаются.
MSG_CANNOT_INSTANTIATE_NON_STATIC_CLASSES_HERE = Здесь невозможно создать экземпляр нестатического класса.
MSG_WARN_ON_SUSPICIOUS_THIS_COMPARISON = Похоже, это плохое сравнение.  В gosu оператор '\=\=' эквивалентен .equals().  Если требуется установить эквивалентность экземпляра, используйте вместо этого оператор '\=\=\='.
MSG_FL_EXPECTING_FEATURE_NAME = Здесь ожидается имя функции, имя метода, свойства или 'construct'
MSG_FL_EXPECTING_RIGHT_CARET = Ожидается '>'
MSG_FL_GENERIC_FUNCTION_REFERENCES_NOT_YET_SUPPORTED = Общие литералы функций пока не поддерживаются.
MSG_FL_EXPECTING_RIGHT_PAREN = Ожидается, что ')' должна закрывать список типов аргументов.
MSG_FL_CONSTRUCTOR_NOT_FOUND = Конструктор с типами {0} не найден
MSG_FL_METHOD_NOT_FOUND = Метод с именем {0} и типами {1} не найден
MSG_FL_PROPERTY_NOT_FOUND = Свойство с именем {0} не найдено
MSG_FL_STATIC_FEATURES_MUST_BE_REFERENCED_FROM_THEIR_TYPES = Статическая функция или конструктор должны ссылаться непосредственно на тип, к которому принадлежит функция.
MSG_NO_TYPE_AFTER_CONSTRUCTOR = Конструкторы не могут указывать тип возвращаемого значения.
WS_ERR_Can_Not_Marshal = {0}Невозможно сортировать локальный тип {2} для {1}.
WS_ERR_Annotation_Duplicate_Namespace = В {0}\: дубликат использования пространства имен "{1}" уже используется в "{2}". {3} еще раз попытается добавить его в {4}.
WS_ERR_Annotation_Exception = Будет игнорировать свойства типа {0} см. журнал для ознакомления с трассировкой стека
WS_ERR_Annotation_Invalid_Namespace = {0}\: Недопустимое пространство имен "{1}"
WS_ERR_Annotation_Only_For_WebService = {0}\: Аннотация @{1} может использоваться только в классах с аннотацией @WsiWebService
WS_ERR_Annotation_Operation_Duplicate = В {0}\: метод {1} уже существует метод с таким именем
WS_ERR_Annotation_Operation_OneWay_Invalid = Односторонние методы должны иметь пустой тип возвращаемого значения
WS_ERR_Annotation_Operation_Response_Reserved = В {0}\: метод {1}, суффикс 'Response' зарезервирован для элементов ответа
WS_ERR_Export_Inner_Only_On_WebService = Внутренние классы в {0}\: типа {1} не могут быть экспортированы
WS_ERR_Export_Inner_Not_Name_Of_Method = Внутренние классы имеют то же имя, что и запрос для метода {0}
WS_ERR_Export_Inner_Not_Name_Of_Response = Внутренние классы имеют такое же имя, как и ответ для метода {0}
WS_ERR_Export_No_Constructor = В {0}\: тип {1} экспортируемому классу нужен открытый конструктор по умолчанию
WS_ERR_Export_No_Extends = В {0}\: тип {1} экспортируемый класс не может расширять другой класс
WS_ERR_Export_Not_Final = В {0}\: тип {1} не является заключительным. Экспортируемый класс должен быть заключительным (final)
WS_ERR_Export_Not_WebService = В {0}\: тип {1} является веб-службой. Веб-служба не может быть экспортирована
WS_ERR_Export_Recursive = Рекурсия не поддерживается. Необходимо убедиться, что {0} не является рекурсивным
WS_WARN_Annontation_Some_Generators_Dont_Support_Schema = {0} Предупреждение обработки параметра {1}, некоторые структуры веб-служб могут не понять {2}
WS_WARN_Annontation_Not_Available = {0} недоступна до {1}
WS_WARN_Ignored = {0}\: свойство {1} типа {2} будет игнорироваться
PCF_ERR_Verify = При попытке подтвердить {0} произошла ошибка PCF.
MSG_FL_ONLY_PROPERTIES_MAY_BE_CHAINED = Только литералы свойства могут связываться в цепочку.
Gen_Wsi_InvalidType = {0} не может сортировать {1}\: {2}
Gen_Wsi_UnsupportedType = {0} является корректным типом, но не поддерживается веб-службами.
Gen_Wsi_UnsupportedComponentType = {0} не поддерживается, поскольку тип компонента/параметра не поддерживается.
Gen_Wsi_NoComponentType = {0} не поддерживается, поскольку тип компонента/параметра не задан.
Gen_Wsi_NoBase = {0} класс XmlBase напрямую не поддерживается.
Gen_Wsi_AnonElement = 0} Анонимные элементы не поддерживаются. Анонимные элементы являются дочерними по отношению к другому элементу. Можно воспользоваться типом дочернего элемента.
Gen_Wsi_AnonType = {0} Анонимные типы (типы, объявленные в декларации элементов), не поддерживаются. Попробуйте использовать элемент.
Gen_Wsi_NoSimple = {0} Простые типы XSD не поддерживаются. Попробуйте создать сложный тип или использовать расширенный тип.
Gen_Wsi_XmlError = Обработка неожиданной ошибки {0}\: {1}
Gen_Wsi_NullType = Передан нулевой тип
Gen_Wsi_TypeNotGosu = {0} не относится к gosu и потому не поддерживается реализацией wsi.
Gen_Wsi_TypeNotWSAnnotated = {0} не имеет аннотации @WsiWebService.
Gen_Wsi_TypeNotEXPAnnotated = {0} не имеет аннотации @WsiExportable.
GEN_CAN_NOT_MARSHAL_GOSU_REMOTEABLE_ENUMS = {0} не может сортировать GWEnumerations, написанные на Gosu
GEN_CAN_NOT_MARSHAL_REMOTEABLE_ENUMS_EXTENDED = {0} не может сортировать GWEnumerations с дополнительными свойствами
GEN_CAN_NOT_MARSHAL_XML_IN_EXPORTABLE = {0} не может сортировать xml в типах WsiExportable
GEN_CLASS_CANNOT_BE_BOTH_WS_AND_EXPORT = Класс {0} не может быть одновременно @WsiWebService и {1}
GEN_CHECKING = Проверка {0}
GEN_CHANGED = Изменено {0}
WS_ERR_Invalid_Supertype = {0} не расширяет {1}
WS_ERR_Export_Empty = {0} не имеет экспортируемых свойств
WS_ERR_Previous_Invalid = {0} является некорректным. Ошибки были сообщены ранее
WS_ERR_Entity_Invalid = {0} не является корректным. Сортировка объектов не поддерживается, создайте класс WsiExportable с требуемыми полями.
WS_ERR_Collection_Invalid = {0} является некорректным. Поддерживаются только массивы и список <T>.
WF_WARN_Subtype = Подтип бизнес-процесса "{0}" определен как невнешний, но либо никакие скрипты не заданы, либо произошел сбой анализа скрипта. Проверьте журналы на наличие ошибок анализа.
WF_ERR_Duplicate = Существует больше одного процесса, заданного с идентичным кодом типа "{0}" и версией "{1}".
WF_ERR_Parse = Не удалось проанализировать "{0}" — {1}\: {2}
WF_ERR_Convert = Не удалось преобразовать "{0}" — {1}\: {2}
WF_ERR = В "{0}"\: {1}

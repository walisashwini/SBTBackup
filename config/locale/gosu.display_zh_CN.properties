ARRAY = 数组
BEAN = Bean
BOOLEAN = 布尔
DATETIME = 日期时间
FUNCTION = 函数
IDENTIFIER = 标识符
METATYPENAME = 类型
NULLTYPENAME = Null
NUMERIC = 编号
STRING = 字符串
MSG_SYNTAX_ERROR = 语法错误。
MSG_BAD_IDENTIFIER_NAME = 无法解析符号： {0}
MSG_END_OF_STMT = 需要语句结尾。可能存在不正确的运算符或缺少运算符。
MSG_END_OF_EXPRESSION = 需要表达式结尾。可能存在不正确的运算符或缺少运算符。
MSG_EXPECTING_OPERATOR_TO_FOLLOW_EXPRESSION = 语句不完整。表达式后需加运算符。
MSG_EXPECTING_ARGS = 函数{0}需要实际参数
MSG_EXPECTING_EXPRESSION_CLOSE = 需要使用“)”结束括号表达式。
MSG_EXPECTING_FUNCTION_CLOSE = 需要使用“)”结束函数调用。
MSG_EXPECTING_TYPE_NAME = 需要类型名称。
MSG_PARAMETERIZATION_NOT_SUPPORTED_FOR_TYPE = {0}不支持参数化。
MSG_NO_ARGUMENTS = 函数{0}不接受实际参数。
MSG_NULL_SYMBOL_TABLE = 符号表为null或为空。
MSG_TYPE_MISMATCH = 类型“{1}”无法转换为“{0}”
MSG_VALUE_MISMATCH = 值不匹配。文本值“{0}”无法转换为{1}。
MSG_WRONG_NUM_OF_ARGS = 函数{0}的实际参数数量不正确
MSG_EXPECTING_NAME_FUNCTION_DEF = 需要函数的名称。
MSG_EXPECTING_LEFTPAREN_FUNCTION_DEF = 需要使用“(”开始函数形式参数声明。
MSG_EXPECTING_RIGHTPAREN_FUNCTION_DEF = 需要使用“)”结束函数参数声明。
MSG_EXPECTING_TYPE_FUNCTION_DEF = 需要为函数声明使用“\:”子句。
MSG_EXPECTING_TYPE_LITERAL_FUNCTION_DEF = 对于函数声明，需要在“\:”后指定类型。
MSG_EXPECTING_IDENTIFIER_FOREACH = “for...in”语句需要标识符。
MSG_EXPECTING_IDENTIFIER_FOREACH_INDEX = “for...in”语句的“index”中需要标识符。
MSG_EXPECTING_IDENTIFIER_FOREACH_ITERATOR = “for...in”语句的“iterator”中需要标识符。
MSG_FOREACH_ITERATOR_NOT_ALLOWED = 没有循环变量的情况下，“for...in”语句中不允许使用“迭代器”。
MSG_ITERATOR_SYMBOL_ONLY_SUPPORTED_ON_ITERABLE_OBJECTS = 只有可迭代对象支持“iterator”符号。
MSG_EXPECTING_IDENTIFIER_EXISTS = “exists”表达式需要标识符
MSG_EXPECTING_IDENTIFIER_EXISTS_INDEX = “exists”表达式的“index”中需要标识符。
MSG_EXPECTING_IN_FOREACH = “for...in”语句需要“in”子句。
MSG_EXPECTING_LEFTPAREN_FE = “for...in”语句中需要“(”。
MSG_EXPECTING_RIGHTPAREN_FE = “for...in”语句中需要“)”。
MSG_EXPECTING_LEFTPAREN_BLOCK = 块类型声明中需要“(”。
MSG_EXPECTING_RIGHTPAREN_BLOCK = 块类型声明中需要“)”。
MSG_EXPECTING_COLON_BLOCK = 块类型声明中需要“\:”。
MSG_EXPECTING_IN_EXISTS = “exists”表达式需要“in”子句。
MSG_EXPECTING_WHERE_EXISTS = “exists”表达式需要“where”子句。
MSG_EXPECTING_LEFTPAREN_EXISTS = “exists”表达式中需要“(”。
MSG_EXPECTING_RIGHTPAREN_EXISTS = “exists”表达式中需要“)”。
MSG_EXPECTING_LEFTPAREN_EVAL = 需要使用“(”打开“eval”表达式。
MSG_EXPECTING_RIGHTPAREN_EVAL = 需要使用“)”结束“eval”表达式。
MSG_EXPECTING_LEFTPAREN_CATCH = “try...catch...finally”语句的“catch”子句中需要“(”。
MSG_EXPECTING_RIGHTPAREN_CATCH = “try...catch...finally”语句的“catch”子句中需要“)”。
MSG_EXPECTING_IDENTIFIER_CATCH = “try...catch...finally”语句的“catch”子句中需要标识符。
MSG_CATCH_OR_FINALLY_REQUIRED = “try...catch...finally”语句中需要“catch”或“finally”子句。
MSG_EXPECTING_LEFTBRACE_STMTBLOCK = 需要使用“{”开始语句块。
MSG_EXPECTING_RIGHTBRACE_STMTBLOCK = 需要使用“}”结束语句块。
MSG_EXPECTING_LEFTPAREN_IF = 需要使用“(”开始“if”条件。
MSG_EXPECTING_RIGHTPAREN_IF = 需要使用“)”结束“if”条件。
MSG_EXPECTING_LEFTPAREN_SWITCH = 需要使用“(”打开“switch”表达式。
MSG_EXPECTING_RIGHTPAREN_SWITCH = 需要使用“)”结束“switch”表达式。
MSG_EXPECTING_LEFTPAREN_WHILE = 需要使用“(”开始“while”条件。
MSG_EXPECTING_RIGHTPAREN_WHILE = 需要使用“)”结束“while”条件。
MSG_EXPECTING_LEFTPAREN_EXCEPT = 需要使用“(”开始“except”条件。
MSG_EXPECTING_RIGHTPAREN_EXCEPT = 需要使用“)”结束“except”条件。
MSG_EXPECTING_WHILE_DO = 需要使用“while”子句结束“do...while”语句。
MSG_LOOP_DOESNT_LOOP = 代码循环未重复
MSG_EXPECTING_EQUALS_ASSIGN = 赋值语句需要“\=”。
MSG_EXPECTING_EXPRESSSION_ON_RHS = 赋值语句需要有效的右侧表达式。
MSG_EXPECTING_STATEMENT = 需要使用语句。
MSG_EXPECTING_BEANTYPE = 需要为成员访问使用复杂类型。找到： {0}
MSG_EXPECTING_ARRAYTYPE_FOREACH = “for...in”语句的“in”子句后需要使用可迭代类型。已找到：{0}
MSG_EXPECTING_ARRAYTYPE_EXISTS = “exists”表达式的“in”子句后需要使用“数组”类型。找到\:
MSG_EXPECTING_IDENTIFIER_ARG_TYPE = 函数参数的“\:”后需要类型名称。
MSG_EXPECTING_ARRAY_BRACKET = 需要使用“]”结束数组类型文本。
MSG_EXPECTING_NEW_ARRAY_OR_CTOR = 需要使用“[”或“(”开始一个新数组或对象操作。
MSG_EXPECTING_OPEN_BRACE_FOR_NEW_ARRAY = 需要使用“{{”开始数组值表达式列表。
MSG_EXPECTING_CLOSE_BRACE_FOR_NEW_ARRAY = 需要使用“}”结束数组值表达式列表。
MSG_EXPECTING_CLOSING_ANGLE_BRACKET_FOR_TYPE = 需要使用“>”结束参数化类型文本。
MSG_EXPECTING_CLOSING_ANGLE_BRACKET_FOR_TYPE_VAR_LIST = 需要使用“>”结束类型变量列表。
MSG_COULD_NOT_PARAMETERIZE = 无法参数化。
MSG_EXPECTING_OPEN_BRACE_FOR_SWITCH = 需要使用“{{”打开“switch”语句。
MSG_EXPECTING_CLOSE_BRACE_FOR_SWITCH = 需要使用“}”结束“switch”语句。
MSG_EXPECTING_COLON_TERNARY = 三元条件表达式需要“\:”。
MSG_EXPECTING_REFERENCE_TYPE = 需要引用类型，此处不允许基元类型。
MSG_LOSS_OF_PRECISION_IN_CONDITIONAL_EXP = 无法在不损失精度的情况下转换类型。请显式转换它们。
MSG_EXPECTING_CASE_COLON = 块类型声明中结束“case”表达式。
MSG_DUPLICATE_CASE_EXPRESSION = 复制case表达式。
MSG_TYPE_MISMATCH_IN_CONDIITIONAL_EXP = 三元条件表达式中的类型不匹配。
MSG_EXPECTING_IDENTIFIER_VAR = 需要变量名称。
MSG_EXPECTING_VAR_STMT = 需要“var”声明。
MSG_EXPECTING_TYPELITERAL = 表达式的右侧需要类型文本。
MSG_EXPECTING_TYPELITERAL_OR_NAMESPACE = 需要类型文本或命名空间。
MSG_PRIMITIVES_NOT_ALLOWED_HERE = 此处不支持基元类型。
MSG_INCONVERTIBLE_TYPES = 不可转换类型；无法将{0}转换为{1}
MSG_BAD_NAMESPACE = {0}不是有效命名空间。
MSG_EXPECTING_ARRAYLENGTH = 需要“length”数组属性。
MSG_ENTITYBEANS_ARE_IMMUTABLE = 不能直接修改对象属性。
MSG_MULTIPLE_DEFAULT_CLAUSES_NOT_PERMITTED = 在“switch”语句中检测到多个“default”子句。
MSG_CASE_CLAUSE_MAY_NOT_FOLLOW_DEFAULT_CLAUSE = case子句不能接“default”子句。
MSG_METHOD_NOT_VISIBLE = 在分析器的可见性约束下，函数“{0}”不可见。
MSG_PROPERTY_NOT_VISIBLE = 在分析器的可见性约束下，属性“{0}”不可见。
MSG_OBJECT_RETIRED = ID“{0}”引用了已注销的对象。
MSG_OBJECT_LITERALS_DEPRECATED = 不建议使用实体文本，请改用查询构建器。
MSG_DEPRECATED_MEMBER = {1}中的{0}已不推荐使用。
MSG_EXPECTING_ENTITY_TYPE = “find”表达式中需要实体类型名称。
MSG_EXPECTING_QUERY_PATH = 需要查询路径表达式。
MSG_QUERY_PATH_MUST_BEGIN_WITH = 查询路径表达式必须以“{0}”开头
MSG_EXPECTING_CONDITIONAL_EXPRESSION = 需要条件表达式，如“a > b”
MSG_CONDITIONAL_EXPRESSION_EXPECTS_BOOLEAN = 需要使用布尔值。
MSG_EXPECTING_IDENTIFIER_FIND = “find”表达式需要标识符
MSG_EXPECTING_IN_FIND = “find”表达式需要“in”子句。
MSG_EXPECTING_WHERE_FIND = “find”表达式需要“where”子句。
MSG_EXPECTING_LEFTPAREN_FIND = “find”表达式中需要“(”。
MSG_EXPECTING_RIGHTPAREN_FIND = “find”表达式中需要“)”。
MSG_QUERYPATH_MUST_BEGIN_WITH = 查询路径必须以其父查询表达式“{0}”开头。
MSG_QUERY_IN_LHS_OP_NOT_ENTITY = {0}不会解析成实体类型。“in”运算符的左侧需要实体类型属性。
MSG_QUERY_IN_LHS_OP_NOT_ARRAY = {0}没有合适的数组类型。“in”运算符的左侧需要具有有效数组类型的实体类型属性。
MSG_QUERY_EXPECTED_BOOLEAN_EXPRESSION = {0}不是布尔表达式。
MSG_EXPECTING_READONLY_ENTITY_TYPE = “find”仅限只读实体类型。设置“allow-entity-queries”注册表元素以查找可写实体。
MSG_STR_IMMUTABLE = 字符串不可变，无法进行修改。
MSG_UNTERMINATED_STRING_LITERAL = 未终止的字符串文本。需要"。
MSG_INVALID_CHAR_AT = 位置{0}处存在非法转义符
MSG_FUNCTION_CLASH_PARAMS = “{1}”中的“{0}”与“{3}”中的“{2}”冲突；两个函数具有相同的删除作用，但都不覆盖对方
MSG_UNTERMINATED_COMMENT = 未终止的注释。需要“*/”。
MSG_UNEXPECTED_EOF = 意外的文件结尾
MSG_FUNCTION_ALREADY_DEFINED = {0}，已定义在{1}
MSG_FUNCTION_CLASH = “{1}”中的“{0}”与“{3}”中的“{2}”冲突；返回类型不兼容。
MSG_ATTEMPTING_TO_ASSIGN_WEAKER_ACCESS_PRIVILEGES = “{1}”中的“{0}”与“{3}”中的“{2}”冲突：尝试指定较低的访问权限。
MSG_CANNOT_OVERRIDE_FINAL = 无法从“{1}”覆盖最终成员“{0}”
MSG_CANNOT_ASSIGN_VALUE_TO_FINAL_VAR = 无法为最终变量“{0}”分配值
MSG_VAR_MIGHT_NOT_HAVE_BEEN_INIT = 变量“{0}”可能未初始化
MSG_VAR_MIGHT_ALREADY_HAVE_BEEN_INIT = 变量“{0}”可能已初始化
MSG_VAR_MIGHT_ALREADY_HAVE_BEEN_INIT_LOOP = 变量“{0}”可能已在循环中初始化
MSG_FUNCTION_ALREADY_DEFINED_IN_EXTENDED_CLASS = 已定义{0}。扩展无法覆盖函数。
MSG_DUPLICATE_CLASS_FOUND = 在此处找到重复类： {0}。
MSG_DUPLICATE_TYPE_FOUND = 在{0}处找到重复类型。
MSG_DUPLICATE_ENHANCEMENT_FOUND = 在此处找到重复增强： {0}。
MSG_EXPECTING_OPEN_BRACE_FOR_CLASS_DEF = 需要使用“{{”开始“class”语句。
MSG_EXPECTING_CLOSE_BRACE_FOR_CLASS_DEF = 需要使用“}”结束“class”语句。
MSG_EXPECTING_NAME_CLASS_DEF = 需要类的名称。
MSG_EXPECTING_ENHANCEMENT_DEF = 需要增强。
MSG_NAMESPACE_CLASS_CONFLICT = 类的目录路径与包名称不符。
MSG_NO_SUCH_FUNCTION = 没有为{0}定义任何函数。
MSG_CANNOT_EXTEND_PRIMITIVE_TYPE = 无法扩展基元类型{0}。
MSG_CANNOT_EXTEND_FINAL_TYPE = 无法扩展最终类型{0}。
MSG_ENHANCEMENTS_CANNOT_ENHANCE_OTHER_ENHANCEMENTS = 无法对增强{0}进行增强。
MSG_CYCLIC_INHERITANCE = 涉及{0}的循环继承。
MSG_EXPECTING_OPEN_BRACE_FOR_CONSTRUCTOR_DEF = 需要使用“{{”作为构造函数主体的开头。
MSG_EXPECTING_OPEN_BRACE_FOR_FUNCTION_DEF = 需要使用“{{”作为函数主体的开头。
MSG_EXPECTING_CLOSE_BRACE_FOR_FUNCTION_DEF = 需要使用“}”作为函数主体的结尾。
MSG_EXPECTING_CLOSE_BRACE_FOR_CONSTRUCTOR_DEF = 需要使用“}”作为构造函数主体的结尾。
MSG_NO_DEFAULT_CTOR_IN = {0}中没有默认构造函数。
MSG_WRONG_NAMESPACE = 包名称“{0}”与目录“{1}”不对应。
MSG_WRONG_CLASSNAME = 类名称{0}与文件{1}不对应。
MSG_SAME_NAME_AS_CLASS = “{0}”已定义为此文件的类名称
MSG_EXPECTING_PROPERTY_GET_OR_SET_MODIFIER = 属性需要“get”或“set”修饰符。
MSG_EXPECTING_NAME_PROPERTY = 变量需要属性名称。
MSG_PROPERTY_ALREADY_DEFINED = 已定义属性“{0}”。
MSG_GETTER_FOR_PROPERTY_ALREADY_DEFINED = 已为“{0}”定义属性“get”函数。
MSG_SETTER_FOR_PROPERTY_ALREADY_DEFINED = 已为“{0}”定义属性“set”函数。
MSG_PROPERTY_NOT_WRITABLE = “{0}”不可写。
MSG_CLASS_PROPERTY_NOT_READABLE = 类“{1}”的属性“{0}”不可读。
MSG_CLASS_PROPERTY_NOT_WRITABLE = 类“{1}”的属性“{0}”不可写。
MSG_NO_VIEWS_FOR_YOUS = 视图不受支持。考虑对“{0}”进行查询
MSG_VARIABLE_ALREADY_DEFINED = 已定义{0}。请使用不同的名称。
MSG_FUNCTION_DECL_MISSING = 内部错误。无法找到{0}的声明函数符号。
MSG_EXPECTING_DEFAULT_VALUE = 需要使用默认值分配。必需形式参数应先于可选形式参数。
MSG_DEFAULT_VALUE_NOT_ALLOWED = 此处不允许使用默认值
MSG_COMPILE_TIME_CONSTANT_REQUIRED = 此处表达式必须为编译时常量。
MSG_OVERLOADING_NOT_ALLOWED_WITH_OPTIONAL_PARAMS = 不允许对可选形式参数进行重载
MSG_MISSING_REQUIRED_ARGUMENTS = 缺少一个或多个必需实际参数
MSG_ARGUMENT_ALREADY_DEFINED = 实际参数已定义
MSG_EXPECTING_NAME_PARAM = 形式参数需要名称
MSG_EXPECTING_NAMED_ARG = 需要使用已命名的实际参数
MSG_PARAM_NOT_FOUND = 未找到形式参数
MSG_VARIABLE_REQUEST_DOES_NOT_ALLOW_VALUE = ，请求变量不能具有初始值。
MSG_VARIABLE_TYPE_OR_VALUE_REQUIRED = “var”语句需要“as”和/或“\:”。
MSG_VARIABLE_MUST_HAVE_NON_NULL_TYPE = 变量必须具有非空类型。为此变量添加一个显式类型。
MSG_CONDITION_IS_ALWAYS_TRUE_FALSE = 条件始终是{0}
MSG_VOID_NOT_ALLOWED = 此处不允许“void”类型
MSG_FUNCTIONS_NOT_ALLOWED_IN_THIS_CONTEXT = 此上下文中不允许函数声明
MSG_CONSTRUCTORS_NOT_ALLOWD_IN_THIS_CONTEXT = 此上下文中不允许使用构造函数
MSG_INNER_CLASSES_NOT_ALLOWED_IN_THIS_CONTEXT = 此上下文中不允许内部类声明
MSG_NO_SOURCE_FOUND = 没有为类找到源。
MSG_CANNOT_RETURN_VALUE_FROM_VOID = 无法从void函数返回值。
MSG_RETURN_NOT_ALLOWED_HERRE = 此处不允许返回声明。
MSG_MISSING_RETURN_VALUE = 缺少返回值。
MSG_EXPECTING_DECL = 变量、函数或属性需要声明。
MSG_FUNCTION_ARG_NAME_CONFLICTS_WITH_CLASS_VAR = 函数{1}的实际参数“{0}”与某个类字段冲突。
MSG_EXPECTING_ARROW_AFTER_BLOCK_ARGS = 块实际参数声明后需要接“->”。
MSG_EXPECTING_CLOSE_BRACE_FOR_BLOCK = 块语句列表后需要接“}”。
MSG_EXPECTING_ARROW_AFTER_MAP_KEY = 块实际参数声明后需要接“->”。
MSG_UNEXPECTED_ARROW = 列表初始化程序中意外出现“->”
MSG_EXPECTING_CLOSE_BRACE_FOR_INITIALIZER = 初始化程序语句后需要接“}”。
MSG_MODIFIER_ABSTRACT_NOT_ALLOWED_HERE = 此处不允许使用修饰符“abstract”。
MSG_ABSTRACT_METHOD_CANNOT_BE_ACCESSED_DIRECTLY = 不能直接访问抽象方法{0}
MSG_NOT_ALLOWED_IN_INTERFACE = 不允许在接口中使用。
MSG_UNIMPLEMENTED_METHOD = {0}函数未实现： {1}
MSG_INHERITS_UNRELATED_DEFAULTS = {0} 从{2}和{3}继承{1}的不相关默认值
MSG_INHERITS_ABSTRACT_AND_DEFAULT = {0} 从{2}和{3}继承{1}的抽象和默认方法
MSG_INTERFACE_CANNOT_EXTEND_CLASS = 单个接口不能扩展类，只有多个接口才能进行扩展。
MSG_CLASS_CANNOT_EXTEND_INTERFACE = 类不能“扩展”接口。
MSG_CANNOT_EXTEND_ARRAY = “类不能‘扩展’数组”。
MSG_CLASS_MUST_HAVE_PACKAGE = 类必须具有包。
MSG_CLASS_CANNOT_IMPLEMENT_CLASS = 类不能“实现”类。
MSG_ENUM_CANNOT_EXTEND_CLASS = 枚举不能扩展类
MSG_ENUM_CANNOT_HAVE_ANNOTATIONS = 枚举常量不能包含批注
MSG_ENUM_CONSTRUCTOR_MUST_BE_PRIVATE = 枚举构造函数必须被声明为私有
MSG_ENUM_CONSTRUCTOR_NOT_ACCESSIBLE = 此处无法使用枚举构造函数
MSG_ENUM_MAY_NOT_HAVE_TYPEPARAM = 枚举可能没有类型形式参数
MSG_BAD_CAPTURE_TYPE = 块不支持对此类符号的词汇引用。在块外部指定一个局部变量对其进行引用。
MSG_POTENTIALLY_BAD_CAPTURE = 此标识符捕获到并不完全支持“范围外”捕获的外部变量。如果标识符在最外层封闭函数范围之外进行计算，则可能会导致运行时错误。
MSG_CANNOT_CAPTURE_SYMBOL_IN_BLOCK_IN_ANON_CLASS = 您无法在嵌入匿名类的块中捕获符号。
MSG_CANNOT_CAPTURE_SYMBOL_IN_ANON_CLASS_IN_BLOCK = 您无法在嵌入块的匿名类中捕获符号。
MSG_EXPECTING_ENHANCE_KEYWORD = 需要“增强”
MSG_NON_PRIVATE_MEMBERS_MUST_DECLARE_TYPE = 非私有数据成员必须显式声明类型。
MSG_DELEGATES_CANNOT_BE_STATIC = 委派不能为静态。
MSG_DELEGATE_METHOD_CONFLICT = 委派成员冲突：{0}和{1}。请显式实现该成员以解决冲突。
MSG_DELEGATES_SHOULD_NOT_SELF_DELEGATE = 委派不应进行自委派。
USING_INTERNAL_CLASS = 这是以后将会更改的内部类。使用此类<b>很危险且不受支持</b>。
MSG_EXTENSION_CLASS_NOT_FOUND = 无法找到要扩展的类{0}。
MSG_CANNOT_DEREF_PROPERTIES_IN_WHERE = 无法在where子句中取消对属性的引用。考虑使用“exists”子句。
MSG_CANNOT_CALL_METHOD_WITH_WILDCARD_PARAM = 无法调用带通配符形式参数的函数。
MSG_NO_WILDCARDS = 通配符在Gosu中已不建议使用。请将类型参数替换为“{0}”
MSG_EXPECTING_COLON_ENHANCEMENT = 增强中需要“\:”。
MSG_EXPECTING_CLOSE_BRACKET_FOR_LIST_LITERAL = 列表文本的结尾需要“]”。
MSG_CANNOT_PARAMETERIZE_NONGENERIC = 无法参数化非泛型类型。
MSG_TYPE_PARAM_NOT_ASSIGNABLE_TO = 类型形式参数{0}不可指定给边界类型{1}。
MSG_TYPE_NOT_ANNOTATION = 类型{0}不是批注。它必须为一个java批注或实现接口gw.lang.IAnnotation
MSG_MISPLACED_META_ANNOTATION = 此批注只能用于批注类。
MSG_MISPLACED_ANNOTATION = 此批注不能用于批注类。
MSG_ANNOTATION_WHEN_NONE_ALLOWED = 批注“{0}”不允许出现在{1}声明中。
MSG_ANNOTATION_USE_SITE_TARGET_NOT_ALLOWED_HERE = 注释“{0}”对于上下文的使用站点目标“{1}”无效。
MSG_TOO_MANY_ANNOTATIONS = 批注“{0}”只能在{1}声明中出现一次。
MSG_EXPECTING_COLON_ANNOTATION = 预期通过“\:”分隔使用站点目标和注释类型。
MSG_INVALID_TYPE = “{0}”不是有效类型。
MSG_INVALID_GENERIC_EXCEPTION = 通用类不能扩展“java.lang.Throwable”
MSG_INVALID_INNER_TYPE = “{1}”中未找到内部类“{0}”。
MSG_INVALID_TYPE_WITH_QUALIFIED_NAME = “{0}”具有无效类型：“{1}”。
MSG_NOT_A_STATEMENT = 不是语句。
MSG_CANNOT_CONSTRUCT_ABSTRACT_CLASS = “{0}”是抽象的，不能进行构造。
MSG_CANNOT_CONSTRUCT_RECURSIVE_CLASS = “{0}”是递归的，不能直接进行构造。
MSG_RECURSIVE_CONSTRUCTOR = 递归构造函数调用。
MSG_MISSING_RETURN = 缺少返回声明。
MSG_UNREACHABLE_STMT = 不可到达的语句。
MSG_BREAK_OUTSIDE_SWITCH_OR_LOOP = 此处不允许中断语句。
MSG_CONTINUE_OUTSIDE_LOOP = 此处不允许继续语句。
MSG_PROPERTY_SET_MUST_HAVE_ONE_PARAMETER = 属性设置函数必须只具有一个形式参数。
MSG_PROPERTY_SET_MUST_RETURN_VOID = 属性设置函数必须返回void。
MSG_MISSING_PROPERTY_RETURN = 缺少属性返回类型。
MSG_IMPLICIT_COERCION_WARNING = 此处出现了从类型{0}到{1}的隐式强制转换。考虑用“as {1}”将其变为显式。
MSG_IMPLICIT_COERCION_ERROR = 必须使用“as”关键字显式将{0}强制为{1}。
MSG_ASYMMETRICAL_COMPARISON = {0}与{1}的比较不对称。考虑转换其中一个操作。
MSG_SILLY_ASSIGNMENT = 此处出现了从{0}到其自身的无用赋值。可能是由于程序错误无意造成的。
MSG_UNUSED_VARIABLE = 此{0}未使用。
MSG_LIKELY_JAVA_CAST = 似乎要尝试执行java形式的转换，这不是正确的Gosu。要将表达式转换为其它类型，请在表达式后使用“as {0}”
MSG_UNEXPECTED_TOKEN = 意外的令牌：{0}
MSG_EXPECTING_INT_ACCESS_TO_ARR_ETC = 需要使用int访问带数组[]运算符的数组、集合或字符串类型。
MSG_EXPECTING_BEAN_TYPE_WITH_REFLECTION_OPERATOR = 需要带[]反射运算符的bean类型。
MSG_PROPERTY_REFLECTION_ONLY_WITH_STRINGS = Bean属性反射只能通过字符串完成。
MSG_EXPECTING_BRACKET_TO_CLOSE_DYNAMIC_MEMBER_ACCESS = 需要使用“]”运算符结束动态成员访问表达式。
MSG_WRONG_NUMBER_OF_ARGS_TO_FUNCTION = 函数{0}的实际参数数量不正确。需要{1}个，获得{2}个。
MSG_WRONG_NUMBER_OF_ARGS_TO_CONSTRUCTOR = 构造函数{0}的实际参数数量不正确。需要{1}个，获得{2}个。
MSG_SHOULD_HAVE_FOUND_METHOD_AT_LINE = 本应在第{0}行第{1}列找到一个函数
MSG_VOID_EXPRESSION_NOT_ALLOWED = 此位置的表达式不可为void。
MSG_EXPECTING_RETURN_TYPE_OR_FUN_BODY = 需要返回类型或函数体。
MSG_INVALID_TYPE_FOR_ANNOTATION_MEMBER = 批注成员的类型无效
MSG_ERRANT_TYPE_VAR = 错误的类型变量
MSG_USING_VOID_RETURN_TYPE_FROM_NON_NULL_EXPR = 使用来自非null表达式的void返回类型。
MSG_FIELD_TYPE_HAS_NOT_BEEN_INFERRED = 尚未推断出此字段的类型，因此无法使用。此表达式必须出现在字段声明之后。
MSG_BEAN_CLASS_IS_NULL = Bean类为null！
MSG_BEAN_MEMBER_PATH_IS_NULL = Bean成员路径为null！
MSG_BEAN_MEMBER_PATH_IS_EMPTY = Bean成员路径为空！
MSG_NO_EXPLICIT_TYPE_INFO_FOUND = 未找到{0}的显式类型信息
MSG_NO_CONSTRUCTOR_FOUND_FOR_CLASS = 未找到类{0}的构造函数
MSG_WRONG_NUMBER_OF_ARGS_FOR_METHOD_ON_CLASS = 类{1}中函数{0}的实际参数数量不正确
MSG_NO_METHOD_DESCRIPTOR_FOUND_FOR_METHOD = 未找到类{1}中函数{0}的函数描述符
MSG_METHOD_IS_NOT_STATIC = 类{1}中函数“{0}”为非静态
MSG_METHOD_IS_STATIC = 类{1}中函数“{0}”为静态
MSG_NO_PROPERTY_DESCRIPTOR_FOUND = 未找到类{2}中属性{1}的{0}属性描述符
MSG_NO_TYPE_ON_NAMESPACE = 未在包{1}中找到类型{0}
MSG_ANY = {0}
MSG_EXPECTING_MEMBER_ACCESS_PATH = 需要成员访问路径。
MSG_CANNOT_CREATE_NEW_ARRAY_FROM_TYPE_VAR = 无法从类型变量创建新的实例数组。只能对此类型进行访问和写入。
MSG_NOT_A_VALID_EXCEPTION_TYPE = {0}未扩展Throwable，无法捕获。
MSG_CANNOT_INFER_ARGUMENT_TYPE_AT_THIS_POSTION = 实际参数{0}必须提供类型声明，因为无法对其进行推断。
MSG_OBSOLETE_CTOR_SYNTAX = 此构造函数语法已过时。使用“construct”关键字代替。
MSG_OBSOLETE_NOT_EQUAL_OP = <>运算符已过时，必须替换为\!\=
MSG_MUST_BE_IN_OUTER_TO_CONSTRUCT_INNER = 必须处于类{0}中或由此类派生，才能构造非静态内部类{1}。
MSG_TYPE_DOES_NOT_HAVE_EMPTY_CONSTRUCTOR = 类型{0}没有默认构造函数且不能在此处隐式创建。
MSG_ENHANCEMENT_DOES_NOT_ACCEPT_THIS_STATEMENT = 增强不能具有此类型的语句。
MSG_CANNOT_OVERRIDE_FUNCTIONS_IN_ENHANCEMENTS = 已在类型{1}中定义函数“{0}”。增强无法覆盖函数。
MSG_CANNOT_OVERRIDE_PROPERTIES_IN_ENHANCEMENTS = 已在类型{1}中定义属性“{0}”。增强无法覆盖属性。
MSG_ENHANCED_TYPE_MUST_USE_ENHANCEMENT_TYPEVARS = 增强类型必须使用增强所声明的所有类型变量。
MSG_ABSTRACT_MEMBER_NOT_IN_ABSTRACT_CLASS = 抽象成员不在抽象类中。
MSG_ILLEGAL_USE_OF_MODIFIER = 非法使用修饰符，不能在此处将“{0}”与“{1}”一起使用。
MSG_ILLEGAL_FORWARD_REFERENCE = 非法向前引用
MSG_MISSING_OVERRIDE_MODIFIER = 缺少“override”调整系数。函数{0}覆盖和/或实现来自{1}的函数。
MSG_RENAME_METHOD = 重命名函数。函数{0}与{1}中的函数冲突，返回类型不兼容。专用函数使用“内部”访问权限进行编译，因此，当它们在同一个文件包中时，会在运行时冲突。
MSG_STATIC_METHOD_CANNOT_OVERRIDE = 静态函数 {0} 无法覆盖/实现{1}中的函数。
MSG_OVERRIDES_OBJECT_METHOD = 默认方法{0}将覆盖对象方法
MSG_INHEREITED_WITH_DIFF_ARG_TYPES = “{0}”具有不同类型的参数，因此无法继承：{1}
MSG_NO_IMPLEMENTS_ALLOWED = 接口不支持实施子句。
MSG_NO_EXTENDS_ALLOWED = 批注不允许使用扩展子句。
MSG_FUNCTION_NOT_OVERRIDE = 函数{0}不会进行任何覆盖
MSG_FUNCTION_NOT_OVERRIDE_PROPERTY = 函数{0}不会进行任何覆盖可能您想要覆盖属性{1}？
MSG_PROPERTY_OVERRIDES_WITH_INCOMPATIBLE_TYPE = 属性覆盖具有不兼容的类型
MSG_SUBCLASS_OBJECT = {0}显式对对象进行子类化
MSG_AMBIGUOUS_SYMBOL_REFERENCE = 这是一个模糊的引用。请对符号进行完全限定。
MSG_LIST_TO_ARRAYLIST_WARNING = 隐式强制转换为数组列表。请显式使用数组列表。
MSG_VAR_CASE_MISMATCH = 变量“{0}”引用的大小写不正确。请将此引用改为“{1}”。
MSG_FUNCTION_CASE_MISMATCH = 函数“{0}”引用的大小写不正确。请将此引用改为“{1}”。
MSG_PROPERTY_CASE_MISMATCH = 属性“{0}”引用的大小写不正确。请将此引用改为“{1}”。
MSG_TYPE_CASE_MISMATCH = 类型“{0}”引用的大小写不正确。请将此引用改为“{1}”。
MSG_NON_STATIC_ACCESS_OF_STATIC_MEMBER = 属性“{0}”为静态，但在类型{1}中未进行静态引用。
MSG_NON_STATIC_ACCESS_WITH_IDENTIFIER_OF_STATIC_MEMBER = 属性“{0}”为静态，但未脱离类型{1}直接引用。\n存在一个名为"{2}"的冲突变量或属性。请将表达式完全限定为{3}.{0}。
MSG_STATEMENT_ON_SAME_LINE = 多个语句占用了同一行；可能表示意外的逻辑错误。\n考虑将语句移动到新行。
MSG_MUST_BE_DEFINED_AS_CLASS = 必须定义为“类”。
MSG_VOID_RETURN_IN_CTX_EXPECTING_VALUE = 此函数需要块返回一个值。
MSG_NO_STATIC_CONSTRUCTOR = 构造函数不能为静态
MSG_NO_ABSTRACT_METHOD_CALL_IN_CONSTR = 函数{0}是抽象的，不能在构造函数中进行调用。
MSG_CALLING_OVERRIDABLE_FROM_CTOR = 从以下构造函数调用可覆盖函数： {0}
MSG_AMBIGUOUS_METHOD_INVOCATION = 这是不明确的函数调用。
MSG_RETURN_VAL_FROM_VOID_FUNCTION = 您正尝试从void函数返回值。
MSG_BAD_ANONYMOUS_CLASS_DECLARATION = 只有java和gosu类型可以通过匿名方式扩展。
MSG_SINGLE_ANON_CTOR = 一个匿名类最多可定义一个构造函数
MSG_ANON_CTOR_PARAMS_CONFLICT_WITH_CALL_SITE = 匿名构造函数参数类型与调用站点的参数类型冲突
MSG_ASSIGNMENT_IN_IF_STATEMENT = if条件内部的赋值不合法
MSG_ASSIGNMENT_IN_LOOP_STATEMENT = loop条件内部的赋值不合法
MSG_JAVA_STYLE_VARIABLE_DECLARATION = 这是java形式的变量声明。请改用“var”关键字。
MSG_NUMERIC_TYPE_EXPECTED = 需要使用数值表达式。
MSG_GETTER_CANNOT_HAVE_PARAMETERS = 属性获取定义不能包含形式参数。
MSG_BAD_TEMPLATE_DIRECTIVE = 无效模板指令。有效指令为“extends”和“params”。
MSG_CLASSPATH_STATEMENT_EXPECTS_A_STRING = classpath语句需要路径字符串
MSG_COMMA_IS_THE_CLASSPATH_SEPARATOR = classpath语句使用逗号作为独立于平台的路径分隔符
MSG_BITSHIFT_LHS_MUST_BE_INT_OR_LONG = 左侧的运算必须为整型或长整型。
MSG_BITWISE_OPERAND_MUST_BE_INT_OR_LONG = 位逻辑操作数必须为整型或长整型。
MSG_EXPECTING_LEFTPAREN_USING = 需要使用“(”开始“using”谓词。
MSG_EXPECTING_RIGHTPAREN_USING = 需要使用“)”结束“using”谓词。
MSG_BAD_TYPE_FOR_USING_STMT = Using语句的谓词必须为Closeable、IDisposable或Lock。转换为IMonitorLock以进行Java形式的同步。
MSG_UNNECESSARY_COERCION = 此表达式已为{0}类型，因此不必转换为{1}。
MSG_LATER_ASSIGNMENT_MAKES_EXPRESSION_ILLEGAL = 稍后为{0}赋值将取消可实现此使用的类型推断。
WSDL_DUPLICATE_WEB_SERVICE = 重复的Web服务名称。只能定义一个具有给定名称的Web服务。
MSG_NUMBER_LITERAL_TOO_LARGE = 数字文本过大。
WSDL_DUPLICATE_METHOD = 重复的Web服务函数。重载函数必须具有不同的形式参数数量，即使形式参数类型不同。\n{0}与{1}冲突。
WSDL_NOT_WEBSERVICE = 此批注仅在Web服务上可用
WSDL_UNSUPPORTED_TYPE = Web服务不能引用以下不受支持的类型： {0} {1}
WSDL_REFERENCE_ABSTRACT_CLASS = Web服务不能引用抽象类： {0} {1}
WSDL_REFERENCE_INTERFACE = Web服务不能引用接口： {0} {1}
WSDL_REFERENCE_ANNOTATION = Web服务不能引用批注：{0} {1}
WSDL_REFERENCE_TRANSACTION_TYPE = Web服务不能引用gw.transaction.*命名空间中的类型： {0} {1}
WSDL_REFERENCE_LIST = Web服务不能引用列表类型： {0}。请尝试强类型数组（如，String[]）。 {1}
WSDL_REFERENCE_MAP = Web服务不能引用映射类型： {0} {1}
WSDL_REFERENCE_COLLECTION = Web服务不能引用集合类型： {0}。请尝试强类型数组（如，String[]）。 {1}
WSDL_REFERENCE_PARAMETERIZED_TYPE = Web服务不能引用参数化类型： {0}
WSDL_REFERENCE_GENERIC_TYPE = Web服务不能引用泛化类型： {0} {1}
WSDL_REFERENCE_UNSUPPORTED_NAMESPACE = Web服务不能引用以下类型。它是不受支持的命名空间的一部分，只支持来自命名空间“gw.*”（gw.transaction.*除外（的类型：{0} {1}
WSDL_REFERENCE_CLASS_WITHOUT_DEFAULT_CONSTRUCTOR = 类{0}没有默认构造函数，无法由Web服务引用。{1}   //这可能是警告。
WSDL_REFERENCE_WEBSERVICE = Web服务不能引用其它Web服务类型： {0} {1}
WSDL_REFERENCE_SOAP_TYPE = Web服务不能引用soap.*命名空间中的类型： {0} {1}
WSDL_REFERENCE_XML_TYPE = RPC Web服务不能引用基于xml的类型： {0} {1}
WSDL_READONLY_PROPERTIES = Web服务不应引用具有只读属性的类型。\n不能将这些类型设置为Web服务操作的形式参数。 {0} {1}
WSDL_WRITEONLY_PROPERTIES = Web服务不应引用具有只写属性的类型。\n不能将这些类型设置为Web服务运算的返回类型。 {0} {1}
WSDL_REFERENCE_CAUSES_NAMESPACE_COLLISION = 此类型导致Web服务命名空间冲突。\n这两种类型具有相同的相对名称并且将以相同的命名空间soap.*.{0}公开到Web服务。\n重命名下面一种类型或确保不在Web服务中对其进行引用\:{1}和{2}。  {3}
MSG_DELEGATION_NOT_ALLOWED_HERE = 此处不允许委派
MSG_DELEGATE_MUST_NOT_BE_STATIC = 不支持静态委派
MSG_DELEGATES_REPRESENT_INTERFACES_ONLY = 委派只能代表接口类型
MSG_ONLY_INTERFACES_ALLOWED_HERE = 此处仅允许使用接口
MSG_ONLY_ONE_CLASS_IN_COMPONENT_TYPE = 一个组件类型仅允许一个非接口
MSG_ONLY_ONE_TYPE_VARIABLE = 类型变量不得后跟其他界限
MSG_NO_ARRAY_IN_COMPONENT_TYPE = 组件类型中不允许有数组
MSG_NO_PRIMITIVE_IN_COMPONENT_TYPE = 组件类型中不允许有基元
MSG_COMPOUND_TYPE_NOT_ALLOWED_HERE = 此处不允许复合类型
MSG_PARAMETERIZED_TYPE_NOT_ALLOWED_HERE = 此处不允许使用参数化类型
MSG_DYNAMIC_TYPE_NOT_ALLOWED_HERE = 此处不允许使用动态类型
MSG_CANNOT_EXTEND_INTERNAL_JAVATYPE = Java类型{0}具有包保护访问，因而无法在Gosu中扩展或增强
MSG_CLASS_DOES_NOT_IMPL = 声明类型未实现的委派接口\: {0}
MSG_EXPECTING_REPRESENTS = 委派需要“represents”子句
MSG_EXPECTING_LEFTPAREN_AGGREGATE = 需要使用“(”开始累计类型
MSG_EXPECTING_RIGHTPAREN_AGGREGATE = 需要使用“)”结束累计类型
MSG_MEMBER_ACCESS_REQUIRED_FOR_SUPER = “super”需要成员访问权限
MSG_ALREADY_CONTAINS_TYPE = 已指定类型{0}
MSG_OVERRIDING_FUNCTION_MUST_HAVE_SAME_NUMBER_OF_TYPE_VARS = 此函数要正确覆盖其父函数，必须拥有{0}类型的变量
MSG_AGGREGATES_MUST_CONTAIN_MORE = 累计类型必须有一个以上的类型
MSG_INTERFACE_REDUNDANT = 接口{0}冗余，{1}扩展{0}
MSG_NONTERMINAL_CASE_CLAUSE = 之前的case子句未终止；可能缺少break、continue或return语句
MSG_ANONYMOUS_CLASS_NOT_ALLOWED_HERE = 此处不允许使用匿名类
MSG_PARAMETERIZED_ARRAY_COMPONENT = 参数化的数组组件类型在运行时缺少类型形式参数
MSG_TEMPLATE_EXCEPTION_GENERATED_SOURCE = 已生成源
MSG_TEMPLATE_MISSING_END_TAG_SCRIPTLET = Scriptlet缺少结束标记“%>”。
MSG_TEMPLATE_MISSING_END_TAG_EXPRESSION = 表达式缺少结束标记“%>”。
MSG_TEMPLATE_MISSING_END_TAG_EXPRESSION_ALT = 表达式缺少结束标记“}”。
MSG_TEMPLATE_MULTIPLE_PARAMS = 找到多个“params”指令。
MSG_TEMPLATE_INVALID_PARAMS = 无效形式参数： {0}
MSG_TEMPLATE_UNKNOWN_DIRECTIVE = 未知指令{0}。有效指令为“params”和“extends”。
MSG_EQUALS_FOR_INITIALIZER_EXPR = 此对象初始化程序中需要“\=”。
MSG_INITIALIZER_NOT_ALLOWED_ABSTRACT_PROPERTY = 抽象属性上不允许使用初始化程序。
MSG_EXPECTING_NAME_VALUE_PAIR = 需要在属性名称后接“\=”和表达式值。
MSG_REDUNTANT_INITIALIZERS = 属性{0}已具有初始化程序值。
MSG_ONLY_ONE_COLON_IN_INITIALIZERS = 初始化程序的属性名称前只能有一个冒号。
MSG_EXPECTING_PROPERTY_NAME = 需要属性名称。
MSG_BLOCK_TYPES_SHOULD_HAVE_ARG_NAMES = 块类型参数应指定名称并采用“argName\:Type”形式。
MSG_DIMENSION_MULTIPLICATION_UNDEFINED = 维度间的乘积未定义
MSG_DIMENSION_ADDITION_MUST_BE_SAME_TYPE = 操作数必须同为相同最终类型的维度
MSG_DIMENSION_DIVIDE_SCALAR_BY_DIMENSION = 无法用标量除以维度
MSG_DIMENSION_MUST_BE_FINAL = 维度算法必须包含最终类型。{0}不是最终类型。
MSG_DIMENSION_NONSTANDARD_NUMBER_NO_OVERRIDE = 维度{0}缺少算法，具有非标准数字类型{1}
MSG_RELATIONAL_OPERATOR_CANNOT_BE_APPLIED_TO_TYPE = 关系运算符{0}不能应用于类型{1}
MSG_ARITHMETIC_OPERATOR_CANNOT_BE_APPLIED_TO_TYPES = 运算符“{0}”不能应用于“{1}”，“{2}”
MSG_ASSIGNMENTS_MUST_BE_ENCLOSED_IN_CURLIES_IN_BLOCKS = 块主体中的赋值必须括在大括号中
MSG_BLOCKS_CAN_HAVE_A_MOST_SIXTEEN_ARGS = 块最多可拥有 16 个实际参数。
MSG_BLOCKS_LITERAL_NOT_ALLOWED_IN_NEW_EXPR = 新表达式中不允许使用块文本。
MSG_STATEMENTS_MUST_BE_ENCLOSED_IN_CURLIES_IN_BLOCKS = 块主体中的“{0}”语句必须括在大括号中
MSG_NOT_AN_ENHANCEABLE_TYPE = {0}不支持增强。
MSG_CANNOT_REFERENCE_CLASS_TYPE_VAR_IN_STATIC_CONTEXT = 您不能在静态上下文中引用类类型变量。
MSG_CANNOT_REFERENCE_THIS_IN_STATIC_CONTEXT = 您无法在静态上下文中引用“此”。
MSG_CANNOT_CALL_NON_STATIC_METHOD_FROM_STATIC_CONTEXT = 您不能在静态上下文中引用非静态方法。
MSG_CANNOT_REFERENCE_NON_STATIC_PROPERTY_FROM_STATIC_CONTEXT = 您不能在静态上下文中引用非静态属性。
MSG_CANNOT_REFERENCE_NON_STATIC_FEATURE_HERE = 此处不能引用非静态功能
MSG_ONLY_GOSU_JAVA_TYPES = 此处仅允许Gosu和Java类型
MSG_CANNOT_READ_A_WRITE_ONLY_PROPERTY = 只能对只写属性进行写入
MSG_TYPE_IS_NOT_ITERABLE = 需要为扩展运算符使用可迭代类型 - {0}
MSG_INTERVAL_MUST_BE_ITERABLE_HERE = 此处的间隔类型必须可迭代
MSG_EXTRA_DOT_FOUND_IN_INTERVAL = 间隔运算符有两个点，找到三个
MSG_EXPECTING_NUMBER_TO_FOLLOW_DECIMAL = 需要十进制数
MSG_IMPROPER_VALUE_FOR_NUMERIC_TYPE = 值{0}未落在类型{1}的数域之内
MSG_PRIMITIVE_TYPE_PARAM = 此处不支持基元类型{0}。类型{0}已作为类型形式参数隐式转换为{1}，请直接使用{1}。
MSG_CTOR_HAS_XXX_ACCESS = 构造函数具有{0}访问
MSG_TYPE_HAS_XXX_ACCESS = 类型{0}具有{1}访问
MSG_QUERY_SPECIFY_COLUMN = 指定查询列
MSG_QUERY_SPECIFY_QUERY_COLUMN = {0}必须指定可查询的数据库中的列
MSG_CANNOT_EXTEND_RAW_GENERIC_TYPE = 泛型类型{0}需要类型参数
MSG_TYPE_VAR_VARIANCE_ERROR = 类型变量{0}已声明为“{1}”，但是在“{2}”位置使用时类型为{3}
MSG_SUPER_CLASS_METHOD_NAME_SAME_AS_SUBCLASS = 超类方法{0}与此类的内部构造函数名称冲突。请更改超类方法名称或此类名称。
MSG_NOT_A_SUPERTYPE = {0]不是直接超类型
MSG_CALL_TO_SUPER_THIS_MUST_BE_FIRST = 对{0}()的调用必须是构造函数中的第一个语句
MSG_EXPECTING_OPERATOR_TO_FOLLOW_NEW_EXPRESSION = 不完整的语句。需要在新表达式后使用运算符。
MSG_EXPECTING_TYPE_TO_FOLLOW_PACKAGE_NAME = 需要在包名称后接类型
MSG_QUERY_FUNCTION_EXPRESSION_RESTRICTION = 只允许引用数据库列或DBFunction方法调用
MSG_QUERY_ORDER_BY_EXPRESSION = 只允许包含数据库列的成员访问表达式。
MSG_QUERY_ARRAYS_NOT_ALLOWED = 此处不允许访问数组。
MSG_APPLICATION_MODIFIER_HAS_BEEN_DEPRECATED = 不建议使用“application”修饰符。请改为使用 gw.api.web.Scopes.Application 映射。
MSG_SESSION_MODIFIER_HAS_BEEN_DEPRECATED = 不建议使用“session”修饰符。请改为使用 gw.api.web.SessionVar。
MSG_REQUEST_MODIFIER_HAS_BEEN_DEPRECATED = 不建议使用“request”修饰符。请改为使用 gw.api.web.RequestVar。
MSG_EXECUTION_MODIFIER_HAS_BEEN_DEPRECATED = “execution”修饰符已不建议使用，它没有意义。将其移除即可。
MSG_CANNOT_REFERENCE_OUTER_SYMBOL_WITHIN_ENHANCEMENTS = 不能在增强中引用outer关键字。考虑将此匿名类移动到已命名类。
MSG_CANNOT_REFERENCE_ENCLOSING_PROPERTIES_WITHIN_ENHANCEMENTS = 不能在增强中引用封闭类型的方法。考虑将此匿名类移动到已命名类。
MSG_CANNOT_REFERENCE_ENCLOSING_METHODS_WITHIN_ENHANCEMENTS = 不能在增强中引用封闭类型的方法。考虑将此匿名类移动到已命名类。
MSG_INVALID_LITERAL = 文本无法转换为{0}。您需要显式构造此值。
MSG_PROPERTIES_MUST_AGREE_ON_STATIC_MODIFIERS = 属性的获取函数和设置函数必须同时为静态或非静态
MSG_PROPERTIES_MUST_AGREE_ON_TYPE = 属性的获取函数和设置函数必须在属性类型上保持一致
MSG_NO_ENCLOSING_INSTANCE_IN_SCOPE = 范围内无“{0}”类型的封闭实例
MSG_EXPECTING_CONDITION_FOR_ASSERT = 需要使用“assert”条件
MSG_EXPECTING_MESSAGE_FOR_ASSERT = 需要“assert”的消息
MSG_ASSERTIONS_NOT_ALLOWED_HERE = 此处不允许使用Assert语句
MSG_ARRAY_NOT_SUPPORTED = {0}不支持数组类型
MSG_IMPROPER_USE_OF_KEYWORD = 关键字使用错误，{0}
MSG_USES_STMT_CONFLICT = 已使用类型，{0}
MSG_USES_STMT_DUPLICATE = 使用语句重复
MSG_ARRAY_INDEX_MUST_BE_INT = 数组必须用整型值进行索引
MSG_PARAM_TYPE_CANT_BE_INFERRED_FROM_LATE_BOUND_EXPRESSION = 无法从逾期绑定表达式类型推断形式参数类型
MSG_LOSS_OF_PRECISION_IN_NUMERIC_LITERAL = 这一双文本在此操作中会丢失精度。必须显式将其声明为BigDecimal，而不是： {0}
MSG_COMPILE_TIME_ANNOTATION_FAILED_TO_EXECUTE = 编译时批注执行失败。消息为{0}。请查看控制台以获得堆栈跟踪信息。
MSG_METHOD_REIFIES_TO_SAME_SIGNATURE_AS_ANOTHER_METHOD = 具有相同名称的方法具体到字节码等级的相同签名。重命名其中一个方法。
MSG_TYPE_NOT_REIFIED = {0}必须使用“已具体化”调整系数进行声明，才能在运行时访问类型变量“{1}”。
MSG_REIFIED_DONT_MATCH = 必须覆盖具有相同“已具体化”设置的函数
MSG_REIFIED_DONT_MATCH_JAVA = 已具体化的通用方法{0}覆盖{1}中的Java方法。从{1}调用{0}会擦除类型形式参数。
NOTHING_TO_REIFY = 无需具体化任何内容
MSG_PROPERTY_AND_FUNCTION_CONFLICT = 方法{0}与属性{1}生成的隐式方法冲突
MSG_PROPERTY_AND_FUNCTION_CONFLICT_UPON_REIFICATION = 方法{0}与属性{1}在具体化时生成的隐式方法冲突
MSG_CANNOT_OVERRIDE_FUNCTION_FROM_ENHANCEMENT = 无法覆盖在增强上定义的方法。
MSG_MASKING_ENHANCEMENT_METHODS_MAY_BE_CONFUSING = 此方法屏蔽了在此类型的增强上定义的方法。这可能会导致语义混淆，因为增强方法是静态分派的。
MSG_STRING_COERCION_ON_RHS_OF_ADDITIVE_EXPRESSION_MUST_BE_PARENTHESIZED = 转换为加法表达式中的字符串可能会产生混淆。请将表达式加上括号以便正确求值。
MSG_EXPLICIT_TYPE_RECOMMENDED_FOR_CATCH_STMTS = 此处应添加一个显式捕获的类型。
MSG_SUPER_NOT_ACCESSIBLE_FROM_BLOCK = 无法从块内访问超级符号。
MSG_GENERIC_PROPERTIES_NOT_SUPPORTED = 属性不能有类型变量。
MSG_GENERIC_ANNOTATIONS_NOT_SUPPORTED = 批注不能具有类型变量。
MSG_CATCH_STMT_CANNOT_EXECUTE = 此捕捉语句永远不会执行，因为先前的捕捉语句已经捕捉了此类型的异常。
MSG_IMONITOR_LOCK_SHOULD_ONLY_BE_USED_WITHIN_USING_STMTS = IMonitorLock界面仅能用于使用遗留同步语句的表达式形式中。
MSG_STATIC_MODIFIER_NOT_ALLOWED_HERE = 此处不允许“static”修饰符。
MSG_MODIFIERS_NOT_ALLOWED_HERE = 此处不允许使用调整系数。
MSG_CANNOT_INSTANTIATE_NON_STATIC_CLASSES_HERE = 此处无法实例化非静态类。
MSG_WARN_ON_SUSPICIOUS_THIS_COMPARISON = 这似乎是一个不当比较。在gosu中，“\=\=”运算符等于.equals()。如果要实现实例相等，请使用“\=\=\=”运算符。
MSG_FL_EXPECTING_FEATURE_NAME = 此处需要一个特征名，方法名称、属性名或“construct”均可
MSG_FL_EXPECTING_RIGHT_CARET = 需要使用“>”
MSG_FL_GENERIC_FUNCTION_REFERENCES_NOT_YET_SUPPORTED = 目前还不支持通用函数文本。
MSG_FL_EXPECTING_RIGHT_PAREN = 需要使用“)”结束实际参数类型列表。
MSG_FL_CONSTRUCTOR_NOT_FOUND = 未找到类型为{0}的构造函数
MSG_FL_METHOD_NOT_FOUND = 未找到名称为{0}且类型为{1}的方法
MSG_FL_PROPERTY_NOT_FOUND = 未找到名称为{0}的属性
MSG_FL_STATIC_FEATURES_MUST_BE_REFERENCED_FROM_THEIR_TYPES = 必须在特征所属的类型上直接引用静态特征或构造函数。
MSG_NO_TYPE_AFTER_CONSTRUCTOR = 构造函数无法指定返回类型。
WS_ERR_Can_Not_Marshal = {0}无法对{1}的本地类型{2}进行排列。
WS_ERR_Annotation_Duplicate_Namespace = 在{0}上：已经在“{2}”中使用了重复的命名空间“{1}”。{3}尝试为{4}再次引入该命名空间。
WS_ERR_Annotation_Exception = 将忽略类型{0}的属性，请参阅堆栈跟踪日志
WS_ERR_Annotation_Invalid_Namespace = {0}：命名空间“{1}”无效
WS_ERR_Annotation_Only_For_WebService = {0}：@{1}批注仅适用于用@WsiWebService进行批注的类
WS_ERR_Annotation_Operation_Duplicate = 在{0}上：已经有一个与方法{1}同名的方法
WS_ERR_Annotation_Operation_OneWay_Invalid = 单向方法应具有void返回类型
WS_ERR_Annotation_Operation_Response_Reserved = 在{0}上：对于方法{1}，后缀“Response”保留用于响应元素
WS_ERR_Export_Inner_Only_On_WebService = 在{0}上：类型{1}的内部类不可导出
WS_ERR_Export_Inner_Not_Name_Of_Method = 内部类名称与方法{0}要求的相同
WS_ERR_Export_Inner_Not_Name_Of_Response = 内部类与方法{0}的响应具有相同的名称
WS_ERR_Export_No_Constructor = 在{0}上：类型{1}的可导出类需要一个公共的默认构造函数
WS_ERR_Export_No_Extends = 在{0}上：类型{1}的可导出类无法扩展另一个类
WS_ERR_Export_Not_Final = 在{0}上：类型{1}不是最终类型。可导出的类必须是最终类型
WS_ERR_Export_Not_WebService = 在{0}上：类型{1}是Web服务。Web服务不能是可导出的服务
WS_ERR_Export_Recursive = 不支持递归，必须确保{0}为非递归
WS_WARN_Annontation_Some_Generators_Dont_Support_Schema = {0}处理形式参数{1}时发出警告，某些Web服务框架可能无法理解{2}
WS_WARN_Annontation_Not_Available = {0} 在{1}之前无效
WS_WARN_Ignored = {0} ： 将忽略类型{2}的属性{1}
PCF_ERR_Verify = 尝试验证{0}时发生了PCF错误。
MSG_FL_ONLY_PROPERTIES_MAY_BE_CHAINED = 只能链接属性文本。
Gen_Wsi_InvalidType = {0}无法对{1}进行排列：{2}
Gen_Wsi_UnsupportedType = {0}是有效类型，但不受Web服务支持。
Gen_Wsi_UnsupportedComponentType = {0}不受支持，因为它的组件/形式参数类型不受支持。
Gen_Wsi_NoComponentType = {0}不受支持，因为没有指定组件/形式参数类型。
Gen_Wsi_NoBase = {0}XmlBase类不受直接支持。
Gen_Wsi_AnonElement = 0}：匿名元素不受支持。匿名元素是另一个元素的子项。您可以尝试使用子元素的类型。
Gen_Wsi_AnonType = {0}匿名类型（在元素声明中声明的类型）不受支持。您可以尝试使用该元素。
Gen_Wsi_NoSimple = {0}XSD简单类型不受支持。您可以尝试创建复杂类型或者使用扩展类型。
Gen_Wsi_XmlError = 处理{0}时发生意外错误：{1}
Gen_Wsi_NullType = 传递的类型为空
Gen_Wsi_TypeNotGosu = {0}不是gosu，因此不受WSI实施的支持。
Gen_Wsi_TypeNotWSAnnotated = {0}没有@WsiWebService批注。
Gen_Wsi_TypeNotEXPAnnotated = {0}没有@WsiExportable批注。
GEN_CAN_NOT_MARSHAL_GOSU_REMOTEABLE_ENUMS = {0}无法对使用Gosu编写的GWEnumeration进行排列
GEN_CAN_NOT_MARSHAL_REMOTEABLE_ENUMS_EXTENDED = {0}无法对具有额外属性的GWEnumeration进行排列。
GEN_CAN_NOT_MARSHAL_XML_IN_EXPORTABLE = {0}无法对WsiExportable类型中的XML进行排列
GEN_CLASS_CANNOT_BE_BOTH_WS_AND_EXPORT = {0}类不能既是@WsiWebService又是{1}
GEN_CHECKING = 检查{0}
GEN_CHANGED = 已更改{0}
WS_ERR_Invalid_Supertype = {0}无法扩展{1}
WS_ERR_Export_Empty = {0}没有可导出的属性
WS_ERR_Previous_Invalid = {0}无效。以前报告的错误
WS_ERR_Entity_Invalid = {0}无效。我们不支持排列实体，请通过必填字段创建WsiExportable类。
WS_ERR_Collection_Invalid = {0}无效。仅支持数组和列表<T>。
WF_WARN_Subtype = 工作流子类型“{0}”被定义为非外部类型，但是未定义脚本或者脚本无法解析。请检查日志，确认是否存在任何解析失败。
WF_ERR_Duplicate = 用相同的类型代码“{0}”和版本“{1}”定义了多个工作流进程。
WF_ERR_Parse = 无法解析“{0}”-- {1}：{2}
WF_ERR_Convert = 无法转换“{0}”-- {1}：{2}
WF_ERR = 在“{0}”上：{1}
